/*
 * Copyright (C) 2023 Texas Instruments Incorporated
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the
 *   distribution.
 *
 *   Neither the name of Texas Instruments Incorporated nor the names of
 *   its contributors may be used to endorse or promote products derived
 *   from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "utils/mbedtls_test_utils.h"

/* ========================================================================== */
/*                           TEST-DATA DECLARATION                            */
/* ========================================================================== */

/*
    data_ecdsa is an array of string literals of test data for mbedTLS sanity tests for ECDSA,
    these data vectors will be used in case of both software and hardware cryptography offloaded mbedTLS (TO DO)
*/

const char* data_ecdsa[] = {
    "depends_on:0",
    "0:exp:0",
    "depends_on:1",
    "0:exp:1",
    "depends_on:2",
    "0:exp:2",
    "depends_on:3",
    "0:exp:3",
    "depends_on:4",
    "0:exp:4",
    "depends_on:2",
    "1:exp:2:char*:\"DC51D3866A15BACDE33D96F992FCA99DA7E6EF0934E7097559C27F1614C88A7F\":char*:\"2442A5CC0ECD015FA3CA31DC8E2BBC70BF42D60CBCA20085E0822CB04235E970\":char*:\"6FC98BD7E50211A4A27102FA3549DF79EBCB4BF246B80945CDDFE7D509BBFD7D\":hex:\"9E56F509196784D963D1C0A401510EE7ADA3DCC5DEE04B154BF61AF1D5A6DECE\":hex:\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\":char*:\"CB28E0999B9C7715FD0A80D8E47A77079716CBBF917DD72E97566EA1C066957C\":char*:\"86FA3BB4E26CAD5BF90B7F81899256CE7594BB1EA0C89212748BFF3B3D5B0315\":int:0",
    "depends_on:3",
    "1:exp:3:char*:\"0BEB646634BA87735D77AE4809A0EBEA865535DE4C1E1DCB692E84708E81A5AF62E528C38B2A81B35309668D73524D9F\":char*:\"96281BF8DD5E0525CA049C048D345D3082968D10FEDF5C5ACA0C64E6465A97EA5CE10C9DFEC21797415710721F437922\":char*:\"447688BA94708EB6E2E4D59F6AB6D7EDFF9301D249FE49C33096655F5D502FAD3D383B91C5E7EDAA2B714CC99D5743CA\":hex:\"B4B74E44D71A13D568003D7489908D564C7761E229C58CBFA18950096EB7463B854D7FA992F934D927376285E63414FA\":hex:\"CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED1631A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7\":char*:\"FB017B914E29149432D8BAC29A514640B46F53DDAB2C69948084E2930F1C8F7E08E07C9C63F2D21A07DCB56A6AF56EB3\":char*:\"B263A1305E057F984D38726A1B46874109F417BCA112674C528262A40A629AF1CBB9F516CE0FA7D2FF630863A00E8B9F\":int:0",
    "depends_on:4",
    "1:exp:4:char*:\"0065FDA3409451DCAB0A0EAD45495112A3D813C17BFD34BDF8C1209D7DF5849120597779060A7FF9D704ADF78B570FFAD6F062E95C7E0C5D5481C5B153B48B375FA1\":char*:\"0151518F1AF0F563517EDD5485190DF95A4BF57B5CBA4CF2A9A3F6474725A35F7AFE0A6DDEB8BEDBCD6A197E592D40188901CECD650699C9B5E456AEA5ADD19052A8\":char*:\"006F3B142EA1BFFF7E2837AD44C9E4FF6D2D34C73184BBAD90026DD5E6E85317D9DF45CAD7803C6C20035B2F3FF63AFF4E1BA64D1C077577DA3F4286C58F0AEAE643\":hex:\"00C1C2B305419F5A41344D7E4359933D734096F556197A9B244342B8B62F46F9373778F9DE6B6497B1EF825FF24F42F9B4A4BD7382CFC3378A540B1B7F0C1B956C2F\":hex:\"DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA20A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD454D4423643CE80E2A9AC94FA54CA49F\":char*:\"0154FD3836AF92D0DCA57DD5341D3053988534FDE8318FC6AAAAB68E2E6F4339B19F2F281A7E0B22C269D93CF8794A9278880ED7DBB8D9362CAEACEE544320552251\":char*:\"017705A7030290D1CEB605A9A1BB03FF9CDD521E87A696EC926C8C10C8362DF4975367101F67D1CF9BCCBF2F3D239534FA509E70AAC851AE01AAC68D62F866472660\":int:0",
    "depends_on:0",
    "3:exp:0",
    "depends_on:1",
    "3:exp:1",
    "depends_on:2",
    "3:exp:2",
    "depends_on:3",
    "3:exp:3",
    "depends_on:4",
    "3:exp:4",
    "depends_on:0:5",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:5:char*:\"sample\":char*:\"98C6BD12B23EAF5E2A2045132086BE3EB8EBD62ABF6698FF\":char*:\"57A22B07DEA9530F8DE9471B1DC6624472E8E2844BC25B64\"",
    "depends_on:0:6",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:6:char*:\"sample\":char*:\"A1F00DAD97AEEC91C95585F36200C65F3C01812AA60378F5\":char*:\"E07EC1304C7C6C9DEBBE980B9692668F81D4DE7922A0F97A\"",
    "depends_on:0:6",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:7:char*:\"sample\":char*:\"4B0B8CE98A92866A2820E20AA6B75B56382E0F9BFD5ECB55\":char*:\"CCDB006926EA9565CBADC840829D8C384E06DE1F1E381B85\"",
    "depends_on:0:7",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:8:char*:\"sample\":char*:\"DA63BF0B9ABCF948FBB1E9167F136145F7A20426DCC287D5\":char*:\"C3AA2C960972BD7A2003A57E1C4C77F0578F8AE95E31EC5E\"",
    "depends_on:0:7",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:9:char*:\"sample\":char*:\"4D60C5AB1996BD848343B31C00850205E2EA6922DAC2E4B8\":char*:\"3F6E837448F027A1BF4B34E796E32A811CBB4050908D8F67\"",
    "depends_on:0:5",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:5:char*:\"test\":char*:\"0F2141A0EBBC44D2E1AF90A50EBCFCE5E197B3B7D4DE036D\":char*:\"EB18BC9E1F3D7387500CB99CF5F7C157070A8961E38700B7\"",
    "depends_on:0:6",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:6:char*:\"test\":char*:\"6945A1C1D1B2206B8145548F633BB61CEF04891BAF26ED34\":char*:\"B7FB7FDFC339C0B9BD61A9F5A8EAF9BE58FC5CBA2CB15293\"",
    "depends_on:0:6",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:7:char*:\"test\":char*:\"3A718BD8B4926C3B52EE6BBE67EF79B18CB6EB62B1AD97AE\":char*:\"5662E6848A4A19B1F1AE2F72ACD4B8BBE50F1EAC65D9124F\"",
    "depends_on:0:7",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:8:char*:\"test\":char*:\"B234B60B4DB75A733E19280A7A6034BD6B1EE88AF5332367\":char*:\"7994090B2D59BB782BE57E74A44C9A1C700413F8ABEFE77A\"",
    "depends_on:0:7",
    "2:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD4\":exp:9:char*:\"test\":char*:\"FE4F4AE86A58B6507946715934FE2D8FF9D95B6B098FE739\":char*:\"74CF5605C98FBA0E1EF34D4B5A1577A7DCF59457CAE52290\"",
    "depends_on:1:5",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:5:char*:\"sample\":char*:\"22226F9D40A96E19C4A301CE5B74B115303C0F3A4FD30FC257FB57AC\":char*:\"66D1CDD83E3AF75605DD6E2FEFF196D30AA7ED7A2EDF7AF475403D69\"",
    "depends_on:1:6",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:6:char*:\"sample\":char*:\"1CDFE6662DDE1E4A1EC4CDEDF6A1F5A2FB7FBD9145C12113E6ABFD3E\":char*:\"A6694FD7718A21053F225D3F46197CA699D45006C06F871808F43EBC\"",
    "depends_on:1:6",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:7:char*:\"sample\":char*:\"61AA3DA010E8E8406C656BC477A7A7189895E7E840CDFE8FF42307BA\":char*:\"BC814050DAB5D23770879494F9E0A680DC1AF7161991BDE692B10101\"",
    "depends_on:1:7",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:8:char*:\"sample\":char*:\"0B115E5E36F0F9EC81F1325A5952878D745E19D7BB3EABFABA77E953\":char*:\"830F34CCDFE826CCFDC81EB4129772E20E122348A2BBD889A1B1AF1D\"",
    "depends_on:1:7",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:9:char*:\"sample\":char*:\"074BD1D979D5F32BF958DDC61E4FB4872ADCAFEB2256497CDAC30397\":char*:\"A4CECA196C3D5A1FF31027B33185DC8EE43F288B21AB342E5D8EB084\"",
    "depends_on:1:5",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:5:char*:\"test\":char*:\"DEAA646EC2AF2EA8AD53ED66B2E2DDAA49A12EFD8356561451F3E21C\":char*:\"95987796F6CF2062AB8135271DE56AE55366C045F6D9593F53787BD2\"",
    "depends_on:1:6",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:6:char*:\"test\":char*:\"C441CE8E261DED634E4CF84910E4C5D1D22C5CF3B732BB204DBEF019\":char*:\"902F42847A63BDC5F6046ADA114953120F99442D76510150F372A3F4\"",
    "depends_on:1:6",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:7:char*:\"test\":char*:\"AD04DDE87B84747A243A631EA47A1BA6D1FAA059149AD2440DE6FBA6\":char*:\"178D49B1AE90E3D8B629BE3DB5683915F4E8C99FDF6E666CF37ADCFD\"",
    "depends_on:1:7",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:8:char*:\"test\":char*:\"389B92682E399B26518A95506B52C03BC9379A9DADF3391A21FB0EA4\":char*:\"414A718ED3249FF6DBC5B50C27F71F01F070944DA22AB1F78F559AAB\"",
    "depends_on:1:7",
    "2:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C1\":exp:9:char*:\"test\":char*:\"049F050477C5ADD858CAC56208394B5A55BAEBBE887FDF765047C17C\":char*:\"077EB13E7005929CEFA3CD0403C7CDCC077ADF4E44F3C41B2F60ECFF\"",
    "depends_on:2:5",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:5:char*:\"sample\":char*:\"61340C88C3AAEBEB4F6D667F672CA9759A6CCAA9FA8811313039EE4A35471D32\":char*:\"6D7F147DAC089441BB2E2FE8F7A3FA264B9C475098FDCF6E00D7C996E1B8B7EB\"",
    "depends_on:2:6",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:6:char*:\"sample\":char*:\"53B2FFF5D1752B2C689DF257C04C40A587FABABB3F6FC2702F1343AF7CA9AA3F\":char*:\"B9AFB64FDC03DC1A131C7D2386D11E349F070AA432A4ACC918BEA988BF75C74C\"",
    "depends_on:2:6",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:7:char*:\"sample\":char*:\"EFD48B2AACB6A8FD1140DD9CD45E81D69D2C877B56AAF991C34D0EA84EAF3716\":char*:\"F7CB1C942D657C41D436C7A1B6E29F65F3E900DBB9AFF4064DC4AB2F843ACDA8\"",
    "depends_on:2:7",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:8:char*:\"sample\":char*:\"0EAFEA039B20E9B42309FB1D89E213057CBF973DC0CFC8F129EDDDC800EF7719\":char*:\"4861F0491E6998B9455193E34E7B0D284DDD7149A74B95B9261F13ABDE940954\"",
    "depends_on:2:7",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:9:char*:\"sample\":char*:\"8496A60B5E9B47C825488827E0495B0E3FA109EC4568FD3F8D1097678EB97F00\":char*:\"2362AB1ADBE2B8ADF9CB9EDAB740EA6049C028114F2460F96554F61FAE3302FE\"",
    "depends_on:2:5",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:5:char*:\"test\":char*:\"0CBCC86FD6ABD1D99E703E1EC50069EE5C0B4BA4B9AC60E409E8EC5910D81A89\":char*:\"01B9D7B73DFAA60D5651EC4591A0136F87653E0FD780C3B1BC872FFDEAE479B1\"",
    "depends_on:2:6",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:6:char*:\"test\":char*:\"C37EDB6F0AE79D47C3C27E962FA269BB4F441770357E114EE511F662EC34A692\":char*:\"C820053A05791E521FCAAD6042D40AEA1D6B1A540138558F47D0719800E18F2D\"",
    "depends_on:2:6",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:7:char*:\"test\":char*:\"F1ABB023518351CD71D881567B1EA663ED3EFCF6C5132B354F28D3B0B7D38367\":char*:\"019F4113742A2B14BD25926B49C649155F267E60D3814B4C0CC84250E46F0083\"",
    "depends_on:2:7",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:8:char*:\"test\":char*:\"83910E8B48BB0C74244EBDF7F07A1C5413D61472BD941EF3920E623FBCCEBEB6\":char*:\"8DDBEC54CF8CD5874883841D712142A56A8D0F218F5003CB0296B6B509619F2C\"",
    "depends_on:2:7",
    "2:exp:2:char*:\"C9AFA9D845BA75166B5C215767B1D6934E50C3DB36E89B127B8A622B120F6721\":exp:9:char*:\"test\":char*:\"461D93F31B6540894788FD206C07CFA0CC35F46FA3C91816FFF1040AD1581A04\":char*:\"39AF9F15DE0DB8D97E72719C74820D304CE5226E32DEDAE67519E840D1194E55\"",
    "depends_on:3:5",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:5:char*:\"sample\":char*:\"EC748D839243D6FBEF4FC5C4859A7DFFD7F3ABDDF72014540C16D73309834FA37B9BA002899F6FDA3A4A9386790D4EB2\":char*:\"A3BCFA947BEEF4732BF247AC17F71676CB31A847B9FF0CBC9C9ED4C1A5B3FACF26F49CA031D4857570CCB5CA4424A443\"",
    "depends_on:3:6",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:6:char*:\"sample\":char*:\"42356E76B55A6D9B4631C865445DBE54E056D3B3431766D0509244793C3F9366450F76EE3DE43F5A125333A6BE060122\":char*:\"9DA0C81787064021E78DF658F2FBB0B042BF304665DB721F077A4298B095E4834C082C03D83028EFBF93A3C23940CA8D\"",
    "depends_on:3:6",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:7:char*:\"sample\":char*:\"21B13D1E013C7FA1392D03C5F99AF8B30C570C6F98D4EA8E354B63A21D3DAA33BDE1E888E63355D92FA2B3C36D8FB2CD\":char*:\"F3AA443FB107745BF4BD77CB3891674632068A10CA67E3D45DB2266FA7D1FEEBEFDC63ECCD1AC42EC0CB8668A4FA0AB0\"",
    "depends_on:3:7",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:8:char*:\"sample\":char*:\"94EDBB92A5ECB8AAD4736E56C691916B3F88140666CE9FA73D64C4EA95AD133C81A648152E44ACF96E36DD1E80FABE46\":char*:\"99EF4AEB15F178CEA1FE40DB2603138F130E740A19624526203B6351D0A3A94FA329C145786E679E7B82C71A38628AC8\"",
    "depends_on:3:7",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:9:char*:\"sample\":char*:\"ED0959D5880AB2D869AE7F6C2915C6D60F96507F9CB3E047C0046861DA4A799CFE30F35CC900056D7C99CD7882433709\":char*:\"512C8CCEEE3890A84058CE1E22DBC2198F42323CE8ACA9135329F03C068E5112DC7CC3EF3446DEFCEB01A45C2667FDD5\"",
    "depends_on:3:5",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:5:char*:\"test\":char*:\"4BC35D3A50EF4E30576F58CD96CE6BF638025EE624004A1F7789A8B8E43D0678ACD9D29876DAF46638645F7F404B11C7\":char*:\"D5A6326C494ED3FF614703878961C0FDE7B2C278F9A65FD8C4B7186201A2991695BA1C84541327E966FA7B50F7382282\"",
    "depends_on:3:6",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:6:char*:\"test\":char*:\"E8C9D0B6EA72A0E7837FEA1D14A1A9557F29FAA45D3E7EE888FC5BF954B5E62464A9A817C47FF78B8C11066B24080E72\":char*:\"07041D4A7A0379AC7232FF72E6F77B6DDB8F09B16CCE0EC3286B2BD43FA8C6141C53EA5ABEF0D8231077A04540A96B66\"",
    "depends_on:3:6",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:7:char*:\"test\":char*:\"6D6DEFAC9AB64DABAFE36C6BF510352A4CC27001263638E5B16D9BB51D451559F918EEDAF2293BE5B475CC8F0188636B\":char*:\"2D46F3BECBCC523D5F1A1256BF0C9B024D879BA9E838144C8BA6BAEB4B53B47D51AB373F9845C0514EEFB14024787265\"",
    "depends_on:3:7",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:8:char*:\"test\":char*:\"8203B63D3C853E8D77227FB377BCF7B7B772E97892A80F36AB775D509D7A5FEB0542A7F0812998DA8F1DD3CA3CF023DB\":char*:\"DDD0760448D42D8A43AF45AF836FCE4DE8BE06B485E9B61B827C2F13173923E06A739F040649A667BF3B828246BAA5A5\"",
    "depends_on:3:7",
    "2:exp:3:char*:\"6B9D3DAD2E1B8C1C05B19875B6659F4DE23C3B667BF297BA9AA47740787137D896D5724E4C70A825F872C9EA60D2EDF5\":exp:9:char*:\"test\":char*:\"A0D5D090C9980FAF3C2CE57B7AE951D31977DD11C775D314AF55F76C676447D06FB6495CD21B4B6E340FC236584FB277\":char*:\"976984E59B4C77B0E8E4460DCA3D9F20E07B9BB1F63BEEFAF576F6B2E8B224634A2092CD3792E0159AD9CEE37659C736\"",
    "depends_on:4:5",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:5:char*:\"sample\":char*:\"0343B6EC45728975EA5CBA6659BBB6062A5FF89EEA58BE3C80B619F322C87910FE092F7D45BB0F8EEE01ED3F20BABEC079D202AE677B243AB40B5431D497C55D75D\":char*:\"0E7B0E675A9B24413D448B8CC119D2BF7B2D2DF032741C096634D6D65D0DBE3D5694625FB9E8104D3B842C1B0E2D0B98BEA19341E8676AEF66AE4EBA3D5475D5D16\"",
    "depends_on:4:6",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:6:char*:\"sample\":char*:\"1776331CFCDF927D666E032E00CF776187BC9FDD8E69D0DABB4109FFE1B5E2A30715F4CC923A4A5E94D2503E9ACFED92857B7F31D7152E0F8C00C15FF3D87E2ED2E\":char*:\"050CB5265417FE2320BBB5A122B8E1A32BD699089851128E360E620A30C7E17BA41A666AF126CE100E5799B153B60528D5300D08489CA9178FB610A2006C254B41F\"",
    "depends_on:4:6",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:7:char*:\"sample\":char*:\"1511BB4D675114FE266FC4372B87682BAECC01D3CC62CF2303C92B3526012659D16876E25C7C1E57648F23B73564D67F61C6F14D527D54972810421E7D87589E1A7\":char*:\"04A171143A83163D6DF460AAF61522695F207A58B95C0644D87E52AA1A347916E4F7A72930B1BC06DBE22CE3F58264AFD23704CBB63B29B931F7DE6C9D949A7ECFC\"",
    "depends_on:4:7",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:8:char*:\"sample\":char*:\"1EA842A0E17D2DE4F92C15315C63DDF72685C18195C2BB95E572B9C5136CA4B4B576AD712A52BE9730627D16054BA40CC0B8D3FF035B12AE75168397F5D50C67451\":char*:\"1F21A3CEE066E1961025FB048BD5FE2B7924D0CD797BABE0A83B66F1E35EEAF5FDE143FA85DC394A7DEE766523393784484BDF3E00114A1C857CDE1AA203DB65D61\"",
    "depends_on:4:7",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:9:char*:\"sample\":char*:\"0C328FAFCBD79DD77850370C46325D987CB525569FB63C5D3BC53950E6D4C5F174E25A1EE9017B5D450606ADD152B534931D7D4E8455CC91F9B15BF05EC36E377FA\":char*:\"0617CCE7CF5064806C467F678D3B4080D6F1CC50AF26CA209417308281B68AF282623EAA63E5B5C0723D8B8C37FF0777B1A20F8CCB1DCCC43997F1EE0E44DA4A67A\"",
    "depends_on:4:5",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:5:char*:\"test\":char*:\"13BAD9F29ABE20DE37EBEB823C252CA0F63361284015A3BF430A46AAA80B87B0693F0694BD88AFE4E661FC33B094CD3B7963BED5A727ED8BD6A3A202ABE009D0367\":char*:\"1E9BB81FF7944CA409AD138DBBEE228E1AFCC0C890FC78EC8604639CB0DBDC90F717A99EAD9D272855D00162EE9527567DD6A92CBD629805C0445282BBC916797FF\"",
    "depends_on:4:6",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:6:char*:\"test\":char*:\"1C7ED902E123E6815546065A2C4AF977B22AA8EADDB68B2C1110E7EA44D42086BFE4A34B67DDC0E17E96536E358219B23A706C6A6E16BA77B65E1C595D43CAE17FB\":char*:\"177336676304FCB343CE028B38E7B4FBA76C1C1B277DA18CAD2A8478B2A9A9F5BEC0F3BA04F35DB3E4263569EC6AADE8C92746E4C82F8299AE1B8F1739F8FD519A4\"",
    "depends_on:4:6",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:7:char*:\"test\":char*:\"00E871C4A14F993C6C7369501900C4BC1E9C7B0B4BA44E04868B30B41D8071042EB28C4C250411D0CE08CD197E4188EA4876F279F90B3D8D74A3C76E6F1E4656AA8\":char*:\"0CD52DBAA33B063C3A6CD8058A1FB0A46A4754B034FCC644766CA14DA8CA5CA9FDE00E88C1AD60CCBA759025299079D7A427EC3CC5B619BFBC828E7769BCD694E86\"",
    "depends_on:4:7",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:8:char*:\"test\":char*:\"14BEE21A18B6D8B3C93FAB08D43E739707953244FDBE924FA926D76669E7AC8C89DF62ED8975C2D8397A65A49DCC09F6B0AC62272741924D479354D74FF6075578C\":char*:\"133330865C067A0EAF72362A65E2D7BC4E461E8C8995C3B6226A21BD1AA78F0ED94FE536A0DCA35534F0CD1510C41525D163FE9D74D134881E35141ED5E8E95B979\"",
    "depends_on:4:7",
    "2:exp:4:char*:\"0FAD06DAA62BA3B25D2FB40133DA757205DE67F5BB0018FEE8C86E1B68C7E75CAA896EB32F1F47C70855836A6D16FCC1466F6D8FBEC67DB89EC0C08B0E996B83538\":exp:9:char*:\"test\":char*:\"13E99020ABF5CEE7525D16B69B229652AB6BDF2AFFCAEF38773B4B7D08725F10CDB93482FDCC54EDCEE91ECA4166B2A7C6265EF0CE2BD7051B7CEF945BABD47EE6D\":char*:\"1FBD0013C674AA79CB39849527916CE301C66EA7CE8B80682786AD60F98F7E78A19CA69EFF5C57400E3B3A0AD66CE0978214D13BAF4E9AC60752F7B155E2DE4DCE3\"",
    "depends_on:0",
    "1:exp:0:char*:\"0\":char*:\"2442A5CC0ECD015FA3CA31DC8E2BBC70BF42D60CBCA20085\":char*:\"6FC98BD7E50211A4A27102FA3549DF79EBCB4BF246B80945\":hex:\"9E56F509196784D963D1C0A401510EE7ADA3DCC5DEE04B15\":hex:\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9C\":char*:\"98C6BD12B23EAF5E2A2045132086BE3EB8EBD62ABF6698FF\":char*:\"57A22B07DEA9530F8DE9471B1DC6624472E8E2844BC25B64\":exp:10",
    "depends_on:0",
    "1:exp:0:char*:\"6FAB034934E4C0FC9AE67F5B5659A9D7D1FEFD187EE09FD41\":char*:\"2442A5CC0ECD015FA3CA31DC8E2BBC70BF42D60CBCA20085\":char*:\"6FC98BD7E50211A4A27102FA3549DF79EBCB4BF246B80945\":hex:\"9E56F509196784D963D1C0A401510EE7ADA3DCC5DEE04B15\":hex:\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61\":char*:\"98C6BD12B23EAF5E2A2045132086BE3EB8EBD62ABF6698FF\":char*:\"57A22B07DEA9530F8DE9471B1DC6624472E8E2844BC25B64\":exp:10",
    "depends_on:1",
    "1:exp:1:char*:\"0\":char*:\"2442A5CC0ECD015FA3CA31DC8E2BBC70BF42D60CBCA20085E0822CB04235E970\":char*:\"6FC98BD7E50211A4A27102FA3549DF79EBCB4BF246B80945CDDFE7D5\":hex:\"9E56F509196784D963D1C0A401510EE7ADA3DCC5DEE04B154BF61AF1\":hex:\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61\":char*:\"22226F9D40A96E19C4A301CE5B74B115303C0F3A4FD30FC257FB57AC\":char*:\"66D1CDD83E3AF75605DD6E2FEFF196D30AA7ED7A2EDF7AF475403D69\":exp:10",
    "depends_on:1",
    "1:exp:1:char*:\"F220266E1105BFE3083E03EC7A3A654651F45E37167E88600BF257C11\":char*:\"2442A5CC0ECD015FA3CA31DC8E2BBC70BF42D60CBCA20085E0822CB04235E970\":char*:\"6FC98BD7E50211A4A27102FA3549DF79EBCB4BF246B80945CDDFE7D5\":hex:\"9E56F509196784D963D1C0A401510EE7ADA3DCC5DEE04B154BF61AF1\":hex:\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\":char*:\"22226F9D40A96E19C4A301CE5B74B115303C0F3A4FD30FC257FB57AC\":char*:\"66D1CDD83E3AF75605DD6E2FEFF196D30AA7ED7A2EDF7AF475403D69\":exp:10",
    "depends_on:2",
    "1:exp:2:char*:\"0\":char*:\"2442A5CC0ECD015FA3CA31DC8E2BBC70BF42D60CBCA20085E0822CB04235E970\":char*:\"6FC98BD7E50211A4A27102FA3549DF79EBCB4BF246B80945CDDFE7D509BBFD7D\":hex:\"9E56F509196784D963D1C0A401510EE7ADA3DCC5DEE04B154BF61AF1D5A6DECE\":hex:\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\":char*:\"CB28E0999B9C7715FD0A80D8E47A77079716CBBF917DD72E97566EA1C066957C\":char*:\"86FA3BB4E26CAD5BF90B7F81899256CE7594BB1EA0C89212748BFF3B3D5B0315\":exp:10",
    "depends_on:2",
    "1:exp:2:char*:\"DC51D3866A15BACDE33D96F992FCA99DA7E6EF0934E7097559C27F1614C88A7F1\":char*:\"2442A5CC0ECD015FA3CA31DC8E2BBC70BF42D60CBCA20085E0822CB04235E970\":char*:\"6FC98BD7E50211A4A27102FA3549DF79EBCB4BF246B80945CDDFE7D509BBFD7D\":hex:\"9E56F509196784D963D1C0A401510EE7ADA3DCC5DEE04B154BF61AF1D5A6DECE\":hex:\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\":char*:\"CB28E0999B9C7715FD0A80D8E47A77079716CBBF917DD72E97566EA1C066957C\":char*:\"86FA3BB4E26CAD5BF90B7F81899256CE7594BB1EA0C89212748BFF3B3D5B0315\":exp:10",
    "depends_on:3",
    "1:exp:3:char*:\"0\":char*:\"96281BF8DD5E0525CA049C048D345D3082968D10FEDF5C5ACA0C64E6465A97EA5CE10C9DFEC21797415710721F437922\":char*:\"447688BA94708EB6E2E4D59F6AB6D7EDFF9301D249FE49C33096655F5D502FAD3D383B91C5E7EDAA2B714CC99D5743CA\":hex:\"B4B74E44D71A13D568003D7489908D564C7761E229C58CBFA18950096EB7463B854D7FA992F934D927376285E63414FA\":hex:\"CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED1631A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7\":char*:\"FB017B914E29149432D8BAC29A514640B46F53DDAB2C69948084E2930F1C8F7E08E07C9C63F2D21A07DCB56A6AF56EB3\":char*:\"B263A1305E057F984D38726A1B46874109F417BCA112674C528262A40A629AF1CBB9F516CE0FA7D2FF630863A00E8B9F\":exp:10",
    "depends_on:3",
    "1:exp:3:char*:\"10BEB646634BA87735D77AE4809A0EBEA865535DE4C1E1DCB692E84708E81A5AF62E528C38B2A81B35309668D73524D9F\":char*:\"96281BF8DD5E0525CA049C048D345D3082968D10FEDF5C5ACA0C64E6465A97EA5CE10C9DFEC21797415710721F437922\":char*:\"447688BA94708EB6E2E4D59F6AB6D7EDFF9301D249FE49C33096655F5D502FAD3D383B91C5E7EDAA2B714CC99D5743CA\":hex:\"B4B74E44D71A13D568003D7489908D564C7761E229C58CBFA18950096EB7463B854D7FA992F934D927376285E63414FA\":hex:\"CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED1631A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7\":char*:\"FB017B914E29149432D8BAC29A514640B46F53DDAB2C69948084E2930F1C8F7E08E07C9C63F2D21A07DCB56A6AF56EB3\":char*:\"B263A1305E057F984D38726A1B46874109F417BCA112674C528262A40A629AF1CBB9F516CE0FA7D2FF630863A00E8B9F\":exp:10",
    "depends_on:4",
    "1:exp:4:char*:\"0\":char*:\"0151518F1AF0F563517EDD5485190DF95A4BF57B5CBA4CF2A9A3F6474725A35F7AFE0A6DDEB8BEDBCD6A197E592D40188901CECD650699C9B5E456AEA5ADD19052A8\":char*:\"006F3B142EA1BFFF7E2837AD44C9E4FF6D2D34C73184BBAD90026DD5E6E85317D9DF45CAD7803C6C20035B2F3FF63AFF4E1BA64D1C077577DA3F4286C58F0AEAE643\":hex:\"00C1C2B305419F5A41344D7E4359933D734096F556197A9B244342B8B62F46F9373778F9DE6B6497B1EF825FF24F42F9B4A4BD7382CFC3378A540B1B7F0C1B956C2F\":hex:\"DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA20A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD454D4423643CE80E2A9AC94FA54CA49F\":char*:\"0154FD3836AF92D0DCA57DD5341D3053988534FDE8318FC6AAAAB68E2E6F4339B19F2F281A7E0B22C269D93CF8794A9278880ED7DBB8D9362CAEACEE544320552251\":char*:\"017705A7030290D1CEB605A9A1BB03FF9CDD521E87A696EC926C8C10C8362DF4975367101F67D1CF9BCCBF2F3D239534FA509E70AAC851AE01AAC68D62F866472660\":exp:10",
    "depends_on:4",
    "1:exp:4:char*:\"0065FDA3409451DCAB0A0EAD45495112A3D813C17BFD34BDF8C1209D7DF5849120597779060A7FF9D704ADF78B570FFAD6F062E95C7E0C5D5481C5B153B48B375FA11\":char*:\"0151518F1AF0F563517EDD5485190DF95A4BF57B5CBA4CF2A9A3F6474725A35F7AFE0A6DDEB8BEDBCD6A197E592D40188901CECD650699C9B5E456AEA5ADD19052A8\":char*:\"006F3B142EA1BFFF7E2837AD44C9E4FF6D2D34C73184BBAD90026DD5E6E85317D9DF45CAD7803C6C20035B2F3FF63AFF4E1BA64D1C077577DA3F4286C58F0AEAE643\":hex:\"00C1C2B305419F5A41344D7E4359933D734096F556197A9B244342B8B62F46F9373778F9DE6B6497B1EF825FF24F42F9B4A4BD7382CFC3378A540B1B7F0C1B956C2F\":hex:\"DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA20A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD454D4423643CE80E2A9AC94FA54CA49F\":char*:\"0154FD3836AF92D0DCA57DD5341D3053988534FDE8318FC6AAAAB68E2E6F4339B19F2F281A7E0B22C269D93CF8794A9278880ED7DBB8D9362CAEACEE544320552251\":char*:\"017705A7030290D1CEB605A9A1BB03FF9CDD521E87A696EC926C8C10C8362DF4975367101F67D1CF9BCCBF2F3D239534FA509E70AAC851AE01AAC68D62F866472660\":exp:10",
};

/* ========================================================================== */
/*                                LOCAL TYPEDEFS                              */
/* ========================================================================== */
static struct
{
    int failed;
    const char *test;
    const char *filename;
    int line_no;
}
test_info;

/* ========================================================================== */
/*                                    MACROS                                  */
/* ========================================================================== */

#define TEST_ASSERT_MBEDTLS( TEST )                 \
    do {                                            \
        if( ! (TEST) )                              \
        {                                           \
            test_fail( #TEST, __LINE__, __FILE__ ); \
            goto exit;                              \
        }                                           \
    } while( 0 )

/* ========================================================================== */
/*                            FUNCTION DECLARATIONS                           */
/* ========================================================================== */

static void test_ecdsa_write_read_random_wrapper( void ** params );
static void test_ecdsa_prim_random_wrapper( void ** params );
static void test_ecdsa_prim_test_vectors_wrapper( void ** params );
static void test_ecdsa_det_test_vectors_wrapper( void ** params );
static void test_ecdsa_write_read_random_wrapper( void ** params );
static void test_ecdsa_prim_random( int id );
static int rnd_pseudo_rand( void *rng_state, unsigned char *output, size_t len );
static int rnd_std_rand( void *rng_state, unsigned char *output, size_t len );
static int rnd_buffer_rand( void *rng_state, unsigned char *output, size_t len );
/* TEST-FUNCTIONS */
static int convert_params( size_t cnt , char ** params , int * int_params_store );
static int dep_check( int dep_id );
static int get_expression( int32_t exp_id, int32_t * out_value );
static int check_test_ecdsa( int func_idx );
static int dispatch_test_ecdsa( int func_idx, void ** params );

/**
 * \brief       Table of test function wrappers. Used by dispatch_test().
 *              This table is populated by script:
 *              generate_test_code.py
 *
 */
TestWrapper_t test_funcs_ecdsa[] =
{
    /* Function Id: 0 */

    #if defined(MBEDTLS_ECDSA_C)
        test_ecdsa_prim_random_wrapper,
    #else
        NULL,
    #endif
    /* Function Id: 1 */

    #if defined(MBEDTLS_ECDSA_C)
        test_ecdsa_prim_test_vectors_wrapper,
    #else
        NULL,
    #endif
    /* Function Id: 2 */

    #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_ECDSA_DETERMINISTIC)
        test_ecdsa_det_test_vectors_wrapper,
    #else
        NULL,
    #endif
    /* Function Id: 3 */

    #if defined(MBEDTLS_ECDSA_C) && defined(MBEDTLS_SHA256_C)
        test_ecdsa_write_read_random_wrapper,
    #else
        NULL,
    #endif
};

/* ========================================================================== */
/*                            FUNCTION DEFINITIONS                            */
/* ========================================================================== */

static void test_fail( const char *test, int line_no, const char* filename )
{
    test_info.failed = 1;
    test_info.test = test;
    test_info.line_no = line_no;
    test_info.filename = filename;
}

/**
 * This function just returns data from rand().
 * Although predictable and often similar on multiple
 * runs, this does not result in identical random on
 * each run. So do not use this if the results of a
 * test depend on the random data that is generated.
 *
 * rng_state shall be NULL.
 */
static int rnd_std_rand( void *rng_state, unsigned char *output, size_t len )
{
    #if !defined(__OpenBSD__)
    size_t i;

    if( rng_state != NULL )
        rng_state  = NULL;

    for( i = 0; i < len; ++i )
        output[i] = rand();
    #else
    if( rng_state != NULL )
        rng_state = NULL;

    arc4random_buf( output, len );
    #endif /* !OpenBSD */

    return 0;
}

/**
 * This function returns random based on a pseudo random function.
 * This means the results should be identical on all systems.
 * Pseudo random is based on the XTEA encryption algorithm to
 * generate pseudorandom.
 *
 * rng_state shall be a pointer to a rnd_pseudo_info structure.
 */
static int rnd_pseudo_rand( void *rng_state, unsigned char *output, size_t len )
{
    rnd_pseudo_info *info = (rnd_pseudo_info *) rng_state;
    uint32_t i, *k, sum, delta=0x9E3779B9;
    unsigned char result[4], *out = output;

    if( rng_state == NULL )
        return rnd_std_rand( NULL, output, len );

    k = info->key;

    while( len > 0 )
    {
        size_t use_len = ( len > 4 ) ? 4 : len;
        sum = 0;

        for( i = 0; i < 32; i++ )
        {
            info->v0 += ( ( ( info->v1 << 4 ) ^ ( info->v1 >> 5 ) )
                            + info->v1 ) ^ ( sum + k[sum & 3] );
            sum += delta;
            info->v1 += ( ( ( info->v0 << 4 ) ^ ( info->v0 >> 5 ) )
                            + info->v0 ) ^ ( sum + k[( sum>>11 ) & 3] );
        }

        PUT_UINT32_BE( info->v0, result, 0 );
        memcpy( out, result, use_len );
        len -= use_len;
        out += 4;
    }

    return  0;
}

/**
 * \brief       Checks if test function is supported
 *
 * \param exp_id    Test function index.
 *
 * \return       DISPATCH_TEST_SUCCESS if found
 *               DISPATCH_TEST_FN_NOT_FOUND if not found
 *               DISPATCH_UNSUPPORTED_SUITE if not compile time enabled.
 */
static int check_test_ecdsa( int func_idx )
{
    int ret = DISPATCH_TEST_SUCCESS;
    TestWrapper_t fp = NULL;

    if ( func_idx < (int)( sizeof(test_funcs_ecdsa)/sizeof( TestWrapper_t ) ) )
    {
        fp = test_funcs_ecdsa[func_idx];
        if ( fp == NULL )
            ret = DISPATCH_UNSUPPORTED_SUITE;
    }
    else
    {
        ret = DISPATCH_TEST_FN_NOT_FOUND;
    }

    return ret;
}

/**
 * \brief       Dispatches test functions based on function index.
 *
 * \param exp_id    Test function index.
 *
 * \return       DISPATCH_TEST_SUCCESS if found
 *               DISPATCH_TEST_FN_NOT_FOUND if not found
 *               DISPATCH_UNSUPPORTED_SUITE if not compile time enabled.
 */
static int dispatch_test_ecdsa( int func_idx, void ** params )
{
    int ret = DISPATCH_TEST_SUCCESS;
    TestWrapper_t fp = NULL;

    if ( func_idx < (int)( sizeof( test_funcs_ecdsa ) / sizeof( TestWrapper_t ) ) )
    {
        fp = test_funcs_ecdsa[func_idx];
        if ( fp )
            fp( params );
        else
            ret = DISPATCH_UNSUPPORTED_SUITE;
    }
    else
    {
        ret = DISPATCH_TEST_FN_NOT_FOUND;
    }

    return ret;
}

/**
 * This function returns random based on a buffer it receives.
 *
 * rng_state shall be a pointer to a rnd_buf_info structure.
 *
 * The number of bytes released from the buffer on each call to
 * the random function is specified by per_call. (Can be between
 * 1 and 4)
 *
 * After the buffer is empty it will return rand();
 */
static int rnd_buffer_rand( void *rng_state, unsigned char *output, size_t len )
{
    rnd_buf_info *info = (rnd_buf_info *) rng_state;
    size_t use_len;

    if( rng_state == NULL )
        return rnd_std_rand( NULL, output, len );

    use_len = len;
    if( len > info->length )
        use_len = info->length;

    if( use_len )
    {
        memcpy( output, info->buf, use_len );
        info->buf += use_len;
        info->length -= use_len;
    }

    if( len - use_len > 0 )
        return rnd_std_rand( NULL, output + use_len, len - use_len );

    return 0;
}

static void test_ecdsa_prim_random( int id )
{
    mbedtls_ecp_group grp;
    mbedtls_ecp_point Q;
    mbedtls_mpi d, r, s;
    rnd_pseudo_info rnd_info;
    unsigned char buf[66] __attribute__ ((aligned (32U)));

    mbedtls_ecp_group_init( &grp );
    mbedtls_ecp_point_init( &Q );
    mbedtls_mpi_init( &d ); mbedtls_mpi_init( &r ); mbedtls_mpi_init( &s );
    memset( &rnd_info, 0x00, sizeof( rnd_pseudo_info ) );
    memset( buf, 0, sizeof( buf ) );

    /* prepare material for signature */
    TEST_ASSERT_MBEDTLS( rnd_pseudo_rand( &rnd_info, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_ecp_group_load( &grp, id ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_ecp_gen_keypair( &grp, &d, &Q, &rnd_pseudo_rand, &rnd_info )
                 == 0 );

    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_sign( &grp, &r, &s, &d, buf, sizeof( buf ),
                             &rnd_pseudo_rand, &rnd_info ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_verify( &grp, buf, sizeof( buf ), &Q, &r, &s ) == 0 );

exit:
    mbedtls_ecp_group_free( &grp );
    mbedtls_ecp_point_free( &Q );
    mbedtls_mpi_free( &d ); mbedtls_mpi_free( &r ); mbedtls_mpi_free( &s );
}

static void test_ecdsa_prim_random_wrapper( void ** params )
{
    test_ecdsa_prim_random( *( (int *) params[0] ) );
}

static void test_ecdsa_prim_test_vectors( int id, char * d_str, char * xQ_str,
                              char * yQ_str, data_t * rnd_buf,
                              data_t * hash, char * r_str, char * s_str,
                              int result )
{
    mbedtls_ecp_group grp;
    mbedtls_ecp_point Q;
    mbedtls_mpi d, r, s, r_check, s_check;
    rnd_buf_info rnd_info;

    mbedtls_ecp_group_init( &grp );
    mbedtls_ecp_point_init( &Q );
    mbedtls_mpi_init( &d ); mbedtls_mpi_init( &r ); mbedtls_mpi_init( &s );
    mbedtls_mpi_init( &r_check ); mbedtls_mpi_init( &s_check );

    TEST_ASSERT_MBEDTLS( mbedtls_ecp_group_load( &grp, id ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_ecp_point_read_string( &Q, 16, xQ_str, yQ_str ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_mpi_read_string( &d, 16, d_str ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_mpi_read_string( &r_check, 16, r_str ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_mpi_read_string( &s_check, 16, s_str ) == 0 );
    rnd_info.buf = rnd_buf->x;
    rnd_info.length = rnd_buf->len;

    /* Fix rnd_buf->x by shifting it left if necessary */
    if( grp.nbits % 8 != 0 )
    {
        unsigned char shift = 8 - ( grp.nbits % 8 );
        size_t i;

        for( i = 0; i < rnd_info.length - 1; i++ )
            rnd_buf->x[i] = rnd_buf->x[i] << shift | rnd_buf->x[i+1] >> ( 8 - shift );

        rnd_buf->x[rnd_info.length-1] <<= shift;
    }

    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_sign( &grp, &r, &s, &d, hash->x, hash->len,
                 rnd_buffer_rand, &rnd_info ) == result );

    if ( result == 0)
    {
        TEST_ASSERT_MBEDTLS( mbedtls_mpi_cmp_mpi( &r, &r_check ) == 0 );
        TEST_ASSERT_MBEDTLS( mbedtls_mpi_cmp_mpi( &s, &s_check ) == 0 );
        TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_verify( &grp, hash->x, hash->len, &Q, &r_check, &s_check ) == 0 );
    }

exit:
    mbedtls_ecp_group_free( &grp );
    mbedtls_ecp_point_free( &Q );
    mbedtls_mpi_free( &d ); mbedtls_mpi_free( &r ); mbedtls_mpi_free( &s );
    mbedtls_mpi_free( &r_check ); mbedtls_mpi_free( &s_check );
}

static void test_ecdsa_prim_test_vectors_wrapper( void ** params )
{
    data_t data4 = {(uint8_t *) params[4], *( (uint32_t *) params[5] )};
    data_t data6 = {(uint8_t *) params[6], *( (uint32_t *) params[7] )};

    test_ecdsa_prim_test_vectors( *( (int *) params[0] ), (char *) params[1], (char *) params[2], (char *) params[3], &data4, &data6, (char *) params[8], (char *) params[9], *( (int *) params[10] ) );
}

#if defined(MBEDTLS_ECDSA_DETERMINISTIC)
static void test_ecdsa_det_test_vectors( int id, char * d_str, int md_alg, char * msg,
                             char * r_str, char * s_str )
{
    mbedtls_ecp_group grp;
    mbedtls_mpi d, r, s, r_check, s_check;
    unsigned char hash[MBEDTLS_MD_MAX_SIZE] __attribute__ ((aligned (32U)));;
    size_t hlen;
    const mbedtls_md_info_t *md_info;

    mbedtls_ecp_group_init( &grp );
    mbedtls_mpi_init( &d ); mbedtls_mpi_init( &r ); mbedtls_mpi_init( &s );
    mbedtls_mpi_init( &r_check ); mbedtls_mpi_init( &s_check );
    memset( hash, 0, sizeof( hash ) );

    TEST_ASSERT_MBEDTLS( mbedtls_ecp_group_load( &grp, id ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_mpi_read_string( &d, 16, d_str ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_mpi_read_string( &r_check, 16, r_str ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_mpi_read_string( &s_check, 16, s_str ) == 0 );

    md_info = mbedtls_md_info_from_type( md_alg );
    TEST_ASSERT_MBEDTLS( md_info != NULL );
    hlen = mbedtls_md_get_size( md_info );
    mbedtls_md( md_info, (const unsigned char *) msg, strlen( msg ), hash );

    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_sign_det( &grp, &r, &s, &d, hash, hlen, md_alg ) == 0 );

    TEST_ASSERT_MBEDTLS( mbedtls_mpi_cmp_mpi( &r, &r_check ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_mpi_cmp_mpi( &s, &s_check ) == 0 );

exit:
    mbedtls_ecp_group_free( &grp );
    mbedtls_mpi_free( &d ); mbedtls_mpi_free( &r ); mbedtls_mpi_free( &s );
    mbedtls_mpi_free( &r_check ); mbedtls_mpi_free( &s_check );
}

static void test_ecdsa_det_test_vectors_wrapper( void ** params )
{
    test_ecdsa_det_test_vectors( *( (int *) params[0] ), (char *) params[1], *( (int *) params[2] ), (char *) params[3], (char *) params[4], (char *) params[5] );
}
#endif /* MBEDTLS_ECDSA_DETERMINISTIC */

static void test_ecdsa_write_read_random( int id )
{
    mbedtls_ecdsa_context ctx;
    rnd_pseudo_info rnd_info;
    unsigned char hash[32] __attribute__ ((aligned (32U)));
    unsigned char sig[200] __attribute__ ((aligned (32U)));
    size_t sig_len, i;

    mbedtls_ecdsa_init( &ctx );
    memset( &rnd_info, 0x00, sizeof( rnd_pseudo_info ) );
    memset( hash, 0, sizeof( hash ) );
    memset( sig, 0x2a, sizeof( sig ) );

    /* prepare material for signature */
    TEST_ASSERT_MBEDTLS( rnd_pseudo_rand( &rnd_info, hash, sizeof( hash ) ) == 0 );

    /* generate signing key */
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_genkey( &ctx, id, &rnd_pseudo_rand, &rnd_info ) == 0 );

    /* generate and write signature, then read and verify it */
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_write_signature( &ctx, MBEDTLS_MD_SHA256,
                 hash, sizeof( hash ),
                 sig, &sig_len, &rnd_pseudo_rand, &rnd_info ) == 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_read_signature( &ctx, hash, sizeof( hash ),
                 sig, sig_len ) == 0 );

    /* check we didn't write past the announced length */
    for( i = sig_len; i < sizeof( sig ); i++ )
        TEST_ASSERT_MBEDTLS( sig[i] == 0x2a );

    /* try verification with invalid length */
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_read_signature( &ctx, hash, sizeof( hash ),
                 sig, sig_len - 1 ) != 0 );
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_read_signature( &ctx, hash, sizeof( hash ),
                 sig, sig_len + 1 ) != 0 );

    /* try invalid sequence tag */
    sig[0]++;
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_read_signature( &ctx, hash, sizeof( hash ),
                 sig, sig_len ) != 0 );
    sig[0]--;

    /* try modifying r */
    sig[10]++;
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_read_signature( &ctx, hash, sizeof( hash ),
                 sig, sig_len ) != 0 );
    sig[10]--;

    /* try modifying s */
    sig[sig_len - 1]++;
    TEST_ASSERT_MBEDTLS( mbedtls_ecdsa_read_signature( &ctx, hash, sizeof( hash ),
                 sig, sig_len ) != 0 );
    sig[sig_len - 1]--;

exit:
    mbedtls_ecdsa_free( &ctx );
}

static void test_ecdsa_write_read_random_wrapper( void ** params )
{
    test_ecdsa_write_read_random( *( (int *) params[0] ) );
}

/**
 * \brief       Checks if the dependency i.e. the compile flag is set.
 *              For optimizing space for embedded targets each dependency
 *              is identified by a unique identifier instead of string literals.
 *              Identifiers and check code is generated by script:
 *              generate_test_code.py
 *
 * \param exp_id    Dependency identifier.
 *
 * \return       DEPENDENCY_SUPPORTED if set else DEPENDENCY_NOT_SUPPORTED
 */
static int dep_check( int dep_id )
{
    int ret = DEPENDENCY_NOT_SUPPORTED;

    (void) dep_id;

    switch( dep_id )
    {

        #if defined(MBEDTLS_ECDSA_C)
        case 0:
        {
            #if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
                ret = DEPENDENCY_SUPPORTED;
            #else
                ret = DEPENDENCY_NOT_SUPPORTED;
            #endif
        }
        break;
        case 1:
        {
            #if defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED)
                ret = DEPENDENCY_SUPPORTED;
            #else
                ret = DEPENDENCY_NOT_SUPPORTED;
            #endif
        }
        break;
        case 2:
        {
            #if defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED)
                ret = DEPENDENCY_SUPPORTED;
            #else
                ret = DEPENDENCY_NOT_SUPPORTED;
            #endif
        }
        break;
        case 3:
        {
            #if defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED)
                ret = DEPENDENCY_SUPPORTED;
            #else
                ret = DEPENDENCY_NOT_SUPPORTED;
            #endif
        }
        break;
        case 4:
        {
            #if defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED)
                ret = DEPENDENCY_SUPPORTED;
            #else
                ret = DEPENDENCY_NOT_SUPPORTED;
            #endif
        }
        break;
        case 5:
        {
            #if defined(MBEDTLS_SHA1_C)
                ret = DEPENDENCY_SUPPORTED;
            #else
                ret = DEPENDENCY_NOT_SUPPORTED;
            #endif
        }
        break;
        case 6:
        {
            #if defined(MBEDTLS_SHA256_C)
                ret = DEPENDENCY_SUPPORTED;
            #else
                ret = DEPENDENCY_NOT_SUPPORTED;
            #endif
        }
        break;
        case 7:
        {
            #if defined(MBEDTLS_SHA512_C)
                ret = DEPENDENCY_SUPPORTED;
            #else
                ret = DEPENDENCY_NOT_SUPPORTED;
            #endif
        }
        break;
        #endif
        default:
            break;
    }
    return ret;
}

/**
 * \brief       Evaluates an expression/macro into its literal integer value.
 *              For optimizing space for embedded targets each expression/macro
 *              is identified by a unique identifier instead of string literals.
 *              Identifiers and evaluation code is generated by script:
 *              generate_test_code.py
 *
 * \param exp_id    Expression identifier.
 * \param out_value Pointer to int to hold the integer.
 *
 * \return       0 if exp_id is found. 1 otherwise.
 */
static int get_expression( int32_t exp_id, int32_t * out_value )
{
    int ret = KEY_VALUE_MAPPING_FOUND;

    (void) exp_id;
    (void) out_value;

    switch( exp_id )
    {
        #if defined(MBEDTLS_ECDSA_C)
        case 0:
        {
            *out_value = MBEDTLS_ECP_DP_SECP192R1;
        }
        break;
        case 1:
        {
            *out_value = MBEDTLS_ECP_DP_SECP224R1;
        }
        break;
        case 2:
        {
            *out_value = MBEDTLS_ECP_DP_SECP256R1;
        }
        break;
        case 3:
        {
            *out_value = MBEDTLS_ECP_DP_SECP384R1;
        }
        break;
        case 4:
        {
            *out_value = MBEDTLS_ECP_DP_SECP521R1;
        }
        break;
        case 5:
        {
            *out_value = MBEDTLS_MD_SHA1;
        }
        break;
        case 6:
        {
            *out_value = MBEDTLS_MD_SHA224;
        }
        break;
        case 7:
        {
            *out_value = MBEDTLS_MD_SHA256;
        }
        break;
        case 8:
        {
            *out_value = MBEDTLS_MD_SHA384;
        }
        break;
        case 9:
        {
            *out_value = MBEDTLS_MD_SHA512;
        }
        break;
        case 10:
            {
                *out_value = MBEDTLS_ERR_ECP_INVALID_KEY;
            }
            break;
        #endif
        default:
           {
                ret = KEY_VALUE_MAPPING_NOT_FOUND;
           }
        break;
    }
    return ret;
}

/**
 * \brief       Converts parameters into test function consumable parameters.
 *              Example: Input:  {"int", "0", "char*", "Hello",
 *                                "hex", "abef", "exp", "1"}
 *                      Output:  {
 *                                0,                // Verified int
 *                                "Hello",          // Verified string
 *                                2, { 0xab, 0xef },// Converted len,hex pair
 *                                9600              // Evaluated expression
 *                               }
 *
 *
 * \param cnt               Parameter array count.
 * \param params            Out array of found parameters.
 * \param int_params_store  Memory for storing processed integer parameters.
 *
 * \return      0 for success else 1
 */

static int convert_params( size_t cnt , char ** params , int * int_params_store )
{
    char ** cur = params;
    char ** out = params;
    int ret = DISPATCH_TEST_SUCCESS;

    while ( cur < params + cnt )
    {
        char * type = *cur++;
        char * val = *cur++;

        if ( strcmp( type, "char*" ) == 0 )
        {
            if ( verify_string( &val ) == 0 )
            {
              *out++ = val;
            }
            else
            {
                ret = ( DISPATCH_INVALID_TEST_DATA );
                break;
            }
        }
        else if ( strcmp( type, "int" ) == 0 )
        {
            if ( verify_int( val, int_params_store ) == 0 )
            {
              *out++ = (char *) int_params_store++;
            }
            else
            {
                ret = ( DISPATCH_INVALID_TEST_DATA );
                break;
            }
        }
        else if ( strcmp( type, "hex" ) == 0 )
        {
            if ( verify_string( &val ) == 0 )
            {
                *int_params_store = unhexify( (unsigned char *) val, val );
                *out++ = val;
                *out++ = (char *)(int_params_store++);
            }
            else
            {
                ret = ( DISPATCH_INVALID_TEST_DATA );
                break;
            }
        }
        else if ( strcmp( type, "exp" ) == 0 )
        {
            int exp_id = strtol( val, NULL, 10 );
            if ( get_expression ( exp_id, int_params_store ) == 0 )
            {
              *out++ = (char *)int_params_store++;
            }
            else
            {
              ret = ( DISPATCH_INVALID_TEST_DATA );
              break;
            }
        }
        else
        {
          ret = ( DISPATCH_INVALID_TEST_DATA );
          break;
        }
    }
    return ret;
}

int* mbedtls_test_ecdsa()
{
    TEST_MESSAGE("----------------------------TEST FOR ECDSA----------------------------");
    uint8_t i=0 ,j=0;
    int ret = 0;
    uint8_t function_id = 0;
    char *params[50];
    int int_params[50];
    char* buffer;
    char unity_buffer[100];
    /* Other Local variables */
    int cnt;
    int total_errors = 0, total_tests = 0, total_skipped = 0;
    while ( i < sizeof(data_ecdsa)/sizeof(data_ecdsa[0]) )
    {
        total_tests++;
        buffer = (char*)malloc(sizeof(char)*strlen(data_ecdsa[i]));
        strcpy(buffer, data_ecdsa[i]);
        int unmet_dep_count = 0;
        char *unmet_dependencies[20];
        ret = 0;
        test_info.failed = 0;

        cnt = parse_arguments( buffer, strlen( buffer ), params,
                                    sizeof( params ) / sizeof( params[0] ) );

        if( strcmp( params[0], "depends_on" ) == 0 )
        {
            for( j = 1; j < cnt; j++ )
            {
                int dep_id = strtol( params[j], NULL, 10 );
                if( dep_check( dep_id ) != DEPENDENCY_SUPPORTED )
                {
                    unmet_dependencies[ unmet_dep_count ] = strdup( params[j] );
                    if(  unmet_dependencies[ unmet_dep_count ] == NULL )
                    {
                        TEST_MESSAGE("FATAL: Out of memory" );
                        mbedtls_exit( MBEDTLS_EXIT_FAILURE );
                    }
                    unmet_dep_count++;
                }
            }
            i++;
            free(buffer);
            buffer = (char*)malloc(sizeof(char)*strlen(data_ecdsa[i]));
            strcpy(buffer, data_ecdsa[i]);
            cnt = parse_arguments( buffer, strlen( buffer ), params,
                                    sizeof( params ) / sizeof( params[0] ) );
        }

        // If there are no unmet dependencies execute the test
        if( unmet_dep_count == 0 )
        {
            test_info.failed = 0;
            function_id = strtol( params[0], NULL, 10 );
            if ( (ret = check_test_ecdsa( function_id )) == DISPATCH_TEST_SUCCESS )
            {
                ret = convert_params( cnt - 1, params + 1, int_params );
                if ( DISPATCH_TEST_SUCCESS == ret )
                {
                    ret = dispatch_test_ecdsa( function_id, (void **)( params + 1 ) );
                }
            }
        }
        if( unmet_dep_count > 0 || ret == DISPATCH_UNSUPPORTED_SUITE )
        {
            total_skipped++;
            sprintf(unity_buffer, "ECDSA-Test %d : Skipped", total_tests);
            TEST_MESSAGE(unity_buffer);

            if(ret == DISPATCH_UNSUPPORTED_SUITE )
            {
                TEST_MESSAGE("Test Suite not enabled" );
            }

            if(unmet_dep_count > 0 )
            {
                TEST_MESSAGE("Unmet dependencies: " );
            }
            unmet_dep_count = 0;
        }
        else if( ret == DISPATCH_TEST_SUCCESS )
        {
            if( test_info.failed == 0 )
            {
                sprintf(unity_buffer, "ECDSA-Test %d : PASSED", total_tests);
                TEST_MESSAGE(unity_buffer);
            }
            else
            {
                total_errors++;
                sprintf(unity_buffer, "Test %d : FAILED", total_tests);
                TEST_MESSAGE(unity_buffer);
                sprintf(unity_buffer, "  %s  at line %d, %s",
                                    test_info.test, test_info.line_no,
                                    test_info.filename );
                TEST_MESSAGE(unity_buffer);
            }
        }
        else if( ret == DISPATCH_INVALID_TEST_DATA )
        {
            TEST_MESSAGE("FAILED: FATAL PARSE ERROR" );
        }
        else if( ret == DISPATCH_TEST_FN_NOT_FOUND )
        {
            TEST_MESSAGE("FAILED: FATAL TEST FUNCTION NOT FOUND" );
        }
        else
        {
            total_errors++;
        }
        for( int k = 0; k < unmet_dep_count; k++ )
        {
            free( unmet_dependencies[k] );
        }
        ++i;
        free(buffer);
    }

    if(total_errors == 0 && total_skipped==0)
        TEST_MESSAGE("ALL ECDSA PASSED" );
    else if(total_errors>0)
        TEST_MESSAGE("ECDSA TESTS FAILED" );
    else
        TEST_MESSAGE("Some tests skipped" );

    int* test_results = (int*)malloc(3*sizeof(int));
    test_results[0] = total_tests;
    test_results[1] = total_errors;
    test_results[2] = total_skipped;
    return test_results;
}
/*!
* \file IOLM_Port_spi.c
*
* \brief
* Interface for SPI Communication on IOLink Board
*
* \author
* KUNBUS GmbH
*
* \date
* 2021-05-19
*
* \copyright
* Copyright (c) 2021, KUNBUS GmbH<br /><br />
* All rights reserved.<br />
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:<br />
* <ol>
* <li>Redistributions of source code must retain the above copyright notice, this
* list of conditions and the following disclaimer.</li>
* <li>Redistributions in binary form must reproduce the above copyright notice,
* this list of conditions and the following disclaimer in the documentation
* and/or other materials provided with the distribution.</li>
* <li>Neither the name of the copyright holder nor the names of its
* contributors may be used to endorse or promote products derived from
* this software without specific prior written permission.</li>
* </ol>
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */

#include <osal.h>
#include "IOLM_Port_spi.h"
#include "IOL_Port_Types.h"

/* ========================================================================== */
/*                          Setup SPI Instances                               */
/* ========================================================================== */

IOLM_SPI_mapping_t ledPortConfig_g =
{
    .spiInstance    = IOLM_SPI_LED_INSTANCE,
    .spiChannel     = IOLM_SPI_LED_CHANNEL,
    .spiDataSize    = IOLM_SPI_LED_DATA_SIZE
};

IOLM_SPI_mapping_t ledIqConfig_g =
{
    .spiInstance    = IOLM_SPI_IQ_INSTANCE,
    .spiChannel     = IOLM_SPI_IQ_CHANNEL,
    .spiDataSize    = IOLM_SPI_IQ_DATA_SIZE
};

/* documentation in header */
void IOLM_SPI_init(void)
{
    /* init and de-init is handled via autogenerated SysCfg code in FreeRTOS MCU SDK */
}

void IOLM_SPI_close(void)
{
    /* init and de-init is handled via autogenerated SysCfg code in FreeRTOS MCU SDK */
}

/* documentation in header */
int32_t IOLM_SPI_mcspiTransfer(uint32_t mcspiInstance_p, uint32_t mcspiChannel_p, uint32_t mcspiDataSize_p,
                                uint8_t *pTxData_p, uint8_t *pRxData_p, uint32_t lengthInBytes_p)
{
    uint32_t            lengthInBits;
    uint32_t            lengthInWords;
    int32_t             error;
    MCSPI_Transaction   *pTransaction;
    // check the platform
    MCSPI_Transaction   transaction;
    pTransaction = &transaction;

    if((mcspiInstance_p >= CONFIG_MCSPI_NUM_INSTANCES) || (mcspiChannel_p >= MCSPI_MAX_NUM_CHANNELS)
       || (gMcspiConfig[mcspiInstance_p].object == NULL))
    {
        error = SystemP_FAILURE;
        OSAL_error(__FILE__, __LINE__, OSAL_eERR_INVALIDSTATE, true, 1,
                   "SPI setup does not match sysCfg SPI setup or SPI init failed.\r\n");
        goto laExit;
    }

    /* convert length in bytes to frames with channel/instance configuration specific width */
    lengthInBits      = lengthInBytes_p * 8;
    lengthInWords     = lengthInBits / mcspiDataSize_p;

    if((lengthInBits % mcspiDataSize_p) > 0 )
    {
        lengthInWords++;
    }

    MCSPI_Transaction_init(pTransaction);
    // load data to the cache
    if(MCSPI_OPER_MODE_DMA == ((MCSPI_Config *) gMcspiConfig[mcspiInstance_p].object->handle)->attrs->operMode)
    {
        CacheP_wb(pTxData_p, lengthInBytes_p, CacheP_TYPE_ALLD);
        CacheP_wbInv(pRxData_p, lengthInBytes_p, CacheP_TYPE_ALLD);
    }

    pTransaction->channel     = mcspiChannel_p;
    pTransaction->txBuf       = pTxData_p;
    pTransaction->rxBuf       = pRxData_p;
    pTransaction->dataSize    = mcspiDataSize_p;
    pTransaction->count       = lengthInWords;
    pTransaction->csDisable   = TRUE;

    error = MCSPI_transfer(gMcspiConfig[mcspiInstance_p].object->handle, pTransaction);
laExit:
    return error;
}

/* documentation in header */
bool IOLM_SPI_getIq(uint8_t portNum_p)
{
    uint8_t     rxBuf[2];
    int32_t     error;
    bool        iqState = false;

    error = IOLM_SPI_mcspiTransfer(ledIqConfig_g.spiInstance, ledIqConfig_g.spiChannel,
                                   ledIqConfig_g.spiDataSize, NULL,
                                   rxBuf, IOLM_SPI_LED_NUM_BYTES);

    if(error != SystemP_SUCCESS)
    {
        OSAL_error(__FILE__, __LINE__, OSAL_eERR_INVALIDSTATE, false, 1,
                   "Error while retrieving IQ state.\r\n");
    }

    iqState  = (rxBuf[1] >> portNum_p) & 0x1;

    return iqState;
}

/* documentation in header */
int32_t IOLM_SPI_setIolLeds(uint16_t bitMask_p)
{
    uint8_t     txBuf[IOLM_SPI_LED_NUM_BYTES];
    int32_t     error;

    txBuf[0] = bitMask_p & 0xFF;            /* get first byte of bitmask    */
    txBuf[1] = (bitMask_p >> 8) & 0xFF;     /* get second byte of bitmask   */

    error = IOLM_SPI_mcspiTransfer(ledPortConfig_g.spiInstance, ledPortConfig_g.spiChannel,
                                   ledPortConfig_g.spiDataSize, txBuf,
                                   NULL, IOLM_SPI_LED_NUM_BYTES);

    if(error != SystemP_SUCCESS)
    {
        OSAL_error(__FILE__, __LINE__, OSAL_eERR_INVALIDSTATE, false, 1,
                   "Error while setting LED states.\r\n");
    }

    return error;
}


/* documentation in header */
int32_t IOLM_SPI_baseBoardLED(uint32_t ledNumber_p, bool ledState_p)
{
    /* stub */
    (void) ledNumber_p;
    (void) ledState_p;
    return OSAL_eERR_NOTIMPLEMENTED;
}


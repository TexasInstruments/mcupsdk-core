
/*
 *  Copyright (C) 2024 Texas Instruments Incorporated
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



#include <stdint.h>
#include <mathlib/trig/ti_arm_trig.h>
#include <mathlib/trig/ti_tmu_trig.h>
#include <drivers/epwm.h>
#include <drivers/adc.h>
#include <math.h>
#include "ti_drivers_config.h"
#include "ti_drivers_open_close.h"
#include "ti_board_open_close.h"


/* # Example Description

This example demonstrates the gains of using TMU in an application-level. The example makes use of Park and Inverse Park Transform application
which has use cases in high performance drive architectures related to permanent magnet synchronous and asynchronous machines. To implement this in an application-level,
the Park and Inverse Park Transform computations are happening in an ISR context. We have configured an EPWM module which will trigger ADC
SOC conversions for two ADC modules. The interrupt gets generated by the ADC Module 1 at end of conversion, an within ISR the park and inverse park calculations take place.
These calculations makes use of TMU, TI ARM Trig Library and Mathlib library alternatively for trigonometric operations and computes the performance diiference between the
three in terms of avgerage cycles taken, max cycles taken and min cycles taken.

*/


typedef struct {

    Float32 alpha;
    Float32 beta;
    Float32 angle;
    Float32 sD;
    Float32 sQ;
    Float32 sine_val;
    Float32 cos_val;


} PARK;

typedef struct {

    Float32 alpha;
    Float32 beta;
    Float32 angle;
    Float32 sD;
    Float32 sQ;
    Float32 sine_val;
    Float32 cos_val;


} INV_PARK;

#define PARK_DEFAULTS { 0, \
                        0, \
                        0, \
                        0, \
                        0, \
                        0, \
                        0  \
                      }

#define INVPARK_DEFAULTS { 0, \
                           0, \
                           0, \
                           0, \
                           0, \
                           0, \
                           0  \
                         }

#define TESTSIZE 512
#define TEST_DATA_SECTION   __attribute__((aligned(8), section(".testData")))

#ifndef PI
#define PI                  3.14159265358979323846f
#endif

#ifndef ReciprocalOf2PI
#define ReciprocalOf2PI                0.159154943091895335768f
#endif

#define ADCConversionCount 512
#define OperationCount 3

TEST_DATA_SECTION float inputValue[TESTSIZE];
TEST_DATA_SECTION uint32_t mathlibCyclesPark[TESTSIZE];
TEST_DATA_SECTION uint32_t trigCyclesPark[TESTSIZE];
TEST_DATA_SECTION uint32_t tmuCyclesPark[TESTSIZE];
TEST_DATA_SECTION uint32_t mathlibCyclesInvPark[TESTSIZE];
TEST_DATA_SECTION uint32_t trigCyclesInvPark[TESTSIZE];
TEST_DATA_SECTION uint32_t tmuCyclesInvPark[TESTSIZE];

void park(PARK *obj);
void inverse_park(INV_PARK * obj);
static HwiP_Object  gADCHwiObject;
volatile uint32_t gTMUOperationsCount = 0;
static void App_adcISR(void *args);
volatile uint32_t gADCConversionCount = 0;
volatile uint32_t loopCount = 0;

uint32_t gAdc1baseAddr = CONFIG_ADC1_BASE_ADDR;
uint32_t gAdc1resultBaseAddr = CONFIG_ADC1_RESULT_BASE_ADDR;
uint32_t gAdc2baseAddr = CONFIG_ADC2_BASE_ADDR;
uint32_t gAdc2resultBaseAddr = CONFIG_ADC2_RESULT_BASE_ADDR;

uint32_t gtmuCount = 0;
uint32_t gtiarmclangCount = 0;
uint32_t gmathlibCount = 0;
uint16_t gAdc1Result0[ADCConversionCount];
uint16_t gAdc1Result1[ADCConversionCount];
uint16_t gAdc1Result2[ADCConversionCount];
uint16_t gAdc2Result0[ADCConversionCount];
uint16_t gAdc2Result1[ADCConversionCount];
uint16_t gAdc2Result2[ADCConversionCount];

bool gTMUOperation = false;
bool gTIARMClangOperation = false;
bool gMathlibOperation = false;

PARK gpark1;
INV_PARK ginvpark1;

void tmu_park_transform_main()
{
    Drivers_open();
    Board_driversOpen();

    DebugP_log("\nTMU Park Transform Test Started ...\r\n");


    int i;
    float testStep;
    float avgCyclesTMUPark, avgCyclesSDKPark, avgCyclesMathlibPark, maxCyclesTMUPark, maxCyclesSDKPark, maxCyclesMathlibPark, minCyclesTMUPark, minCyclesSDKPark, minCyclesMathlibPark;
    float avgCyclesTMUInvPark, avgCyclesSDKInvPark, avgCyclesMathlibInvPark, maxCyclesTMUInvPark, maxCyclesSDKInvPark, maxCyclesMathlibInvPark, minCyclesTMUInvPark, minCyclesSDKInvPark, minCyclesMathlibInvPark;
    uint32_t minIterations = 0x7f800000;
    int32_t  status;

    gpark1.alpha = 500;
    gpark1.beta = 400;

    ginvpark1.sD = 150;
    ginvpark1.sQ = 275;

    /*Creation of inputs*/
    testStep = 2 * PI / (float)TESTSIZE;
    for(i = 0; i < TESTSIZE; i++)
    {
        inputValue[i] = i * testStep;
    }

    /* Register and Enable interrupt */
    HwiP_Params  hwiPrms;
    HwiP_Params_init(&hwiPrms);

    hwiPrms.intNum      = CSLR_R5FSS0_CORE0_CONTROLSS_INTRXBAR0_OUT_0;
    hwiPrms.priority    = 0;
    hwiPrms.callback    = &App_adcISR;
    status              = HwiP_construct(&gADCHwiObject, &hwiPrms);
    DebugP_assert(status == SystemP_SUCCESS);

    EPWM_setTimeBaseCounterMode(CONFIG_EPWM0_BASE_ADDR, EPWM_COUNTER_MODE_UP);

    while( gADCConversionCount < ADCConversionCount );

    /* Read ADC Conversion results */
    DebugP_log("ADC Read Results : \r\n");
    for(i = 0; i< ADCConversionCount; i+=100)
    {
        DebugP_log("ADC 1 SOC0 result : %d, ADC1 SOC1 result : %d, ADC1 SOC2 result : %d \r\n", gAdc1Result0[i], gAdc1Result1[i], gAdc1Result2[i]);
        DebugP_log("ADC 2 SOC0 result : %d, ADC2 SOC1 result : %d, ADC2 SOC2 result : %d \r\n", gAdc2Result0[i], gAdc2Result1[i], gAdc2Result2[i]);
    }
    avgCyclesTMUPark = 0;
    avgCyclesSDKPark = 0;
    avgCyclesMathlibPark = 0;
    avgCyclesTMUInvPark = 0;
    avgCyclesSDKInvPark = 0;
    avgCyclesMathlibInvPark = 0;
    maxCyclesTMUPark = 0;
    maxCyclesSDKPark = 0;
    maxCyclesMathlibPark = 0;
    maxCyclesTMUInvPark = 0;
    maxCyclesSDKInvPark = 0;
    maxCyclesMathlibInvPark = 0;
    minCyclesTMUPark = 0x7f800000;
    minCyclesSDKPark = 0x7f800000;
    minCyclesMathlibPark = 0x7f800000;
    minCyclesTMUInvPark = 0x7f800000;
    minCyclesSDKInvPark = 0x7f800000;
    minCyclesMathlibInvPark = 0x7f800000;

    if(gtmuCount < gtiarmclangCount && gtmuCount < gmathlibCount)
        minIterations = gtmuCount;
    else if(gtiarmclangCount < gtmuCount && gtiarmclangCount < gmathlibCount)
        minIterations = gtiarmclangCount;
    else if(gmathlibCount < gtmuCount && gmathlibCount < gtiarmclangCount)
        minIterations = gmathlibCount;

    /* Computing avg cycles, max cycles and min cycles taken by each of the trigonometric operations method */
    for(i = 0; i < minIterations; i++)
    {
        avgCyclesTMUPark += tmuCyclesPark[i];
        avgCyclesSDKPark += trigCyclesPark[i];
        avgCyclesMathlibPark += mathlibCyclesPark[i];

        avgCyclesTMUInvPark += tmuCyclesInvPark[i];
        avgCyclesSDKInvPark += trigCyclesInvPark[i];
        avgCyclesMathlibInvPark += mathlibCyclesInvPark[i];

        if(tmuCyclesPark[i] > maxCyclesTMUPark)
            maxCyclesTMUPark = tmuCyclesPark[i];
        if(trigCyclesPark[i] > maxCyclesSDKPark)
            maxCyclesSDKPark = trigCyclesPark[i];
        if(mathlibCyclesPark[i] > maxCyclesMathlibPark)
            maxCyclesMathlibPark = mathlibCyclesPark[i];
        if(tmuCyclesInvPark[i] > maxCyclesTMUInvPark)
            maxCyclesTMUInvPark = tmuCyclesInvPark[i];
        if(trigCyclesInvPark[i] > maxCyclesSDKInvPark)
            maxCyclesSDKInvPark = trigCyclesInvPark[i];
        if(mathlibCyclesInvPark[i] > maxCyclesMathlibInvPark)
            maxCyclesMathlibInvPark = mathlibCyclesInvPark[i];

        if(tmuCyclesPark[i] < minCyclesTMUPark)
            minCyclesTMUPark = tmuCyclesPark[i];
        if(trigCyclesPark[i] < minCyclesSDKPark)
            minCyclesSDKPark = trigCyclesPark[i];
        if(mathlibCyclesPark[i] < minCyclesMathlibPark)
            minCyclesMathlibPark = mathlibCyclesPark[i];
        if(tmuCyclesInvPark[i] < minCyclesTMUInvPark)
            minCyclesTMUInvPark = tmuCyclesInvPark[i];
        if(trigCyclesInvPark[i] < minCyclesSDKInvPark)
            minCyclesSDKInvPark = trigCyclesInvPark[i];
        if(mathlibCyclesInvPark[i] < minCyclesMathlibInvPark)
            minCyclesMathlibInvPark = mathlibCyclesInvPark[i];

    }

    avgCyclesTMUPark = (float)avgCyclesTMUPark / (float)minIterations;
    avgCyclesSDKPark = (float)avgCyclesSDKPark / (float)minIterations;
    avgCyclesMathlibPark = (float)avgCyclesMathlibPark / (float)minIterations;

    avgCyclesTMUInvPark = (float)avgCyclesTMUInvPark / (float)minIterations;
    avgCyclesSDKInvPark = (float)avgCyclesSDKInvPark / (float)minIterations;
    avgCyclesMathlibInvPark = (float)avgCyclesMathlibInvPark / (float)minIterations;


    DebugP_log("Park Transform Results : \r\n");
    DebugP_log("Avg cycles taken by TMU : %f \r\n", avgCyclesTMUPark);
    DebugP_log("Avg cycles taken by TI ARM Trig Library : %f \r\n", avgCyclesSDKPark);
    DebugP_log("Avg cycles taken by Clang Mathlib Library : %f \r\n", avgCyclesMathlibPark);
    DebugP_log("Max cycles taken by TMU : %f \r\n", maxCyclesTMUPark);
    DebugP_log("Max cycles taken by TI ARM Trig Library : %f \r\n", maxCyclesSDKPark);
    DebugP_log("Max cycles taken by Clang Mathlib Library : %f \r\n", maxCyclesMathlibPark);
    DebugP_log("Min cycles taken by TMU : %f \r\n", minCyclesTMUPark);
    DebugP_log("Min cycles taken by TI ARM Trig Library : %f \r\n", minCyclesSDKPark);
    DebugP_log("Min cycles taken by Clang Mathlib Library : %f \r\n", minCyclesMathlibPark);

    DebugP_log("Inverse Park Transform Results : \r\n");
    DebugP_log("Avg cycles taken by TMU : %f \r\n", avgCyclesTMUInvPark);
    DebugP_log("Avg cycles taken by TI ARM Trig Library : %f \r\n", avgCyclesSDKInvPark);
    DebugP_log("Avg cycles taken by Clang Mathlib Library : %f \r\n", avgCyclesMathlibInvPark);
    DebugP_log("Max cycles taken by TMU : %f \r\n", maxCyclesTMUInvPark);
    DebugP_log("Max cycles taken by TI ARM Trig Library : %f \r\n", maxCyclesSDKInvPark);
    DebugP_log("Max cycles taken by Clang Mathlib Library : %f \r\n", maxCyclesMathlibInvPark);
    DebugP_log("Min cycles taken by TMU : %f \r\n", minCyclesTMUInvPark);
    DebugP_log("Min cycles taken by TI ARM Trig Library : %f \r\n", minCyclesSDKInvPark);
    DebugP_log("Min cycles taken by Clang Mathlib Library : %f \r\n", minCyclesMathlibInvPark);

    DebugP_log("\r\nTMU Park Transform Test Passed!!\r\n");
    DebugP_log("All tests have passed!!\r\n");

    Board_driversClose();
    Drivers_close();

    return;
}

static void App_adcISR(void *args)
{


     if(gADCConversionCount < ADCConversionCount )
     {
        /* Here USERS can add their applicatin-specific code */
        gAdc1Result0[gADCConversionCount] = ADC_readResult(gAdc1resultBaseAddr, ADC_SOC_NUMBER0);
        gAdc1Result1[gADCConversionCount] = ADC_readResult(gAdc1resultBaseAddr, ADC_SOC_NUMBER1);
        gAdc1Result2[gADCConversionCount] = ADC_readResult(gAdc1resultBaseAddr, ADC_SOC_NUMBER2);
        gAdc2Result0[gADCConversionCount] = ADC_readResult(gAdc2resultBaseAddr, ADC_SOC_NUMBER0);
        gAdc2Result1[gADCConversionCount] = ADC_readResult(gAdc2resultBaseAddr, ADC_SOC_NUMBER1);
        gAdc2Result2[gADCConversionCount] = ADC_readResult(gAdc2resultBaseAddr, ADC_SOC_NUMBER2);
        if(gADCConversionCount % OperationCount == 0)
            gTMUOperation = true;
        else if(gADCConversionCount % OperationCount == 1)
            gTIARMClangOperation = true;
        else
            gMathlibOperation = true;

        /* Call to Park and Inverse Park Transform Operations */
        park(&gpark1);
        inverse_park(&ginvpark1);
        loopCount++;
     }
     else
     {
        EPWM_setTimeBaseCounterMode(CONFIG_EPWM0_BASE_ADDR, EPWM_COUNTER_MODE_STOP_FREEZE);
     }

    gADCConversionCount++;

    ADC_clearInterruptStatus(gAdc1baseAddr, ADC_INT_NUMBER1);

    if(true == ADC_getInterruptOverflowStatus(gAdc1baseAddr, ADC_INT_NUMBER1))
    {
        ADC_clearInterruptStatus(gAdc1baseAddr, ADC_INT_NUMBER1);
        ADC_clearInterruptOverflowStatus(gAdc1baseAddr, ADC_INT_NUMBER1);
    }
}

void park(PARK *obj)
{

    uint32_t t1, t2, t3;


        obj->angle = inputValue[loopCount];

        if(gTMUOperation)
        {
            /* TMU Calculation */
            t1 = CycleCounterP_getCount32();
            obj->sD = (obj->alpha * ti_tmu_cos(obj->angle)) + (obj->beta * ti_tmu_sin(obj->angle));
            obj->sQ = (obj->beta * ti_tmu_cos(obj->angle)) - (obj->alpha * ti_tmu_sin(obj->angle));
            t2 = CycleCounterP_getCount32();
            t3 = CycleCounterP_getCount32();
            tmuCyclesPark[gtmuCount] = (t2 - t1) - (t3 - t2);


        }
        else if(gTIARMClangOperation)
        {
            /* TI ARM Clang Trigonometric Calculation */
            t1 = CycleCounterP_getCount32();
            obj->sD = (obj->alpha * ti_arm_cos(obj->angle)) + (obj->beta * ti_arm_sin(obj->angle));
            obj->sQ = (obj->beta * ti_arm_cos(obj->angle)) - (obj->alpha * ti_arm_sin(obj->angle));
            t2 = CycleCounterP_getCount32();
            t3 = CycleCounterP_getCount32();
            trigCyclesPark[gtiarmclangCount] = (t2 - t1) - (t3 - t2);


        }
        else if(gMathlibOperation)
        {
            /* Clang Matlib Trigonometric Calculation */
           t1 = CycleCounterP_getCount32();
           obj->sD = (obj->alpha * cosf(obj->angle)) + (obj->beta * sinf(obj->angle));
           obj->sQ = (obj->beta * cosf(obj->angle)) - (obj->alpha * sinf(obj->angle));
           t2 = CycleCounterP_getCount32();
           t3 = CycleCounterP_getCount32();
           mathlibCyclesPark[gmathlibCount] = (t2 - t1) - (t3 - t2);


        }

    return;

}

void inverse_park(INV_PARK *obj)
{
    uint32_t t1, t2, t3;

        obj->angle = inputValue[loopCount];

        if(gTMUOperation)
        {
            /* TMU Calculation */
            t1 = CycleCounterP_getCount32();
            obj->alpha = (obj->sD * ti_tmu_cos(obj->angle)) - (obj->sQ * ti_tmu_sin(obj->angle));
            obj->beta = (obj->sD * ti_tmu_sin(obj->angle)) + (obj->sQ * ti_tmu_cos(obj->angle));
            t2 = CycleCounterP_getCount32();
            t3 = CycleCounterP_getCount32();
            tmuCyclesInvPark[gtmuCount] = (t2 - t1) - (t3 - t2);
            gtmuCount++;
            gTMUOperation = false;
        }
        else if(gTIARMClangOperation)
        {
            /* TI ARM Clang Trigonometric Calculation */
            t1 = CycleCounterP_getCount32();
            obj->alpha = (obj->sD * ti_arm_cos(obj->angle)) - (obj->sQ * ti_arm_sin(obj->angle));
            obj->beta = (obj->sD * ti_arm_sin(obj->angle)) + (obj->sQ * ti_arm_cos(obj->angle));
            t2 = CycleCounterP_getCount32();
            t3 = CycleCounterP_getCount32();
            trigCyclesInvPark[gtiarmclangCount] = (t2 - t1) - (t3 - t2);
            gtiarmclangCount++;
            gTIARMClangOperation = false;
        }
        else if(gMathlibOperation)
        {
            /* Clang Matlib Trigonometric Calculation */
            t1 = CycleCounterP_getCount32();
            obj->alpha = (obj->sD * cosf(obj->angle)) - (obj->sQ * sinf(obj->angle));
            obj->beta = (obj->sD * sinf(obj->angle)) + (obj->sQ * cosf(obj->angle));
            t2 = CycleCounterP_getCount32();
            t3 = CycleCounterP_getCount32();
            mathlibCyclesInvPark[gmathlibCount] = (t2 - t1) - (t3 - t2);
            gmathlibCount++;
            gMathlibOperation = false;
        }


    return;
}




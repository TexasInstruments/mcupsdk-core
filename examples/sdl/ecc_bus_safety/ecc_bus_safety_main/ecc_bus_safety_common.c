/* Copyright (c) 2022-23 Texas Instruments Incorporated
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

 /**
 *  \file     ecc_bus_safety_common.c
 *
 *  \brief    This file contains common supporting function for Ecc Bus Safety.
 *
 *  \details  ECC_BUS_SAFETY APP
 **/

/*===========================================================================*/
/*                         Include files                                     */
/*===========================================================================*/
#include "ecc_bus_safety.h"
/*===========================================================================*/
/*                         Internal function declarations                    */
/*===========================================================================*/

/*===========================================================================*/
/*                         Global Variables                                  */
/*===========================================================================*/
/* EDMA variables */
uint32_t            *srcBuffPtr, *dstBuffPtr;
EDMACCPaRAMEntry   edmaParam1, edmaParam2;

/* The source buffer used for transfer */
static uint32_t gEdmaTestSrcBuff[EDMA_TEST_BUFFER_SIZE] __attribute__((aligned(CacheP_CACHELINE_ALIGNMENT)))= {0x12345678U,0x1234567U};
/* The destination buffer used for transfer */
static uint32_t gEdmaTestDstBuff[EDMA_TEST_BUFFER_SIZE] __attribute__((aligned(CacheP_CACHELINE_ALIGNMENT)));

/* TX AND RX DESCRIPTORS */
unsigned char CppiRxPkt0 [] = {0x00,0x00,0x00,0x00,0x00,0x02,0x28,0xC0,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x20}; /* MEMORY_RX_BUFFER */
unsigned char CppiTxPkt0 [] = {0x00,0x00,0x00,0x00,0x00,0x07,0x28,0xC0,0x00,0x04,0x00,0x00,0x00,0x04,0x11,0xe0}; /* MEMORY_TX_BUFFER */

unsigned char TxBufferData0 [] = {

 0x52,0x4c,0x94,0x9d,0xc8,0x9f,0x0d,0x03,0x20,0x7e,0x69,0x6e,0x82,0x3e,0xfc,0xe3,
 0xe3,0x3c,0x31,0xef,0x2b,0x9f,0xae,0xed,0x36,0x92,0xc5,0x00,0xc5,0xfc,0x55,0xdc,
 0x6f,0xe7,0x17,0x9b,0x5c,0x67,0xf5,0x56,0x38,0x21,0x1c,0x61,0xbd,0xcb,0xec,0xd8,
 0xb4,0x39,0x4e,0xba,0xd9,0x63,0x4b,0x3f,0x27,0x59,0x0b,0xe9,0xb8,0xaa,0x2c,0x90,
 0xa5,0x3f,0x74,0x5f,0xb3,0xdd,0xb0,0x62,0x17,0xfb,0x0e,0xde,0x12,0x51,0xfe,0x4a,
 0x0a,0xb0,0x8f,0xf4,0xa3,0x56,0xaa,0x2e,0x63,0xf1,0x2c,0xb5,0xf5,0x3f,0x94,0x58,
 0x62,0x9e,0xfb,0xc1,0xb4,0x95,0xe2,0xae,0xfe,0xbb,0x5d,0x14,0x23,0x2c,0xe2,0xb0,
 0xa1,0x9d,0x72,0xcf,0xaf,0x35,0x83,0x62,0xf3,0x67,0x0f,0x51,0x02,0x6c,0xc1,0x15,
 0xda,0x13,0x0d,0x79,0x15,0x7d,0xd0,0x45,0xb0,0x3f,0x7e,0x74,0x26,0x18,0x56,0x51,
 0x3d,0xd8,0xba,0x1c,0xe5,0x9a,0xb2,0xd6,0x84,0xb6,0xd0,0x2a,0x24,0x82,0x76,0x2a,
 0x37,0x8e,0xdb,0x0b,0x31,0x07,0x68,0x84,0xf6,0xa4,0x2a,0x2e,0x43,0x30,0x9d,0x96,
 0xae,0x14,0xd6,0x5d,0x93,0xb5,0x60,0xe1,0x2c,0xda,0x87,0x8a,0x70,0xac,0xbc,0x51,
 0xeb,0x79,0x19,0xb5,0x61,0x3b,0x23,0xae,0xf1,0x77,0xe0,0x8a,0xe1,0x6a,0x26,0xad,
 0xa6,0xf6,0xf2,0x92,0xef,0x11,0x2e,0x6d,0x60,0x5a,0x39,0x74,0x30,0x1a,0xfc,0x2b,
 0xba,0x63,0x59,0xdd,0xd2,0x4a,0xa5,0xb0,0xf2,0xd4,0x7c,0x3b,0x8d,0x15,0xb7,0xde,
 0x9f,0x97,0xf6,0x76,0x4f,0xe4,0xad,0xa0,0xe2,0xa9,0x29,0x65,0x0a,0x78,0x61,0xde,
 0xff,0xbe,0x6c,0xa0,0x55,0xc7,0x82,0x55,0xd6,0x57,0x47,0x2e,0x63,0xb1,0xb2,0x77,
 0x3c,0xd8,0x7a,0x3f,0xc8,0x75,0xba,0xb7,0xc9,0x4c,0x90,0xc4,0x0f,0xa4,0xd0,0xe7,
 0x6d,0xe6,0x20,0xc4,0xfa,0x14,0xde,0x4e,0x43,0x87,0x77,0x02,0xb6,0x78,0x33,0xf1,
 0x51,0xd7,0x60,0xdb,0x2b,0x3a,0x6a,0x23,0x3f,0x96,0xc8,0xd5,0x54,0x21,0x8d,0xd6,
 0x41,0x64,0x46,0xc1,0x02,0x8a,0x3c,0xdd,0xa0,0xbc,0x11,0x97,0x21,0x87,0x84,0xaf,
 0xb9,0xfe,0x1a,0x69,0x11,0x1c,0xc4,0x55,0x8a,0xe0,0x7b,0x05,0x49,0x0d,0x51,0x65,
 0x6a,0x2e,0xe2,0xf2,0x64,0xa0,0x7f,0x0e,0x29,0x91,0xfd,0xc5,0x08,0xb2,0x7c,0x87,
 0x3a,0x83,0x8a,0xf4,0xc2,0xa0,0x1d,0xe8,0xed,0x49,0x88,0xe6,0x7d,0x18,0x7c,0x5f,
 0x24,0xdd,0x36,0x94,0xc4,0x34,0x69,0x8b,0xb6,0x6a,0x76,0xf5,0x7f,0x22,0x9d,0x38,
 0x01,0x8a,0x88,0x62,0x65,0x98,0x40,0x70,0x06,0x03,0xfd,0x28,0xc3,0xa9,0xe5,0xff,
 0x80,0x88,0xb6,0x9a,0x32,0xef,0xa0,0xf7,0x36,0x97,0xe9,0x4c,0x74,0x73,0x8d,0x57,
 0x75,0x03,0x5c,0x2f,0x10,0x3b,0xec,0xdd,0x0e,0xe8,0x71,0x64,0x83,0x76,0xae,0x50,
 0x57,0x5d,0x5b,0x47,0x4c,0xcc,0x73,0x97,0x3f,0xb8,0x98,0xc1,0x52,0x6d,0xa9,0x6f,
 0xb5,0x8a,0x70,0x5d,0x44,0xa8,0x3d,0x89,0xcc,0x0e,0xf7,0xe3,0xb2,0x83,0x49,0x55,
 0x99,0x70,0x37,0x1c,0x75,0xeb,0x73,0x8f,0xc2,0xaa,0x67,0xa3,0x06,0x7d,0x5f,0xce,
 0xfd,0xf0,0xc0,0xc0,0x89,0x7d,0x45,0x72,0x6f,0x2e,0x57,0x26,0x62,0x95,0xe1,0x49,
 0x4c,0x09,0x88,0x36,0x82,0xde,0x35,0x41,0x22,0xca,0x7e,0x91,0x3e,0x50,0xba,0x24,
 0xf7,0xfc,0x09,0x99,0x62,0x2a,0xb8,0x34,0x93,0x19,0x79,0x07,0xdf,0xb8,0xde,0xc8,
 0xf9,0xb3,0xbe,0x50,0x15,0x75,0x48,0xc1,0xa0,0x43,0x72,0x15,0x87,0x51,0xc6,0xaf,
 0x49,0x9b,0x97,0x8b,0xfe,0x65,0xf3,0x22,0xa5,0xe1,0x37,0xe5,0x62,0xfc,0xa7,0x51,
 0xe9,0xd4,0x89,0x20,0x91,0x0e,0x61,0x12,0x0f,0x03,0xc6,0xb0,0xb6,0x15,0x90,0x69,
 0x96,0xb8,0xcb,0x66,0xed,0xa5,0xb2,0x66,0xa2,0x7c,0x2a,0x56,0xed,0xb6,0xd2,0x4e,
 0x72,0x2e,0xdb,0x50,0x2f,0xd2,0x06,0x45,0x01,0xd2,0x81,0xce,0xdc,0xae,0x15,0xf2,
 0xb2,0x31,0x7a,0x4d,0xba,0x86,0xc8,0x2d,0x86,0x71,0x01,0xb7,0x69,0x15,0x37,0x90,
 0x12,0x40,0x12,0x4c,0xd3,0xba,0xd2,0x34,0x18,0x9b,0x78,0xaf,0xdc,0xa0,0x5e,0xfe,
 0xe1,0x11,0x0f,0xfc,0x99,0xa6,0xd7,0x12,0xd4,0xd2,0x00,0x79,0x7f,0xad,0x42,0x66,
 0xb9,0x92,0x38,0xce,0x09,0xb7,0x7e,0xb2,0xca,0x15,0x4f,0xac,0xf9,0x11,0xbc,0x6d,
 0xdf,0xb4,0xd6,0x36,0x30,0xea,0x5d,0x4a,0x70,0x37,0x55,0x79,0x7c,0x9b,0x25,0x0e,
 0x3d,0xc5,0x5a,0x0a,0x98,0x46,0x01,0xa5,0x22,0x72,0xcf,0x5d,0x92,0x61,0xd8,0x92,
 0xe6,0xc9,0x6f,0x31,0x1d,0x12,0xfa,0xf3,0xb3,0x16,0xf6,0x5d,0x0c,0xe0,0x3f,0x41,
 0x66,0x91,0xb5,0x30,0xad,0x7f,0xaf,0x6b,0xdc,0xbb,0x4b,0xc2,0x8a,0x80,0x9f,0xf7,
 0xbb,0x27,0xa6,0x65,0xfd,0x8f,0xa5,0x99,0xe8,0x97,0x2c,0x26,0xd0,0xb6,0x68,0x6d,
 0x3b,0xca,0x2d,0x97,0x62,0xa0,0xf8,0xff,0xc3,0x21,0x2c,0xc5,0x47,0x41,0xae,0x1c,
 0x6a,0xfc,0x41,0x9a,0x16,0xdb,0x95,0xb8,0x0d,0x86,0x24,0x8e,0x1e,0x24,0xc1,0xc9,
 0x67,0x99,0x8a,0x73,0x8c,0xcd,0x55,0x28,0xe0,0x15,0xe7,0x64,0x03,0x27,0x9c,0xfb,
 0x31,0x91,0xf0,0x54,0xfe,0xb5,0xf7,0xca,0x57,0x65,0x01,0x4b,0x0e,0xda,0x41,0xf2,
 0x32,0x89,0xae,0xa7,0x53,0xae,0x97,0xa8,0x49,0xb1,0x55,0x33,0xef,0x43,0x47,0x41,
 0x34,0xd2,0x61,0x74,0x02,0xee,0xcf,0xab,0x09,0xda,0x99,0xd0,0xd5,0x94,0x64,0x75,
 0x2b,0x3a,0xa5,0xcf,0x2e,0x2b,0x0c,0xbd,0x63,0xcd,0x74,0xf7,0x2a,0xe6,0x08,0xad,
 0x98,0xe8,0x34,0x31,0x84,0xeb,0x39,0x44,0xef,0xdb,0x2f,0x57,0xbf,0x9b,0xfe,0x45,
 0x1a,0x20,0xc3,0x05,0x13,0x17,0x89,0x60,0x6c,0xab,0xb8,0x7d,0x79,0x11,0xb5,0xf3,
 0xa8,0x7d,0x52,0xb1,0xcf,0x7d,0x84,0x50,0x48,0x7d,0x31,0x5b,0x17,0xdf,0x19,0x8e,
 0xd3,0x43,0x1e,0xd0,0x78,0x69,0x09,0x0d,0x84,0x08,0x46,0x08,0x2f,0xed,0x6a,0xd7,
 0xd1,0xf9,0xdc,0x50,0xd8,0x0c,0xd9,0x64,0x9a,0x32,0x7e,0x6e,0xa2,0xdd,0xe3,0x6e,
 0x1d,0x82,0xfb,0x7d,0x69,0x3f,0xdb,0x2e,0xea,0x73,0x15,0xd9,0x22,0xcd,0x9e,0x71,
 0xe8,0x93,0x7c,0xe0,0xd6,0x6f,0x77,0x94,0x0c,0x66,0x69,0x93,0xb9,0xe3,0xc7,0x01,
 0x2c,0x60,0x14,0x1c,0xe2,0xc1,0xf3,0x3f,0x71,0xe4,0xa0,0xd8,0x9a,0x79,0x65,0xb2,
 0xe7,0x52,0x5f,0x4f,0xac,0xbb,0xcd,0xd2,0x31,0x7f,0xa4,0xc8,0xd4,0x95,0x70,0x41

};

unsigned char ExpBufferData0 [] = {

 0xFF,0x4c,0x94,0x9d,0xc8,0x9f,0x0d,0x03,0x20,0x7e,0x69,0x6e,0x82,0x3e,0xfc,0xe3,
 0xe3,0x3c,0x31,0xef,0x2b,0x9f,0xae,0xed,0x36,0x92,0xc5,0x00,0xc5,0xfc,0x55,0xdc,
 0x6f,0xe7,0x17,0x9b,0x5c,0x67,0xf5,0x56,0x38,0x21,0x1c,0x61,0xbd,0xcb,0xec,0xd8,
 0xb4,0x39,0x4e,0xba,0xd9,0x63,0x4b,0x3f,0x27,0x59,0x0b,0xe9,0xb8,0xaa,0x2c,0x90,
 0xa5,0x3f,0x74,0x5f,0xb3,0xdd,0xb0,0x62,0x17,0xfb,0x0e,0xde,0x12,0x51,0xfe,0x4a,
 0x0a,0xb0,0x8f,0xf4,0xa3,0x56,0xaa,0x2e,0x63,0xf1,0x2c,0xb5,0xf5,0x3f,0x94,0x58,
 0x62,0x9e,0xfb,0xc1,0xb4,0x95,0xe2,0xae,0xfe,0xbb,0x5d,0x14,0x23,0x2c,0xe2,0xb0,
 0xa1,0x9d,0x72,0xcf,0xaf,0x35,0x83,0x62,0xf3,0x67,0x0f,0x51,0x02,0x6c,0xc1,0x15,
 0xda,0x13,0x0d,0x79,0x15,0x7d,0xd0,0x45,0xb0,0x3f,0x7e,0x74,0x26,0x18,0x56,0x51,
 0x3d,0xd8,0xba,0x1c,0xe5,0x9a,0xb2,0xd6,0x84,0xb6,0xd0,0x2a,0x24,0x82,0x76,0x2a,
 0x37,0x8e,0xdb,0x0b,0x31,0x07,0x68,0x84,0xf6,0xa4,0x2a,0x2e,0x43,0x30,0x9d,0x96,
 0xae,0x14,0xd6,0x5d,0x93,0xb5,0x60,0xe1,0x2c,0xda,0x87,0x8a,0x70,0xac,0xbc,0x51,
 0xeb,0x79,0x19,0xb5,0x61,0x3b,0x23,0xae,0xf1,0x77,0xe0,0x8a,0xe1,0x6a,0x26,0xad,
 0xa6,0xf6,0xf2,0x92,0xef,0x11,0x2e,0x6d,0x60,0x5a,0x39,0x74,0x30,0x1a,0xfc,0x2b,
 0xba,0x63,0x59,0xdd,0xd2,0x4a,0xa5,0xb0,0xf2,0xd4,0x7c,0x3b,0x8d,0x15,0xb7,0xde,
 0x9f,0x97,0xf6,0x76,0x4f,0xe4,0xad,0xa0,0xe2,0xa9,0x29,0x65,0x0a,0x78,0x61,0xde,
 0xff,0xbe,0x6c,0xa0,0x55,0xc7,0x82,0x55,0xd6,0x57,0x47,0x2e,0x63,0xb1,0xb2,0x77,
 0x3c,0xd8,0x7a,0x3f,0xc8,0x75,0xba,0xb7,0xc9,0x4c,0x90,0xc4,0x0f,0xa4,0xd0,0xe7,
 0x6d,0xe6,0x20,0xc4,0xfa,0x14,0xde,0x4e,0x43,0x87,0x77,0x02,0xb6,0x78,0x33,0xf1,
 0x51,0xd7,0x60,0xdb,0x2b,0x3a,0x6a,0x23,0x3f,0x96,0xc8,0xd5,0x54,0x21,0x8d,0xd6,
 0x41,0x64,0x46,0xc1,0x02,0x8a,0x3c,0xdd,0xa0,0xbc,0x11,0x97,0x21,0x87,0x84,0xaf,
 0xb9,0xfe,0x1a,0x69,0x11,0x1c,0xc4,0x55,0x8a,0xe0,0x7b,0x05,0x49,0x0d,0x51,0x65,
 0x6a,0x2e,0xe2,0xf2,0x64,0xa0,0x7f,0x0e,0x29,0x91,0xfd,0xc5,0x08,0xb2,0x7c,0x87,
 0x3a,0x83,0x8a,0xf4,0xc2,0xa0,0x1d,0xe8,0xed,0x49,0x88,0xe6,0x7d,0x18,0x7c,0x5f,
 0x24,0xdd,0x36,0x94,0xc4,0x34,0x69,0x8b,0xb6,0x6a,0x76,0xf5,0x7f,0x22,0x9d,0x38,
 0x01,0x8a,0x88,0x62,0x65,0x98,0x40,0x70,0x06,0x03,0xfd,0x28,0xc3,0xa9,0xe5,0xff,
 0x80,0x88,0xb6,0x9a,0x32,0xef,0xa0,0xf7,0x36,0x97,0xe9,0x4c,0x74,0x73,0x8d,0x57,
 0x75,0x03,0x5c,0x2f,0x10,0x3b,0xec,0xdd,0x0e,0xe8,0x71,0x64,0x83,0x76,0xae,0x50,
 0x57,0x5d,0x5b,0x47,0x4c,0xcc,0x73,0x97,0x3f,0xb8,0x98,0xc1,0x52,0x6d,0xa9,0x6f,
 0xb5,0x8a,0x70,0x5d,0x44,0xa8,0x3d,0x89,0xcc,0x0e,0xf7,0xe3,0xb2,0x83,0x49,0x55,
 0x99,0x70,0x37,0x1c,0x75,0xeb,0x73,0x8f,0xc2,0xaa,0x67,0xa3,0x06,0x7d,0x5f,0xce,
 0xfd,0xf0,0xc0,0xc0,0x89,0x7d,0x45,0x72,0x6f,0x2e,0x57,0x26,0x62,0x95,0xe1,0x49,
 0x4c,0x09,0x88,0x36,0x82,0xde,0x35,0x41,0x22,0xca,0x7e,0x91,0x3e,0x50,0xba,0x24,
 0xf7,0xfc,0x09,0x99,0x62,0x2a,0xb8,0x34,0x93,0x19,0x79,0x07,0xdf,0xb8,0xde,0xc8,
 0xf9,0xb3,0xbe,0x50,0x15,0x75,0x48,0xc1,0xa0,0x43,0x72,0x15,0x87,0x51,0xc6,0xaf,
 0x49,0x9b,0x97,0x8b,0xfe,0x65,0xf3,0x22,0xa5,0xe1,0x37,0xe5,0x62,0xfc,0xa7,0x51,
 0xe9,0xd4,0x89,0x20,0x91,0x0e,0x61,0x12,0x0f,0x03,0xc6,0xb0,0xb6,0x15,0x90,0x69,
 0x96,0xb8,0xcb,0x66,0xed,0xa5,0xb2,0x66,0xa2,0x7c,0x2a,0x56,0xed,0xb6,0xd2,0x4e,
 0x72,0x2e,0xdb,0x50,0x2f,0xd2,0x06,0x45,0x01,0xd2,0x81,0xce,0xdc,0xae,0x15,0xf2,
 0xb2,0x31,0x7a,0x4d,0xba,0x86,0xc8,0x2d,0x86,0x71,0x01,0xb7,0x69,0x15,0x37,0x90,
 0x12,0x40,0x12,0x4c,0xd3,0xba,0xd2,0x34,0x18,0x9b,0x78,0xaf,0xdc,0xa0,0x5e,0xfe,
 0xe1,0x11,0x0f,0xfc,0x99,0xa6,0xd7,0x12,0xd4,0xd2,0x00,0x79,0x7f,0xad,0x42,0x66,
 0xb9,0x92,0x38,0xce,0x09,0xb7,0x7e,0xb2,0xca,0x15,0x4f,0xac,0xf9,0x11,0xbc,0x6d,
 0xdf,0xb4,0xd6,0x36,0x30,0xea,0x5d,0x4a,0x70,0x37,0x55,0x79,0x7c,0x9b,0x25,0x0e,
 0x3d,0xc5,0x5a,0x0a,0x98,0x46,0x01,0xa5,0x22,0x72,0xcf,0x5d,0x92,0x61,0xd8,0x92,
 0xe6,0xc9,0x6f,0x31,0x1d,0x12,0xfa,0xf3,0xb3,0x16,0xf6,0x5d,0x0c,0xe0,0x3f,0x41,
 0x66,0x91,0xb5,0x30,0xad,0x7f,0xaf,0x6b,0xdc,0xbb,0x4b,0xc2,0x8a,0x80,0x9f,0xf7,
 0xbb,0x27,0xa6,0x65,0xfd,0x8f,0xa5,0x99,0xe8,0x97,0x2c,0x26,0xd0,0xb6,0x68,0x6d,
 0x3b,0xca,0x2d,0x97,0x62,0xa0,0xf8,0xff,0xc3,0x21,0x2c,0xc5,0x47,0x41,0xae,0x1c,
 0x6a,0xfc,0x41,0x9a,0x16,0xdb,0x95,0xb8,0x0d,0x86,0x24,0x8e,0x1e,0x24,0xc1,0xc9,
 0x67,0x99,0x8a,0x73,0x8c,0xcd,0x55,0x28,0xe0,0x15,0xe7,0x64,0x03,0x27,0x9c,0xfb,
 0x31,0x91,0xf0,0x54,0xfe,0xb5,0xf7,0xca,0x57,0x65,0x01,0x4b,0x0e,0xda,0x41,0xf2,
 0x32,0x89,0xae,0xa7,0x53,0xae,0x97,0xa8,0x49,0xb1,0x55,0x33,0xef,0x43,0x47,0x41,
 0x34,0xd2,0x61,0x74,0x02,0xee,0xcf,0xab,0x09,0xda,0x99,0xd0,0xd5,0x94,0x64,0x75,
 0x2b,0x3a,0xa5,0xcf,0x2e,0x2b,0x0c,0xbd,0x63,0xcd,0x74,0xf7,0x2a,0xe6,0x08,0xad,
 0x98,0xe8,0x34,0x31,0x84,0xeb,0x39,0x44,0xef,0xdb,0x2f,0x57,0xbf,0x9b,0xfe,0x45,
 0x1a,0x20,0xc3,0x05,0x13,0x17,0x89,0x60,0x6c,0xab,0xb8,0x7d,0x79,0x11,0xb5,0xf3,
 0xa8,0x7d,0x52,0xb1,0xcf,0x7d,0x84,0x50,0x48,0x7d,0x31,0x5b,0x17,0xdf,0x19,0x8e,
 0xd3,0x43,0x1e,0xd0,0x78,0x69,0x09,0x0d,0x84,0x08,0x46,0x08,0x2f,0xed,0x6a,0xd7,
 0xd1,0xf9,0xdc,0x50,0xd8,0x0c,0xd9,0x64,0x9a,0x32,0x7e,0x6e,0xa2,0xdd,0xe3,0x6e,
 0x1d,0x82,0xfb,0x7d,0x69,0x3f,0xdb,0x2e,0xea,0x73,0x15,0xd9,0x22,0xcd,0x9e,0x71,
 0xe8,0x93,0x7c,0xe0,0xd6,0x6f,0x77,0x94,0x0c,0x66,0x69,0x93,0xb9,0xe3,0xc7,0x01,
 0x2c,0x60,0x14,0x1c,0xe2,0xc1,0xf3,0x3f,0x71,0xe4,0xa0,0xd8,0x9a,0x79,0x65,0xb2,
 0xe7,0x52,0x5f,0x4f,0xac,0xbb,0xcd,0xd2,0x31,0x7f,0xa4,0xc8,0xd4,0x95,0x70,0x41

};
/*===========================================================================*/
/*                         Macros                                            */
/*===========================================================================*/
#define CPSW_NC_BASE 0x20000U
#define CPSW_ALE_BASE 0x1E000U
#define CPSW_ENET_BASE 0x2000U

/* Test Memory */
#define NON_CPU_RX_BUFFER_DESC    0xC0280000U
#define RX_BUFFER_DESC            0x10280000U
#define NON_CPU_TX_BUFFER_DESC    0xC0280100U
#define TX_BUFFER_DESC            0x10280100U
#define MEMORY_RX_BUFFER          0x10280200U
#define MEMORY_TX_BUFFER          0x10280700U

#define SS_C0_TH_En             (0x00000084UL)
#define SS_C0_FH_En             (0x00000088UL)
#define CPSW_Control            (0x00000004UL)
#define CPSW_Stat_Port_En       (0x00000014UL)
#define CPPI_P0_Flow_ID_Offset  (0x00001008UL)
#define CPPI_P0_Rx_Maxlen       (0x00001024UL)
#define ALE_CONTROL             (0x00000008UL)
#define ALE_TBLCTL              (0x00000020UL)
#define ALE_TBLW2               (0x00000034UL)
#define ALE_TBLW1               (0x00000038UL)
#define ALE_TBLW0               (0x0000003cUL)
#define ALE_PORTCTL             (0x00000040UL)
#define Enet_Pn_Mac_Control     (0x00000330UL)
#define Enet_Pn_Mac_Status      (0x00000334UL)
#define Enet_Pn_Mac_Soft_Reset  (0x00000338UL)
#define Enet_Pn_Rx_Maxlen       (0x00000024UL)
#define CPDMA_EOI_Vector        (0x00014094UL)
#define CPDMA_FH0_HDP           (0x00014200UL)
#define CPDMA_TH0_HDP           (0x00014220UL)
#define CPDMA_FH0_CP            (0x00014240UL)
#define CPDMA_TH0_CP            (0x00014260UL)
#define CPDMA_TH_IntMask_Set    (0x000140a8UL)
#define CPDMA_TH_Buffer_Offset  (0x00014028UL)
#define CPDMA_FH_IntMask_Set    (0x00014088UL)
#define CPDMA_FH_Control        (0x00014004UL)
#define CPDMA_TH_Control        (0x00014014UL)
#define CPDMA_FH_IntStat_Masked (0x00014084UL)
#define CPDMA_TH_IntStat_Masked (0x000140a4UL)

#define DATA_BYTES                       (256) /* Number of data bytes */
#define PSI_WORDS                          (0) /* Number of protocol-specific words*/
#define DESC_BUFSIZE                    (2048) /* Max packet size*/

#define UWORD32 uint32_t
/*===========================================================================*/
/*                   Local Function definitions                              */
/*===========================================================================*/

#if defined (SOC_AM273X) ||  defined (SOC_AWR294X)
#if defined (SUBSYS_DSS)

/********************************************************************************************************
*   Function to select the parameters for EDMA config according to Nodes
*********************************************************************************************************/

void SDL_ECC_BUS_SAFETY_DSS_getEDMAParameters(uint32_t busSftyNode , uint32_t *dmaCh, uint32_t *tcc,uint32_t *param, uint32_t *queNum, uint32_t *edmaNum )
{
    switch (busSftyNode)
    {
        /* DSS TPTC A0 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_A0_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
        /* DSS TPTC A1 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_A1_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *queNum = 1U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
        /* DSS TPTC B0 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_B0_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_B_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_B_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_B_EVT_HWA_DMA_REQ0;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA1;
            break;
        }
        /* DSS TPTC B1 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_B1_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_B_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_B_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_B_EVT_HWA_DMA_REQ0;
            *queNum = 1U;
            *edmaNum = CONFIG_EDMA1;
            break;
        }
        /* DSS TPTC C0 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_C0_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA2;
            break;
        }
        /* DSS TPTC C1 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_C1_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *queNum = 1U;
            *edmaNum = CONFIG_EDMA2;
            break;
        }
        /* DSS TPTC C2 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_C2_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *queNum = 2U;
            *edmaNum = CONFIG_EDMA2;
            break;
        }
        /* DSS TPTC C3 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_C3_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *queNum = 3U;
            *edmaNum = CONFIG_EDMA2;
            break;
        }
        /* DSS TPTC C4 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_C4_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *queNum = 4U;
            *edmaNum = CONFIG_EDMA2;
            break;
        }
        /* DSS TPTC C5 RD */
        case SDL_ECC_BUS_SAFETY_DSS_TPTC_C5_RD :
        {
            *dmaCh = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_C_EVT_HWA_DMA_REQ0;
            *queNum = 5U;
            *edmaNum = CONFIG_EDMA2;
            break;
        }
        /* DSS PCR */
        case SDL_ECC_BUS_SAFETY_DSS_PCR :
        {
            *dmaCh = EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *tcc =   EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *param = EDMA_DSS_TPCC_A_EVT_HWA_DMA_REQ0;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA2;
            break;
        }
        default :
        {
            *dmaCh = EDMA_RESOURCE_ALLOC_ANY;
            *tcc =   EDMA_RESOURCE_ALLOC_ANY;
            *param = EDMA_RESOURCE_ALLOC_ANY;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
    }
}

#endif
#endif

#if defined (SOC_AM273X) || defined (SOC_AWR294X) || defined (SOC_AM263X)
#if defined (SUBSYS_MSS)
/********************************************************************************************************
*   Function to select the parameters for EDMA config according to Nodes
*********************************************************************************************************/

void SDL_ECC_BUS_SAFETY_MSS_getEDMAParameters(uint32_t busSftyNode , uint32_t *dmaCh, \
                                      uint32_t *tcc,uint32_t *param, uint32_t *queNum, uint32_t *edmaNum )
{
    switch (busSftyNode)
    {
      #if defined (SOC_AM273X) || defined (SOC_AWR294X)
        /* MSS TPTC A0 RD */
        case SDL_ECC_BUS_SAFETY_MSS_TPTC_A0_RD :
        {
            *dmaCh = EDMA_MSS_TPCC_A_EVT_FREE_0;
            *tcc =   EDMA_MSS_TPCC_A_EVT_FREE_0;
            *param = EDMA_MSS_TPCC_A_EVT_FREE_0;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
        /* MSS TPTC A1 RD */
        case SDL_ECC_BUS_SAFETY_MSS_TPTC_A1_RD :
        {
            *dmaCh = EDMA_MSS_TPCC_A_EVT_FREE_0;
            *tcc =   EDMA_MSS_TPCC_A_EVT_FREE_0;
            *param = EDMA_MSS_TPCC_A_EVT_FREE_0;
            *queNum = 1U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
        /* MSS TPTC B0 RD */
        case SDL_ECC_BUS_SAFETY_MSS_TPTC_B0_RD :
        {
            *dmaCh = EDMA_MSS_TPCC_B_EVT_FREE_0;
            *tcc =   EDMA_MSS_TPCC_B_EVT_FREE_0;
            *param = EDMA_MSS_TPCC_B_EVT_FREE_0;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA1;
            break;
        }
        /* MSS PCR */
        case SDL_ECC_BUS_SAFETY_MSS_PCR :
        {
            *dmaCh = EDMA_MSS_TPCC_A_EVT_FREE_0;
            *tcc =   EDMA_MSS_TPCC_A_EVT_FREE_0;
            *param = EDMA_MSS_TPCC_A_EVT_FREE_0;
            *queNum = 1U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
        /* MSS PCR2 */
        case SDL_ECC_BUS_SAFETY_MSS_PCR2 :
        {
            *dmaCh = EDMA_MSS_TPCC_A_EVT_FREE_0;
            *tcc =   EDMA_MSS_TPCC_A_EVT_FREE_0;
            *param = EDMA_MSS_TPCC_A_EVT_FREE_0;
            *queNum = 1U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
        #endif
        #if defined (SOC_AM263X)
        /* MSS TPTC A0 RD */
        case SDL_ECC_BUS_SAFETY_MSS_TPTC_A0_RD :
        {
            *dmaCh = EDMA_RESOURCE_ALLOC_ANY;
            *tcc =   EDMA_RESOURCE_ALLOC_ANY;
            *param = EDMA_RESOURCE_ALLOC_ANY;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
        /* MSS TPTC A1 RD */
        case SDL_ECC_BUS_SAFETY_MSS_TPTC_A1_RD :
        {
            *dmaCh = EDMA_RESOURCE_ALLOC_ANY;
            *tcc =   EDMA_RESOURCE_ALLOC_ANY;
            *param = EDMA_RESOURCE_ALLOC_ANY;
            *queNum = 1U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
        #endif
        default :
        {
            *dmaCh = EDMA_RESOURCE_ALLOC_ANY;
            *tcc =   EDMA_RESOURCE_ALLOC_ANY;
            *param = EDMA_RESOURCE_ALLOC_ANY;
            *queNum = 0U;
            *edmaNum = CONFIG_EDMA0;
            break;
        }
    }
}
#endif
#endif


/*
 *   In this test, EDMA transfer in A synchronized transfer is verified
 *   in polling mode.
 */

void test_edmaATransfer(uint32_t busSftyNode, uint32_t dmaCh, uint32_t tcc,uint32_t param, uint32_t queNum,\
                                                                       uint32_t edmaNum )
{
    uint32_t            loopCnt = 0;
    uint32_t            baseAddr, regionId;
    int32_t             testStatus = SystemP_SUCCESS;
    baseAddr = EDMA_getBaseAddr(gEdmaHandle[edmaNum]);
    DebugP_assert(baseAddr != 0);

    regionId = EDMA_getRegionId(gEdmaHandle[edmaNum]);
    DebugP_assert(regionId < SOC_EDMA_NUM_REGIONS);

    testStatus = EDMA_allocDmaChannel(gEdmaHandle[edmaNum], &dmaCh);
    DebugP_assert(testStatus == SystemP_SUCCESS);

    testStatus = EDMA_allocTcc(gEdmaHandle[edmaNum], &tcc);
    DebugP_assert(testStatus == SystemP_SUCCESS);

    testStatus = EDMA_allocParam(gEdmaHandle[edmaNum], &param);
    DebugP_assert(testStatus == SystemP_SUCCESS);

    /*
     * Initialize the source address with a pattern
     * initialize dst address with zero/another pattern (optional)
     */
    srcBuffPtr = (uint32_t *) gEdmaTestSrcBuff;
    dstBuffPtr = (uint32_t *) gEdmaTestDstBuff;
#if defined (SOC_AM273X) || defined (SOC_AWR294X)
#if defined (SUBSYS_MSS)
   if(busSftyNode == SDL_ECC_BUS_SAFETY_MSS_PCR)
   {
       dstBuffPtr = (uint32_t *) (SDL_MSS_CTRL_U_BASE);
       srcBuffPtr = (uint32_t *) (SDL_MSS_L2_U_BASE);
   }
   else if(busSftyNode == SDL_ECC_BUS_SAFETY_MSS_PCR2)
   {
       dstBuffPtr = (uint32_t *) (SDL_MSS_GPADC_REG_U_BASE);
       srcBuffPtr = (uint32_t *) (SDL_MSS_L2_U_BASE);
   }
   else
   {
       dstBuffPtr = (uint32_t *) gEdmaTestDstBuff;
   }
#endif
#endif
#if defined (SUBSYS_DSS)
   if( busSftyNode == SDL_ECC_BUS_SAFETY_DSS_PCR)
   {
       dstBuffPtr = (uint32_t *) (SDL_DSS_CTRL_U_BASE);
   }
   else
   {
       dstBuffPtr = (uint32_t *) gEdmaTestDstBuff;
   }
#endif
    /* Request channel */
    EDMA_configureChannelRegion(baseAddr, regionId, EDMA_CHANNEL_TYPE_DMA,
         dmaCh, tcc, param, queNum);

    /* Disable the interrupt for the channel to transfer in polled mode */
    EDMA_disableEvtIntrRegion(baseAddr, regionId, dmaCh);

    /* Program Param Set */
    EDMA_ccPaRAMEntry_init(&edmaParam1);
    edmaParam1.srcAddr       = (uint32_t) SOC_virtToPhy(srcBuffPtr);
    edmaParam1.destAddr      = (uint32_t) SOC_virtToPhy(dstBuffPtr);
    edmaParam1.aCnt          = (uint16_t) EDMA_TEST_A_COUNT;
    edmaParam1.bCnt          = (uint16_t) EDMA_TEST_B_COUNT;
    edmaParam1.cCnt          = (uint16_t) EDMA_TEST_C_COUNT;
    edmaParam1.bCntReload    = (uint16_t) EDMA_TEST_B_COUNT;
    edmaParam1.srcBIdx       = (int16_t) EDMA_TEST_A_COUNT;
    edmaParam1.destBIdx      = (int16_t) EDMA_TEST_A_COUNT;
    edmaParam1.srcCIdx       = (int16_t) EDMA_TEST_A_COUNT;
    edmaParam1.destCIdx      = (int16_t) EDMA_TEST_A_COUNT;
    edmaParam1.linkAddr      = 0xFFFFU;
    edmaParam1.opt          |=
        (EDMA_OPT_TCINTEN_MASK | EDMA_OPT_ITCINTEN_MASK |
         ((((uint32_t)tcc) << EDMA_OPT_TCC_SHIFT) & EDMA_OPT_TCC_MASK));
    EDMA_setPaRAM(baseAddr, param, &edmaParam1);
    /*
     * Transfer is done in A sync mode
     * Number of triggers required are B_COUNT * C_COUNT
     */
    for(loopCnt = 0; loopCnt < (EDMA_TEST_B_COUNT * EDMA_TEST_C_COUNT); loopCnt++)
    {
        EDMA_enableTransferRegion(baseAddr, regionId, dmaCh,
             EDMA_TRIG_MODE_MANUAL);
        EDMA_clrIntrRegion(baseAddr, regionId, tcc);
    }
    /* Free channel */
    EDMA_freeChannelRegion(baseAddr, regionId, EDMA_CHANNEL_TYPE_DMA,
         dmaCh, EDMA_TRIG_MODE_MANUAL, tcc, queNum);

    /* Free the EDMA resources managed by driver. */
    testStatus = EDMA_freeDmaChannel(gEdmaHandle[edmaNum], &dmaCh);
    DebugP_assert(testStatus == SystemP_SUCCESS);
    testStatus = EDMA_freeTcc(gEdmaHandle[edmaNum], &tcc);
    DebugP_assert(testStatus == SystemP_SUCCESS);
    testStatus = EDMA_freeParam(gEdmaHandle[edmaNum], &param);
    DebugP_assert(testStatus == SystemP_SUCCESS);

}


#if defined (SOC_AM273X) ||  defined(SOC_AWR294X)
#if defined (SUBSYS_MSS)

/*Register/Memory Read/Write Functions */
void reg_write_32(UWORD32 addr,UWORD32 write_data)
{
  (*(UWORD32 volatile *) (addr)) = write_data;
}

void reg_writes(UWORD32 wdth, UWORD32 addrs, UWORD32 wr_data)
{
   reg_write_32(addrs, wr_data);
}

void test_mem_write(UWORD32 strt_addr, unsigned char* ptr, UWORD32 sz)
{
  int i;
  UWORD32* write_data;
  write_data = (UWORD32*)ptr;
  for(i=0; i<(sz/4); i++) {
    reg_writes(32,(strt_addr+(i * 4)), write_data[i]);
  }
}

void cpsw_transfer()
{
  /*WRITE TO HDPs*/
  HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_FH0_HDP, NON_CPU_TX_BUFFER_DESC);
  HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_TH0_HDP, NON_CPU_RX_BUFFER_DESC);
}


void setup_CPSW()
{
    /* HELPERS */
    unsigned int i, j;

    /*ENABLE CPSW_SS SS_C0_FH_En and SS_C0_TH_En INTERRUPT REGISTER */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + 0x84, 0x1);
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + 0x88, 0x1);

    /*ENABLE STATISTIC FOR PORT 0 AND 1. */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_Stat_Port_En, 0xF);

    /* CPSW CONTROL REG SETUP : SETUP MAX PACKET LENGTH ON INGRESS PACKET ON CPPI, AND CRC TYPE, CRC DROP AND SHORT PACKET HANDLING ON THOST PACKETS TO CPPI. ALSO ENABLE CPPI PORT
    CPPI Port 0 Ingress Maximum Frame Length : This field determines the maximum length of a received frame.  The reset value is 1518, we have updated it to 2020.
    Frames with larger than this bytecount is long frames (LGF) (LGF with no errors are Oversized Frames, LGF with errors are called Jabber Frames) */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPPI_P0_Rx_Maxlen, 2020);
    /* bit 2  : CPSW_CONTROL REG > P0 ENABLE > CPPI port (port 0) packet operations are enabled
    bit 12 : p0_tx_crc_type   > Port 0 Transmit CRC type  > The type of CRC on all Port 0 THost packets >>   0 : Ethernet CRC on Port 0 THost
    bit 13 : p0_tx_crc_remove > Port 0 Transmit CRC remove >>                                                1 : Remove the CRC on all Port 0 THost packets.
    bit 14 : p0_rx_pad        > Port 0 FHost Short Packet Pad  >>                                            0 : short packets are dropped. */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_Control, 0x02004);

    /* ALE_CONTROL REG : Clear ALE address table : bit 30 - Setting this bit causes the ALE hardware to write all table bit values to zero. Software must perform a clear table operation as part of the ALE setup/configuration process. Setting this bit causes all
      ALE accesses to be held up for 64 clocks while the clear is performed. Access to all ALE registers will be blocked (wait states) until the 64 clocks have completed.*/
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ALE_BASE + ALE_CONTROL, 0x40000000);

    /* ALE_CONTROL REG : ENABLE_ALE : bit 31 > 1 >> Enable ALE packet processing, Also enabled ALE_BYPASS */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ALE_BASE + ALE_CONTROL, 0x80000010);

    /*  ALE PORT STATE REGISTER WRITE : P0_PORTSTATE : bit [1:0] >> Defins the current port state used for lookup operations. Set to 3 (Forwarding) */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ALE_BASE + ALE_PORTCTL,   0x3);
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ALE_BASE + ALE_PORTCTL+0x4, 0x3);
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ALE_BASE + ALE_PORTCTL+0x8, 0x3);

    /* Enet_Pn_Mac_Soft_Reset   > pn_soft_reset > Software reset � Writing a one to this bit causes the Ethernet Mac logic to be reset.  After writing a one to this bit, it may be polled to determine if the reset has occurred.  If a one is read, the reset has not yet occurred*/
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ENET_BASE + Enet_Pn_Mac_Soft_Reset, 0x1);
    while(HW_RD_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ENET_BASE + Enet_Pn_Mac_Soft_Reset) == 1);

    /*Enet_Pn_Mac_Control Reg bit 5 > pn_gmii_en > 1 >> GMII RX and TX released from reset. */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ENET_BASE + Enet_Pn_Mac_Control, 0x20);

    /* Enet_Pn_Mac_Control REG Configs
     Enet_Pn_Mac_Control bit 5  : pn_gmii_en > 1 >> GMII RX and TX released from reset.
     Enet_Pn_Mac_Control bit 24 : pn_rx_cmf_en > RX Copy MAC Control Frames Enable  > 0 >> MAC control frames are filtered (but acted upon if enabled).
     Enet_Pn_Mac_Control bit 23 : pn_rx_csf_en > RX Copy Short Frames Enable        > 0 >> Short frames are filtered
     Enet_Pn_Mac_Control bit 22 : pn_rx_cef_en > RX Copy Error Frames Enable        > 0 >> Frames containing errors are filter
     Enet_Pn_Mac_Control bit 0  : pn_fullduplex > Full Duplex mode                  > 1 >> full duplex mode set
     Enet_Pn_Mac_Control bit 4  : pn_tx_flow_en > Transmit Flow Control Enable      > 0 >> Transmit Flow Control Disabled.  Full-duplex mode � Incoming pause frames are not acted upon.
     Enet_Pn_Mac_Control bit 3  : pn_rr_flow_en > Receive Flow Control Enable       > 0 >> Receive  Flow Control Disabled.  Full-duplex mode � No outgoing pause frames are sent.
     Enet_Pn_Mac_Control bit 10 : pn_tx_short_gap_en > Transmit Short Gap Enable    > 1 >> Transmit with a short IPG (when TX_SHORT_GAP input is asserted) is enabled
     Enet_Pn_Mac_Control bit 12 : pn_crc_type   >  Port CRC Type   > 0 >> Ethernet CRC
     Enet_Pn_Mac_Control bit 1  : pn_loopback   >  Loop Back Mode  > 0 >> Not loop back mode : // FIXME : CHECK IF THIS CAN BE WRITTEN ALONG WITH pn_gmii_en. Loopback mode forces internal fullduplex mode regardless of whether the pn_fullduplex bit is set or not.
     Enet_Pn_Mac_Control bit 8  : pn_xgig >  10 Gigabit Mode > 0 - 10/100/1G mode as determined by pn_gig
     Enet_Pn_Mac_Control bit 7  : pn_gig  >  1  Gigabit Mode > 0 - 10/100 mode
     Enet_Pn_Mac_Control bit 5  : pn_gmii_en > 1 >> GMII RX and TX released from reset.
     Enet_Pn_Mac_Control bit 13 : pn_xgmii_en > 0 >> 0 � XGMII RX and TX held in reset. */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ENET_BASE + Enet_Pn_Mac_Control, 0x421);
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPSW_ENET_BASE + Enet_Pn_Rx_Maxlen, 0x2020);

    /*WAIT for cprgmii_tx.pkt_en to go high. Downcounter cprgmii_tx.cnt should reset to 0 from 0xFFF and only then pkt_en will go high and any transmit packet is accepted */
    for(j = 0; j <= 0x100; j++) {}
    /*(0x01008) >> p0_flow_id_offset > This value adds to the transmit (egress) FLOW ID.  This register is unused and should remain at the default 0x00. */
     HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + 0x1008, 0x3FFF);

    /*---------------------------------------------------------------------------
    We are ready to go
    ---------------------------------------------------------------------------
    SETUP CPDMA
    ZERO OUT CPDMA HDPs*/
   for (i=0;i<8;i++)
    {
        HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_TH0_HDP + (i*4), 0x00000000);
    }
    for (i=0;i<8;i++)
    {
        HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_FH0_HDP + (i*4), 0x00000000);
    }

    /*Fill Transmit Data Buffer */
    test_mem_write((MEMORY_TX_BUFFER+0x0000), TxBufferData0, sizeof(TxBufferData0));

    /* Tx CPPI descriptors */
    test_mem_write(TX_BUFFER_DESC, CppiTxPkt0, 16);
    /* Rx CPPI descriptors */
    test_mem_write(RX_BUFFER_DESC, CppiRxPkt0, 16);

    /*CPDMA_TH_IntMask_Set > bit 0 > thost0_pend_mask > THost Channel 0 Pending Int Mask Write one to enable Int. */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_TH_IntMask_Set, 0x00000001);

    /*CPDMA_TH_Buffer_Offset > 0 >  The fhost_buffer_offset will be written by the port into each frame SOP buffer descriptor buffer_offset field.*/
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_TH_Buffer_Offset, 0x0);

    /*CPDMA_FH_IntMask_Set > bit 0 > FHost Channel 0 Mask � Write one to enable interrupt.*/
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_FH_IntMask_Set, 0x00000001);
    /*CPDMA_FH_Control > bit 0 >  1 - FHost Enabled */
    HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_FH_Control, 0x00000001);
    /*CPDMA_TH_Control > bit 0 >  1 - THost DMA Enabled */
  HW_WR_REG32_RAW(CSL_MSS_CPSW_U_BASE + CPSW_NC_BASE + CPDMA_TH_Control, 0x00000001);
}

#endif
#endif



/* ==========================================================================
 * $File: //dwh/usb_iip/dev/software/DWC_usb3/driver/pcd.c $
 * $Revision: #105 $
 * $Date: 2014/01/15 $
 * $Change: 2410328 $
 *
 * Synopsys SS USB3 Linux Software Driver and documentation (hereinafter,
 * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
 * otherwise expressly agreed to in writing between Synopsys and you.
 *
 * The Software IS NOT an item of Licensed Software or Licensed Product under
 * any End User Software License Agreement or Agreement for Licensed Product
 * with Synopsys or any supplement thereto. You are permitted to use and
 * redistribute this Software in source and binary forms, with or without
 * modification, provided that redistributions of source code must retain this
 * notice. You may not view, use, disclose, copy or distribute this file or
 * any information contained herein except pursuant to this license grant from
 * Synopsys. If you do not agree with this notice, including the disclaimer
 * below, then you are not authorized to use the Software.
 *
 * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 * ========================================================================== */

/** @file
 * This file implements the Peripheral Controller Driver.
 *
 * The Peripheral Controller Driver (PCD) is responsible for translating
 * requests from the Function Driver into the appropriate actions on the
 * DWC_usb3 controller. It isolates the Function Driver from the specifics
 * of the controller by providing an API to the Function Driver.
 *
 * The Peripheral Controller Driver for Linux will implement the Gadget API,
 * so that the existing Gadget drivers can be used. (Gadget Driver is the
 * Linux terminology for a Function Driver.)
 *
 * The Linux Gadget API is defined in the header file
 * <code><linux/usb/gadget.h></code>. The USB EP operations API is defined
 * in the structure <code>usb_ep_ops</code> and the USB Controller API is
 * defined in the structure <code>usb_gadget_ops</code>.
 *
 * An important function of the PCD is managing interrupts generated by the
 * DWC_usb3 controller. The implementation of the DWC_usb3 device mode
 * interrupt service routines is in pcd_intr.c.
 */
/*
 * todo  Add Device Mode test modes (Test J mode, Test K mode, etc).
 */

#include "../include/os_defs.h"
#include "../include/hw.h"
#include "../include/usb.h"
#include "../include/pcd.h"
#include "../include/dev.h"
#include "../include/os_dev.h"
#include "../include/cil.h"

#ifdef DWC_UTE
# include "ute_if.h"
#endif

/**********************************************************************
 *************************** Local Functions **************************
 **********************************************************************/
static void dwc_usb3_stop_xfer(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep);
static int dwc_usb3_ep_complete_request(dwc_usb3_pcd_t *pcd,dwc_usb3_pcd_ep_t *ep,dwc_usb3_pcd_req_t *req, u32 event);
static void ep_deactivate(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep);
static void pcd_epinit(dwc_usb3_pcd_t *pcd);
/**
 * This routine allocates the TRBs for an EP.
 *
 * @param ep            The EP for the allocation.
 * @param num_trbs      Number of TRBs to allocate.
 * @param trb_type      Type of the TRB.
 * @param iso_intvl     bInterval if this is an Isoc EP.
 * @param link          True if the TRBs should be linked in a circular chain
 *                      (only supported for Isoc EPs for now).
 * @param trbs_dma_ret  The DMA address of the allocation is returned through
 *                      this pointer.
 * @return              The address of the allocated memory, or NULL if the
 *                      allocation fails.
 */
dwc_usb3_dma_desc_t *dwc_usb3_pcd_trb_alloc(dwc_usb3_pcd_ep_t *ep, int num_trbs,
		uByte trb_type, int iso_intvl, int link, dwc_dma_t *trbs_dma_ret)
{
	dwc_usb3_dma_desc_t *trbs, *cur_trb;
	dwc_dma_t trbs_dma;
	int size, i;
#ifdef DWC_TEST_ISOC_CHAIN
	int j;
#endif

#ifdef DWC_TEST_ISOC_CHAIN
	size = num_trbs * 3 * 16;
	if (link)
		size += 16 * 3;
#else
	size = num_trbs * 16;
	if (link > 0) {
		size += 16;
	}
#endif

	trbs = cur_trb = dwc_usb3_gadget_alloc_dma(ep, size, &trbs_dma);
	if (!trbs) {
		return NULL;
	}

	/* Now initialize the TRBs */
	for (i = 0; i < num_trbs; i++, cur_trb++) {
		if (trb_type == UE_ISOCHRONOUS) {
#ifdef DWC_ISOC_INTR_MODERATION
			/*
			 * For small intervals, only set the IOC bit in every
			 * 8th TRB, for interrupt moderation purposes
			 */
			if (iso_intvl > 3 || (i & 7) == 7 || i == num_trbs - 1)
#endif
				dwc_usb3_fill_desc(cur_trb, 0, 0, 0,
						   DWC_DSCCTL_TRBCTL_ISOC_1ST,
						   DWC_DSCCTL_IOC_BIT |
						   DWC_DSCCTL_IMI_BIT |
						   DWC_DSCCTL_CSP_BIT, 0);
#ifdef DWC_ISOC_INTR_MODERATION
			else
				dwc_usb3_fill_desc(cur_trb, 0, 0, 0,
						   DWC_DSCCTL_TRBCTL_ISOC_1ST,
						   DWC_DSCCTL_IMI_BIT |
						   DWC_DSCCTL_CSP_BIT, 0);
#endif
#ifdef DWC_TEST_ISOC_CHAIN
			/* Add 2 more TRBs per entry, chain them to the 1st */
			dwc_usb3_start_desc_chain(cur_trb);
			cur_trb++;

			for (j = 0; j < 2; j++, cur_trb++)
				dwc_usb3_fill_desc(cur_trb, 0, 0, 0,
						   DWC_DSCCTL_TRBCTL_ISOC,
						   DWC_DSCCTL_IMI_BIT |
						   DWC_DSCCTL_CSP_BIT |
						   DWC_DSCCTL_CHN_BIT, 0);
			cur_trb--;
			dwc_usb3_end_desc_chain(cur_trb);
#endif
		}

		/* For types other than Isoc, the TRBs are initialized just
		 * before the transfer is started.
		 */
	}

	if (link > 0) {
		dwc_usb3_fill_desc(cur_trb, trbs_dma, 0, 0,
				   DWC_DSCCTL_TRBCTL_LINK, 0, 1);
	}

	/* Init the pcd_ep structure */
	ep->dwc_ep.dma_desc = trbs;
	ep->dwc_ep.dma_desc_dma = trbs_dma;
	ep->dwc_ep.desc_size = size;
	ep->dwc_ep.desc_link = link;
	ep->dwc_ep.num_desc = num_trbs;
	ep->dwc_ep.desc_avail = num_trbs;
	ep->dwc_ep.desc_idx = 0;
	ep->dwc_ep.hiber_desc_idx = 0;

	*trbs_dma_ret = trbs_dma;
	return trbs;
}

/**
 * This routine frees the TRBs allocated by dwc_usb3_pcd_trb_alloc().
 *
 * @param ep    The EP for the allocation.
 */
void dwc_usb3_pcd_trb_free(dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dma_desc_t *trbs;
	dwc_dma_t trbs_dma;
	int size;

	if (ep->dwc_ep.dma_desc != NULL) {
		trbs = ep->dwc_ep.dma_desc;
		trbs_dma = ep->dwc_ep.dma_desc_dma;
		size = ep->dwc_ep.desc_size;
		ep->dwc_ep.dma_desc = NULL;
		ep->dwc_ep.dma_desc_dma = 0;

		dwc_usb3_gadget_free_dma(ep, size, trbs, trbs_dma);
	}
}

/**
 * This routine assigns and fills in the TRBs for a request.
 *
 * @param pcd   Programming view of DWC_usb3 peripheral controller.
 * @param ep    The EP for the transfer.
 * @param req   The request that needs the TRBs.
 */
void dwc_usb3_pcd_fill_trbs(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			    dwc_usb3_pcd_req_t *req)
{
	dwc_usb3_dma_desc_t *desc;
	dwc_dma_t desc_dma;
	u32 len, tlen, pkts, ctrl;
	int i;

	if (ep == pcd->ep0) {
		return;
	}

	/* Get the next DMA Descriptor (TRB) for this EP */
	desc = ep->dwc_ep.dma_desc + ep->dwc_ep.desc_idx * req->dwc_req.numbuf;
	desc_dma = (dwc_dma_t)((unsigned long)ep->dwc_ep.dma_desc_dma +
		(unsigned long)ep->dwc_ep.desc_idx * (unsigned long)req->dwc_req.numbuf * 16U);

	if (++ep->dwc_ep.desc_idx >= ep->dwc_ep.num_desc) {
		ep->dwc_ep.desc_idx = 0;
	}
	ep->dwc_ep.desc_avail--;

	req->dwc_req.trb = desc;
	req->dwc_req.trbdma = desc_dma;

	pkts = 0;

	if (ep->dwc_ep.is_in > 0U) {
		/* For IN, TRB length is just xfer length */
		len = req->dwc_req.length;

		if (ep->dwc_ep.type == UE_ISOCHRONOUS &&
				pcd->speed == USB_SPEED_HIGH) {
			pkts = (len + ep->dwc_ep.maxpacket - 1U)
					/ ep->dwc_ep.maxpacket;
			if (pkts > 0U) {
				pkts--;
			}
		}
	} else {
		/* For OUT, TRB length must be multiple of maxpacket */
		if ((ep->dwc_ep.type == UE_ISOCHRONOUS ||
				ep->dwc_ep.type == UE_INTERRUPT) &&
						ep->dwc_ep.maxpacket != 1024U) {
			/* Might not be power of 2, so use (expensive?)
			 * divide/multiply
			 */
			len = ((req->dwc_req.length + ep->dwc_ep.maxpacket - 1U)
			       / ep->dwc_ep.maxpacket) * ep->dwc_ep.maxpacket;
        }
		else {
			/* Must be power of 2, use cheap AND */
			len = (req->dwc_req.length + ep->dwc_ep.maxpacket - 1U)
			      & ~(ep->dwc_ep.maxpacket - 1U);
		}

		req->dwc_req.length = len;
	}

	/* DMA Descriptor Setup */
	for (i = 0; i < req->dwc_req.numbuf; i++, desc++) {
		if (ep->dwc_ep.type == UE_ISOCHRONOUS) {
			if (i != req->dwc_req.numbuf - 1) {
				tlen = req->dwc_req.buflen[i];
				len -= tlen;
			} else {
				tlen = len;
			}

			if (i == 0) {
				tlen |= pkts << DWC_DSCSTS_PCM1_SHIFT;
			}

			dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[i], tlen,
					   0, 0, 0, i != 0);
		} else {
			if (i != req->dwc_req.numbuf - 1) {
				ctrl = 0;
				tlen = req->dwc_req.buflen[i];
				len -= tlen;
			} else {
				ctrl = DWC_DSCCTL_LST_BIT;
				tlen = len;
			}

			dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[i], tlen,
					   req->dwc_req.stream,
					   DWC_DSCCTL_TRBCTL_NORMAL, ctrl,
					   i != 0);
		}
	}

	/* Must do this last! */
	desc = req->dwc_req.trb;
	dwc_usb3_enable_desc(desc);
}

/**
 * This routine configures EP0 OUT to receive SETUP packets and configures
 * EP0 IN for transmitting packets.
 *
 * @param pcd           Programming view of DWC_usb3 peripheral controller.
 * @param restore       True if restoring endpoint state after hibernation.
 */
void dwc_usb3_ep0_activate(dwc_usb3_pcd_t *pcd, int restore)
{
	u32 diepcfg0, doepcfg0, diepcfg1, doepcfg1;
	u32 diepcfg2 = 0, doepcfg2 = 0;
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;

	dwc_debug1(pcd->usb3_dev, "%s()\n", __func__);

	diepcfg0 = DWC_USB3_EP_TYPE_CONTROL << DWC_EPCFG0_EPTYPE_SHIFT;
	diepcfg1 = DWC_EPCFG1_XFER_CMPL_BIT | DWC_EPCFG1_XFER_IN_PROG_BIT |
		   DWC_EPCFG1_XFER_NRDY_BIT | DWC_EPCFG1_EP_DIR_BIT;

	doepcfg0 = DWC_USB3_EP_TYPE_CONTROL << DWC_EPCFG0_EPTYPE_SHIFT;
	doepcfg1 = DWC_EPCFG1_XFER_CMPL_BIT | DWC_EPCFG1_XFER_IN_PROG_BIT |
		   DWC_EPCFG1_XFER_NRDY_BIT;

	/* Default to MPS of 512 (will reconfigure after ConnectDone event) */
	diepcfg0 |= 512U << DWC_EPCFG0_MPS_SHIFT;
	doepcfg0 |= 512U << DWC_EPCFG0_MPS_SHIFT;

#ifdef DWC_UTE
	pcd->ep0->dwc_ep.tx_fifo_num = pcd->txf_map[1];
#endif
	diepcfg0 |= pcd->ep0->dwc_ep.tx_fifo_num << DWC_EPCFG0_TXFNUM_SHIFT;

	if (restore > 0) {
		diepcfg0 |= DWC_CFG_ACTION_RESTORE
					<< DWC_EPCFG0_CFG_ACTION_SHIFT;
		diepcfg2 = pcd->ep0_in_save_state;
		dwc_debug1(pcd->usb3_dev, "IN restore state=%08x\n", diepcfg2);
		doepcfg0 |= DWC_CFG_ACTION_RESTORE
					<< DWC_EPCFG0_CFG_ACTION_SHIFT;
		doepcfg2 = pcd->ep0_out_save_state;
		dwc_debug1(pcd->usb3_dev, "OUT restore state=%08x\n", doepcfg2);
	}

	/*
	 * Issue "DEPCFG" command to EP0-OUT
	 */

	ep_reg = &pcd->out_ep_regs[0];
	dwc_usb3_dis_usb2_phy_suspend(pcd);

	/* If core is version 1.09a or later */
	if ((pcd->usb3_dev->snpsid & 0xffffU) >= 0x109aU) {
		/* Must issue DEPSTRTNEWCFG command first */
		dwc_usb3_dep_startnewcfg(pcd, ep_reg, 0);
	}

	dwc_usb3_dep_cfg(pcd, ep_reg, doepcfg0, doepcfg1, doepcfg2);

	/*
	 * Issue "DEPSTRMCFG" command to EP0-OUT
	 */

	/* One stream */
	dwc_usb3_dep_xfercfg(pcd, ep_reg, 1);

	/*
	 * Issue "DEPCFG" command to EP0-IN
	 */

	ep_reg = &pcd->in_ep_regs[0];
	dwc_usb3_dep_cfg(pcd, ep_reg, diepcfg0, diepcfg1, diepcfg2);

	/*
	 * Issue "DEPSTRMCFG" command to EP0-IN
	 */

	/* One stream */
	dwc_usb3_dep_xfercfg(pcd, ep_reg, 1);

	dwc_usb3_ena_usb2_phy_suspend(pcd);
	pcd->ep0->dwc_ep.active = 1;
}

/**
 * This routine activates an EP. The Device EP control registers for the EP
 * are configured as defined in the EP structure.
 *
 * @param pcd           Programming view of DWC_usb3 peripheral controller.
 * @param ep            The EP to activate.
 * @param restore       True if restoring endpoint state after hibernation.
 */
void dwc_usb3_ep_activate(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			  int restore)
{
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg, *ep0_reg;
	u32 depcfg0, depcfg1, depcfg2 = 0;

	dwc_debug3(pcd->usb3_dev, "%s() EP%d-%s\n", __func__, ep->dwc_ep.num,
		   (ep->dwc_ep.is_in ? "IN" : "OUT"));

	ep->dwc_ep.hiber_desc_idx = 0;

#ifdef DWC_STAR_9000463548_WORKAROUND
	if (pcd->configuring)
		goto skip;
#endif
	/*
	 * Get the appropriate EP registers
	 */
	if (ep->dwc_ep.is_in > 0U) {
		ep_reg = ep->dwc_ep.in_ep_reg;
	}
    else {
		ep_reg = ep->dwc_ep.out_ep_reg;
	}

	dwc_usb3_dis_usb2_phy_suspend(pcd);

	/* If this is first EP enable (ie. start of a new configuration) */
	if (pcd->eps_enabled == 0U) {

#ifdef DWC_STAR_9000463548_WORKAROUND
		dwc_usb3_dev_ep_regs_t __iomem *eptmp_reg;
		dwc_usb3_pcd_ep_t *eptmp;
		int i;

		/* For the workaround, we must wait for all EndXfers on all EPs
		 * to complete before continuing
		 */
		for (i = 0; i < pcd->num_in_eps; i++) {
			eptmp = pcd->in_ep[i];
			dwc_print3(pcd->usb3_dev, "DWC IN EP%d=%lx tri-in=%d\n",
				   i, (unsigned long)eptmp, eptmp->dwc_ep.tri_in);
			if (eptmp->dwc_ep.tri_in) {
				eptmp_reg = eptmp->dwc_ep.in_ep_reg;
				eptmp->dwc_ep.condition = 0;
				dwc_usb3_dep_wait_endxfer(pcd, eptmp_reg,
						&eptmp->dwc_ep.condition);
				eptmp->dwc_ep.tri_in = 0;
			}
		}

		for (i = 0; i < pcd->num_out_eps; i++) {
			eptmp = pcd->out_ep[i];
			dwc_print3(pcd->usb3_dev,
				   "DWC OUT EP%d=%lx tri-out=%d\n",
				   i, (unsigned long)eptmp, eptmp->dwc_ep.tri_out);
			if (eptmp->dwc_ep.tri_out) {
				eptmp_reg = eptmp->dwc_ep.out_ep_reg;
				eptmp->dwc_ep.condition = 0;
				dwc_usb3_dep_wait_endxfer(pcd, eptmp_reg,
						&eptmp->dwc_ep.condition);
				eptmp->dwc_ep.tri_out = 0;
			}
		}
#endif
		pcd->eps_enabled = 1;

		/* NOTE: When setting a new configuration, we must issue a
		 * "DEPCFG" command to physical EP1 (logical EP0-IN) first.
		 * This resets the core's Tx FIFO mapping table
		 */
		depcfg0 = DWC_USB3_EP_TYPE_CONTROL << DWC_EPCFG0_EPTYPE_SHIFT;
		depcfg0 |= DWC_CFG_ACTION_MODIFY << DWC_EPCFG0_CFG_ACTION_SHIFT;
		depcfg1 = DWC_EPCFG1_XFER_CMPL_BIT | DWC_EPCFG1_XFER_IN_PROG_BIT
			| DWC_EPCFG1_XFER_NRDY_BIT | DWC_EPCFG1_EP_DIR_BIT;

		switch (pcd->speed) {
		case USB_SPEED_SUPER:
			depcfg0 |= 512U << DWC_EPCFG0_MPS_SHIFT;
			break;

		case USB_SPEED_HIGH:
		case USB_SPEED_FULL:
			depcfg0 |= 64U << DWC_EPCFG0_MPS_SHIFT;
			break;

		case USB_SPEED_LOW:
			depcfg0 |= 8U << DWC_EPCFG0_MPS_SHIFT;
			break;
		default :
			// do nothing
			break;
		}

		ep0_reg = &pcd->in_ep_regs[0];
		dwc_usb3_dep_cfg(pcd, ep0_reg, depcfg0, depcfg1, 0);

		/* If core is version 1.09a or later */
		if ((pcd->usb3_dev->snpsid & 0xffffU) >= 0x109aU) {
			/* Must issue DEPSTRTNEWCFG command first */
			ep0_reg = &pcd->out_ep_regs[0];
			dwc_usb3_dep_startnewcfg(pcd, ep0_reg, 2);
		}
	}

	/*
	 * Issue "DEPCFG" command to EP
	 */
	depcfg0 = (u32)ep->dwc_ep.type << DWC_EPCFG0_EPTYPE_SHIFT;
	depcfg0 |= ep->dwc_ep.maxpacket << DWC_EPCFG0_MPS_SHIFT;

	if (ep->dwc_ep.is_in > 0U) {
#ifdef DWC_UTE
		ep->dwc_ep.tx_fifo_num = pcd->txf_map[ep->dwc_ep.phys];
#endif
		depcfg0 |= ep->dwc_ep.tx_fifo_num << DWC_EPCFG0_TXFNUM_SHIFT;
	}

	if (pcd->usb3_dev->core_params->burst > 0) {
		dwc_debug1(pcd->usb3_dev, "Setting maxburst to %u\n",
			   ep->dwc_ep.maxburst);
		depcfg0 |= ep->dwc_ep.maxburst << DWC_EPCFG0_BRSTSIZ_SHIFT;
	}

	if (restore > 0) {
		depcfg0 |= DWC_CFG_ACTION_RESTORE
					<< DWC_EPCFG0_CFG_ACTION_SHIFT;
		depcfg2 = ep->dwc_ep.save_state;
	}

	depcfg1 = (u32)ep->dwc_ep.num << DWC_EPCFG1_EP_NUM_SHIFT;
	if (ep->dwc_ep.is_in > 0U) {
		depcfg1 |= DWC_EPCFG1_EP_DIR_BIT;
	}

	depcfg1 |= DWC_EPCFG1_XFER_CMPL_BIT;
	depcfg1 |= DWC_EPCFG1_XFER_IN_PROG_BIT;
	depcfg1 |= DWC_EPCFG1_XFER_NRDY_BIT;
	dwc_isocdbg1(pcd->usb3_dev, "Setting bInterval-1 to %u\n",
		     ep->dwc_ep.intvl);
	depcfg1 |= ep->dwc_ep.intvl << DWC_EPCFG1_BINTERVAL_SHIFT;

	if (ep->dwc_ep.num_streams > 0U) {
		dwc_debug0(pcd->usb3_dev, "Setting stream-capable bit\n");
		depcfg1 |= DWC_EPCFG1_STRM_CAP_BIT;
	}

	/* Save the DEPCFG parameters for later */
	if (ep->dwc_ep.is_in > 0U) {
		ep->dwc_ep.param0in = depcfg0 & ~(uint32_t)(DWC_EPCFG0_CFG_ACTION_BITS);
		ep->dwc_ep.param1in = depcfg1;
	} else {
		ep->dwc_ep.param0out = depcfg0 & ~(uint32_t)(DWC_EPCFG0_CFG_ACTION_BITS);
		ep->dwc_ep.param1out = depcfg1;
	}

	dwc_usb3_dep_cfg(pcd, ep_reg, depcfg0, depcfg1, depcfg2);

	/*
	 * Issue "DEPSTRMCFG" command to EP
	 */

	/* If this EP hasn't been enabled yet in this configuration */
	if (ep->dwc_ep.ena_once == 0U) {
		ep->dwc_ep.ena_once = 1;

		/* One stream */
		dwc_debug0(pcd->usb3_dev, "Setting 1 stream resource\n");
		dwc_usb3_dep_xfercfg(pcd, ep_reg, 1);
	}

	dwc_usb3_ena_usb2_phy_suspend(pcd);

#ifdef DWC_STAR_9000463548_WORKAROUND
skip:
#endif
	/* Enable EP in DALEPENA reg */
	dwc_usb3_enable_ep(pcd, ep);

	ep->dwc_ep.active = 1;
	ep->dwc_ep.stall_clear_flag = 0;
}

/**
 * This routine deactivates an EP.
 *
 * @param pcd   Programming view of DWC_usb3 peripheral controller.
 * @param ep    The EP to deactivate.
 */
static void ep_deactivate(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;
	u8 tri;

	dwc_debug3(pcd->usb3_dev, "%s() EP%d-%s\n", __func__, ep->dwc_ep.num,
		   (ep->dwc_ep.is_in ? "IN" : "OUT"));
	/*
	 * Get the appropriate EP registers
	 */
	if (ep->dwc_ep.is_in > 0U) {
		ep_reg = ep->dwc_ep.in_ep_reg;
		tri = ep->dwc_ep.tri_in;
		ep->dwc_ep.tri_in = 0;
	} else {
		ep_reg = ep->dwc_ep.out_ep_reg;
		tri = ep->dwc_ep.tri_out;
		ep->dwc_ep.tri_out = 0;
	}

	dwc_print2(pcd->usb3_dev, "end: DWC EP=%lx tri=%d\n",
		   (unsigned long)ep, tri);
	dwc_usb3_dis_usb2_phy_suspend(pcd);

	/* Execute clear stall command */
	dwc_usb3_dep_cstall(pcd, ep_reg, 0);

	if (tri > 0U) {
#ifdef DWC_STAR_9000463548_WORKAROUND
		/* For the workaround, we wait until the EP is re-enabled
		 * before waiting for the end transfer to complete
		 */
		dwc_usb3_dep_endxfer_nowait(pcd, ep_reg, tri - 1,
					    DWC_ENDXFER_FORCE);
		if (ep->dwc_ep.is_in > 0U)
			ep->dwc_ep.tri_in = tri;
		else
			ep->dwc_ep.tri_out = tri;
#else
		/* Execute end transfer command */
		ep->dwc_ep.condition = 0;
		dwc_usb3_dep_endxfer(pcd, ep_reg, (u32)tri - 1U, DWC_ENDXFER_FORCE,
				     &ep->dwc_ep.condition);
#endif
	}

	dwc_usb3_ena_usb2_phy_suspend(pcd);
	ep->dwc_ep.xfer_started = 0;

	/* Disable EP in DALEPENA reg */
	dwc_usb3_disable_ep(pcd, ep);

	ep->dwc_ep.active = 0;
}

/**
 * This routine sets up a SETUP stage transfer for EP0 and starts the transfer.
 *
 * @param pcd   Programming view of the PCD.
 */
void dwc_usb3_pcd_ep0_out_start(dwc_usb3_pcd_t *pcd)
{
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;
	dwc_usb3_dma_desc_t *desc;
	dwc_dma_t desc_dma;
	u8 tri;

	/* Get the SETUP packet DMA Descriptor (TRB) */
	desc = dwc_usb3_ep0_setup_desc(pcd);
	desc_dma = dwc_usb3_ep0_setup_desc_dma(pcd);

	/* DMA Descriptor setup */
	dwc_usb3_fill_desc(desc, dwc_usb3_ep0_setup_pkt_dma(pcd),
			   pcd->ep0->dwc_ep.maxpacket, 0,
			   DWC_DSCCTL_TRBCTL_SETUP, DWC_DSCCTL_LST_BIT, 1);
	dwc_debug5(pcd->usb3_dev,
		   "%s() desc=0x%08lx xfercnt=%u bptr=0x%08x:%08x\n",
		   __func__, (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
		   desc->bpth, desc->bptl);
#ifdef VERBOSE
	dwc_debug4(pcd->usb3_dev, "0x%08x 0x%08x 0x%08x 0x%08x\n",
		   *((unsigned *)desc), *((unsigned *)desc + 1),
		   *((unsigned *)desc + 2), *((unsigned *)desc + 3));
#endif

	ep_reg = &pcd->out_ep_regs[0];
	dwc_usb3_dis_usb2_phy_suspend(pcd);

	/* Issue "DEPSTRTXFER" command to EP0-OUT */
	wmb();
	tri = dwc_usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
	pcd->ep0->dwc_ep.tri_out = tri + 1U;

	dwc_usb3_ena_usb2_phy_suspend(pcd);
}

/**
 * This routine sets up a data/status stage transfer for EP0 and starts the
 * transfer. If pcd->ep0->dwc_ep.is_in is 0 it will be an OUT transfer,
 * otherwise it will be an IN transfer.
 *
 * @param pcd   Programming view of DWC_usb3 peripheral controller.
 * @param req   The request to start.
 */
void dwc_usb3_pcd_ep0_start_transfer(dwc_usb3_pcd_t *pcd,
				     dwc_usb3_pcd_req_t *req)
{
	dwc_usb3_pcd_ep_t *ep0 = pcd->ep0;
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;
	dwc_usb3_dma_desc_t *desc;
	dwc_dma_t desc_dma;
	u32 desc_type, len;
	u8 tri;

	dwc_debug7(pcd->usb3_dev,
		"%s(): ep%d-%s req=%lx xfer_len=%d xfer_cnt=%d xfer_buf=%lx\n",
		__func__, ep0->dwc_ep.num, (ep0->dwc_ep.is_in ? "IN" : "OUT"),
		(unsigned long)req, req->dwc_req.length, req->dwc_req.actual,
		(unsigned long)req->dwc_req.buf[0]);

	/* Get the DMA Descriptor (TRB) for this request */
	if (ep0->dwc_ep.is_in > 0U) {
		req->dwc_req.trb = dwc_usb3_ep0_in_desc(pcd);
		req->dwc_req.trbdma = dwc_usb3_ep0_in_desc_dma(pcd);
	} else {
		req->dwc_req.trb = dwc_usb3_ep0_out_desc(pcd);
		req->dwc_req.trbdma = dwc_usb3_ep0_out_desc_dma(pcd);
	}

	desc = req->dwc_req.trb;
	desc_dma = req->dwc_req.trbdma;
	dwc_usb3_dis_usb2_phy_suspend(pcd);

	if (ep0->dwc_ep.is_in > 0U) {
		/*
		 * Start DMA on EP0-IN
		 */
		ep_reg = ep0->dwc_ep.in_ep_reg;

		/* DMA Descriptor (TRB) setup */
		len = req->dwc_req.length;

		dwc_debug1(pcd->usb3_dev, "IN EP0STATE=%d\n", pcd->ep0state);

		if (pcd->ep0state == EP0_IN_STATUS_PHASE) {
			if (ep0->dwc_ep.three_stage > 0U) {
				desc_type = DWC_DSCCTL_TRBCTL_STATUS_3;
			}
            else {
				desc_type = DWC_DSCCTL_TRBCTL_STATUS_2;
			}
		} else {
			desc_type = DWC_DSCCTL_TRBCTL_CTLDATA_1ST;
		}

		dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[0],
				   len, 0, desc_type, DWC_DSCCTL_LST_BIT, 1);
		dwc_debug4(pcd->usb3_dev,
			   "IN desc=0x%08lx xferlen=%u bptr=0x%08x:%08x\n",
			   (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
			   desc->bpth, desc->bptl);
#ifdef VERBOSE
		dwc_debug4(pcd->usb3_dev, "0x%08x 0x%08x 0x%08x 0x%08x\n",
			   *((unsigned *)desc), *((unsigned *)desc + 1),
			   *((unsigned *)desc + 2), *((unsigned *)desc + 3));
#endif
		/* Issue "DEPSTRTXFER" command to EP0-IN */
		wmb();
		tri = dwc_usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
		ep0->dwc_ep.tri_in = tri + 1U;
	} else {
		/*
		 * Start DMA on EP0-OUT
		 */
		ep_reg = ep0->dwc_ep.out_ep_reg;

		/* DMA Descriptor (TRB) setup */
		len = (req->dwc_req.length + ep0->dwc_ep.maxpacket - 1U) &
			~(ep0->dwc_ep.maxpacket - 1U);

		dwc_debug1(pcd->usb3_dev, "OUT EP0STATE=%d\n", pcd->ep0state);

		if (pcd->ep0state == EP0_OUT_STATUS_PHASE) {
			if (ep0->dwc_ep.three_stage > 0U) {
				desc_type = DWC_DSCCTL_TRBCTL_STATUS_3;
			}
			else {
				desc_type = DWC_DSCCTL_TRBCTL_STATUS_2;
			}
		} else {
			desc_type = DWC_DSCCTL_TRBCTL_CTLDATA_1ST;
		}

		dwc_usb3_fill_desc(desc, req->dwc_req.bufdma[0],
				   len, 0, desc_type, DWC_DSCCTL_LST_BIT, 1);
		dwc_debug4(pcd->usb3_dev,
			   "OUT desc=0x%08lx xferlen=%u bptr=0x%08x:%08x\n",
			   (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
			   desc->bpth, desc->bptl);
#ifdef VERBOSE
		dwc_debug4(pcd->usb3_dev, "0x%08x 0x%08x 0x%08x 0x%08x\n",
			   *((unsigned *)desc), *((unsigned *)desc + 1),
			   *((unsigned *)desc + 2), *((unsigned *)desc + 3));
#endif
		/* Issue "DEPSTRTXFER" command to EP0-OUT */
		wmb();
		tri = dwc_usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0);
		ep0->dwc_ep.tri_out = tri + 1U;
	}

	dwc_usb3_ena_usb2_phy_suspend(pcd);
}

/**
 * This routine does the setup for a data transfer for an EP and starts
 * the transfer.
 *
 * @param pcd   Programming view of DWC_usb3 peripheral controller.
 * @param ep    The EP to start the transfer on.
 * @param req   The request to start.
 * @param event If non-zero, this is the first transfer for an Isoc EP, so we
 *              must calculate the starting uFrame and do a startxfer instead
 *              of an updatexfer.
 */
void dwc_usb3_pcd_ep_start_transfer(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
				    dwc_usb3_pcd_req_t *req, u32 event)
{
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;
	dwc_usb3_dma_desc_t *desc __attribute__((unused));
	dwc_dma_t desc_dma;
	u32 dsts;
	u16 current_uf, intvl, mask, now, target_uf = 0;
	u8 tri;
#if defined(DEBUG) || defined(ISOC_DEBUG)
	u32 dcfg;
#endif

	dwc_debug10(pcd->usb3_dev,
		    "%s(): ep%d-%s (%d phys) %lx max_pkt=%d req=%lx"
		    " xfer_len=%d xfer_cnt=%d xfer_buf=%lx\n",
		    __func__, ep->dwc_ep.num, (ep->dwc_ep.is_in ? "IN" : "OUT"),
		    ep->dwc_ep.phys, (unsigned long)ep, ep->dwc_ep.maxpacket,
		    (unsigned long)req, req->dwc_req.length,
		    req->dwc_req.actual, (unsigned long)req->dwc_req.buf[0]);

	ep->dwc_ep.hiber_desc_idx = 0;

	/* If first transfer for Isoc */
	if (event > 0U) {
		/* Get the uFrame of the host request */
		current_uf = event >> DWC_DEPEVT_ISOC_UFRAME_NUM_SHIFT &
			     DWC_DEPEVT_ISOC_UFRAME_NUM_BITS >>
					DWC_DEPEVT_ISOC_UFRAME_NUM_SHIFT;

		/* Get the EP's interval */
		intvl = (u16)1U << ep->dwc_ep.intvl;

		/* Get the EP's interval mask */
		mask = ~(intvl - 1U);

		dsts = dwc_rd32(pcd->usb3_dev, &pcd->dev_global_regs->dsts);
		now = dsts >> DWC_DSTS_SOF_FN_SHIFT &
		      DWC_DSTS_SOF_FN_BITS >> DWC_DSTS_SOF_FN_SHIFT;
		if (now < (current_uf & 0x3fffU)) {
			now += 0x4000U;
		}
		now += current_uf & 0xc000U;

		/* Calculate a start time which is 2 or 4 intervals in the
		 * future
		 */
		target_uf = current_uf & mask;
again:
#ifdef SELA_PLATFORM
		target_uf += intvl;
#else
		if (intvl <= 8U) {
			target_uf += intvl << 2;
		}
		else {
			target_uf += intvl << 1;
		}
#endif
		dwc_isocdbg3(pcd->usb3_dev, "tgt:%1x now:%1x tgt-now:%1x\n",
			     target_uf, now, target_uf - now);
		if (target_uf - now >= 0x8000U) {
			goto again;
		}

#if defined(DEBUG) || defined(ISOC_DEBUG)
		dcfg = dwc_rd32(pcd->usb3_dev, &pcd->dev_global_regs->dcfg);
		dwc_debug6(pcd->usb3_dev,
			   "dcfg:0x%1x dsts:0x%1x uf:0x%1x"
			   " intvl:0x%1x cur_uf:0x%1x tgt_uf:0x%1x\n",
			   dcfg, dsts, dsts >> 3 & 0x3fff, intvl, current_uf,
			   target_uf);
		dwc_isocdbg4(pcd->usb3_dev,
			     "now:%1x bIvl:%1x ivl:%1x(u)f tgt:%1x\n",
			     now, ep->dwc_ep.intvl + 1, intvl, target_uf);
#endif
		/* Make sure 'target_uf' is non-zero so the code below knows
		 * that this is the first Isoc xfer. It will decrement the
		 * value by 1 before using it
		 */
		target_uf++;
	}

	ep->dwc_ep.send_zlp = 0;
	req->dwc_req.flags |= DWC_PCD_REQ_STARTED;
	desc = req->dwc_req.trb;
	desc_dma = req->dwc_req.trbdma;
	dwc_usb3_dis_usb2_phy_suspend(pcd);
	wmb();

	if (ep->dwc_ep.is_in > 0U) {
		/*
		 * Start DMA on EPn-IN
		 */
		ep_reg = ep->dwc_ep.in_ep_reg;
		dwc_debug4(pcd->usb3_dev,
			   "IN desc=0x%08lx xferlen=%u bptr=0x%08x:%08x\n",
			   (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
			   desc->bpth, desc->bptl);
#ifdef VERBOSE
		dwc_debug5(pcd->usb3_dev, "%08x %08x %08x %08x (%08x)\n",
			   *((unsigned *)desc), *((unsigned *)desc + 1),
			   *((unsigned *)desc + 2), *((unsigned *)desc + 3),
			   (unsigned)desc_dma);
#endif
		/* If Isoc */
		if (ep->dwc_ep.type == UE_ISOCHRONOUS) {
			if (ep->dwc_ep.xfer_started > 0U) {
				/* Issue "DEPUPDTXFER" command to EP */
				dwc_usb3_dep_updatexfer(pcd, ep_reg,
							(u32)ep->dwc_ep.tri_in - 1U);
			} else if (target_uf > 0U) {
				/* Issue "DEPSTRTXFER" command to EP */
				tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
							     desc_dma,
							     (u32)target_uf - 1U);
				ep->dwc_ep.tri_in = tri + 1U;
				ep->dwc_ep.xfer_started = 1;
			} else {
				//dwc_print0(pcd->usb3_dev,
				//	   "Not starting isoc IN!\n");
			}
		} else {
			if (ep->dwc_ep.xfer_started > 0U) {
				/* Issue "DEPUPDTXFER" command to EP */
				dwc_usb3_dep_updatexfer(pcd, ep_reg,
							(u32)ep->dwc_ep.tri_in - 1U);
			} else {
				/* Issue "DEPSTRTXFER" command to EP */
				tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
							desc_dma,
							req->dwc_req.stream);
				ep->dwc_ep.tri_in = tri + 1U;
				ep->dwc_ep.xfer_started = 1;
			}
		}
	} else {
		/*
		 * Start DMA on EPn-OUT
		 */
		ep_reg = ep->dwc_ep.out_ep_reg;
		dwc_debug4(pcd->usb3_dev,
			   "OUT desc=0x%08lx xferlen=%u bptr=0x%08x:%08x\n",
			   (unsigned long)desc, dwc_usb3_get_xfercnt(desc),
			   desc->bpth, desc->bptl);
#ifdef VERBOSE
		dwc_debug5(pcd->usb3_dev, "%08x %08x %08x %08x (%08x)\n",
			   *((unsigned *)desc), *((unsigned *)desc + 1),
			   *((unsigned *)desc + 2), *((unsigned *)desc + 3),
			   (unsigned)desc_dma);
#endif
		/* If Isoc */
		if (ep->dwc_ep.type == UE_ISOCHRONOUS) {
			if (ep->dwc_ep.xfer_started > 0U) {
				/* Issue "DEPUPDTXFER" command to EP */
				dwc_usb3_dep_updatexfer(pcd, ep_reg,
							(u32)ep->dwc_ep.tri_out - 1U);
			} else if (target_uf > 0U) {
				/* Issue "DEPSTRTXFER" command to EP */
				tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
							     desc_dma,
							     (u32)target_uf - 1U);
				ep->dwc_ep.tri_out = tri + 1U;
				ep->dwc_ep.xfer_started = 1;
			} else {
				//dwc_print0(pcd->usb3_dev,
				//	   "Not starting isoc OUT!\n");
			}
		} else {
			if (ep->dwc_ep.xfer_started > 0U) {
				/* Issue "DEPUPDTXFER" command to EP */
				dwc_usb3_dep_updatexfer(pcd, ep_reg,
							(u32)ep->dwc_ep.tri_out - 1U);
			} else {
				/* Issue "DEPSTRTXFER" command to EP */
				tri = dwc_usb3_dep_startxfer(pcd, ep_reg,
							desc_dma,
							req->dwc_req.stream);
				ep->dwc_ep.tri_out = tri + 1U;
				ep->dwc_ep.xfer_started = 1;
			}
		}
	}

	dwc_usb3_ena_usb2_phy_suspend(pcd);
}

/**
 * For restart after hibernation, we need to restart the transfer with the
 * address of the TRB that was last active before the hibernation. That address
 * was saved in the <em>hiber_desc_idx</em> field of struct dwc_ep by the
 * hibernation wakeup code.
 *
 * @param pcd   Programming view of DWC_usb3 peripheral controller.
 * @param ep    The EP to restart the transfer on.
 * @return      1 if a transfer was restarted, 0 if not.
 */
int dwc_usb3_pcd_isoc_ep_hiber_restart(dwc_usb3_pcd_t *pcd,
				       dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;
	dwc_usb3_dma_desc_t *desc __attribute__((unused));
	dwc_dma_t desc_dma;
	int owned;
	u8 *tri;

	/* Need to restart after hibernation? */
	owned = ep->dwc_ep.hiber_desc_idx - 1;
	if (owned < 0) {
		return 0;
	}

	if (ep->dwc_ep.is_in > 0U) {
		ep_reg = ep->dwc_ep.in_ep_reg;
		tri = &ep->dwc_ep.tri_in;
	} else {
		ep_reg = ep->dwc_ep.out_ep_reg;
		tri = &ep->dwc_ep.tri_out;
	}

	dwc_debug0(pcd->usb3_dev, "Restarting Isoc xfer\n");
	desc = ep->dwc_ep.dma_desc + owned;
	desc_dma = (dwc_dma_t)
		((unsigned long)ep->dwc_ep.dma_desc_dma + (unsigned long)owned * 16U);
	dwc_debug1(pcd->usb3_dev, "desc=%08lx\n", (unsigned long)desc);

#ifdef VERBOSE
	dwc_debug5(pcd->usb3_dev, "%08x %08x %08x %08x (%08x)\n",
		   *((unsigned *)desc), *((unsigned *)desc + 1),
		   *((unsigned *)desc + 2), *((unsigned *)desc + 3),
		   (unsigned)desc_dma);
#endif

	dwc_usb3_dis_usb2_phy_suspend(pcd);
	wmb();
	*tri = dwc_usb3_dep_startxfer(pcd, ep_reg, desc_dma, 0) + 1;
	dwc_usb3_ena_usb2_phy_suspend(pcd);

	return 1;
}

/**
 * Stop any active xfer on a non-EP0 endpoint.
 */
static void dwc_usb3_stop_xfer(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;

	dwc_debug1(pcd->usb3_dev, "%s()\n", __func__);

	if (ep->dwc_ep.is_in > 0U) {
		if ((ep->dwc_ep.active > 0U) && (ep->dwc_ep.tri_in > 0U)) {
			ep_reg = ep->dwc_ep.in_ep_reg;
			ep->dwc_ep.condition = 0;
			dwc_usb3_dep_endxfer(pcd, ep_reg, (u32)ep->dwc_ep.tri_in - 1U,
					     DWC_ENDXFER_FORCE,
					     &ep->dwc_ep.condition);
			ep->dwc_ep.tri_in = 0;
		}
	} else {
		if ((ep->dwc_ep.active > 0U) && (ep->dwc_ep.tri_out > 0U)) {
			ep_reg = ep->dwc_ep.out_ep_reg;
			ep->dwc_ep.condition = 0;
			dwc_usb3_dep_endxfer(pcd, ep_reg, (u32)ep->dwc_ep.tri_out - 1U,
					     DWC_ENDXFER_FORCE,
					     &ep->dwc_ep.condition);
			ep->dwc_ep.tri_out = 0;
		}
	}
}

/**
 * Stop any active xfers on the non-EP0 endpoints.
 */
void dwc_usb3_stop_all_xfers(dwc_usb3_pcd_t *pcd)
{
	int i;
	dwc_usb3_pcd_ep_t *ep;

	dwc_debug1(pcd->usb3_dev, "%s()\n", __func__);
	dwc_usb3_dis_usb2_phy_suspend(pcd);

	/* Stop any active xfers on the non-EP0 IN endpoints */
	for (i = pcd->num_in_eps; i > 0; i--) {
		ep = pcd->in_ep[i - 1];
		dwc_debug3(pcd->usb3_dev, "DWC IN EP%d=%lx tri-in=%d\n",
			   i, (unsigned long)ep, ep->dwc_ep.tri_in);
		dwc_usb3_stop_xfer(pcd, ep);
		dwc_usb3_gadget_request_nuke(pcd, ep);
		ep->dwc_ep.xfer_started = 0;
	}

	/* Stop any active xfers on the non-EP0 OUT endpoints */
	for (i = pcd->num_out_eps; i > 0; i--) {
		ep = pcd->out_ep[i - 1];
		dwc_debug3(pcd->usb3_dev, "DWC OUT EP%d=%lx tri-out=%d\n",
			   i, (unsigned long)ep, ep->dwc_ep.tri_out);
		dwc_usb3_stop_xfer(pcd, ep);
		dwc_usb3_gadget_request_nuke(pcd, ep);
		ep->dwc_ep.xfer_started = 0;
	}

	dwc_usb3_ena_usb2_phy_suspend(pcd);
}

/**
 * This routine completes the request for the EP. If there are additional
 * requests for the EP in the queue they will be started.
 */
static int dwc_usb3_ep_complete_request(dwc_usb3_pcd_t *pcd,
					dwc_usb3_pcd_ep_t *ep,
					dwc_usb3_pcd_req_t *req, u32 event)
{
	int is_last = 0, ret = 0;
	int now_uf, evt_uf, diff, intvl, tri, i;
	u32 status;
	dwc_usb3_dma_desc_t *desc;
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;
	u32 byte_count;
#if defined(DEBUG) || defined(ISOC_DEBUG)
	dwc_usb3_device_t *dev = pcd->usb3_dev;
	u32 bmudbg;
	static u32 old0, old1, old2, old3, old4;
#endif

	dwc_debug1(dev, "%s()\n", __func__);

	ep->dwc_ep.send_zlp = 0;
	desc = req->dwc_req.trb;
	dwc_debug2(dev, "req=%lx desc=%lx\n", (unsigned long)req,
		   (unsigned long)desc);

	if (!desc) {
		dwc_isocdbg3(dev, "### %s, EP%d-%s request TRB is NULL! ###\n",
			     __func__, ep->dwc_ep.num, ep->dwc_ep.is_in ?
			     "IN" : "OUT");
		return ret;
	}

	if ((req->dwc_req.flags & DWC_PCD_REQ_STARTED) == 0U) {
		dwc_isocdbg3(dev, "### %s, EP%d-%s request not started! ###\n",
			     __func__, ep->dwc_ep.num, ep->dwc_ep.is_in ?
			     "IN" : "OUT");
		if (ep->dwc_ep.type == UE_ISOCHRONOUS &&
		    (event & DWC_DEPEVT_INTTYPE_BITS) ==
		    DWC_DEPEVT_XFER_IN_PROG << DWC_DEPEVT_INTTYPE_SHIFT &&
		    ep->dwc_ep.xfer_started == 0U) {
			is_last = 1;
			goto done;
		}
		return ret;
	}

	if ((dwc_usb3_is_hwo(desc)) > 0U) {
		dwc_isocdbg3(dev, "### %s, EP%d-%s HWO bit set! ###\n",
			     __func__, ep->dwc_ep.num, ep->dwc_ep.is_in ?
			     "IN" : "OUT");
		return ret;
	}

	if (ep->dwc_ep.type == UE_ISOCHRONOUS) {
		now_uf = dwc_usb3_get_frame(pcd);
		evt_uf = dwc_usb3_get_eventsofn(event);
		dwc_isocdbg6(dev,
			"ep:%1x evt:%08x frm:%04x now:%04x trb:%1lx len:%04x\n",
			ep->dwc_ep.num, event, evt_uf, now_uf,
			((unsigned long)req->dwc_req.trbdma -
			 (unsigned long)ep->dwc_ep.dma_desc_dma) /
			(req->dwc_req.numbuf * 16), dwc_usb3_get_xfercnt(desc));
		/*dwc_isocdbg4(dev, "this trb: %08x %08x %08x %08x\n",
			*((unsigned *)desc), *((unsigned *)desc + 1),
			*((unsigned *)desc + 2), *((unsigned *)desc + 3));
		dwc_isocdbg4(dev, "next trb: %08x %08x %08x %08x\n",
			*((unsigned *)desc + 4), *((unsigned *)desc + 5),
			*((unsigned *)desc + 6), *((unsigned *)desc + 7));*/

		status = dwc_usb3_get_xfersts(desc);
		if ((status & DWC_TRBRSP_MISSED_ISOC_IN) > 0U) {
			desc->status &= ~DWC_DSCSTS_TRBRSP_BITS;

#if defined(DEBUG) || defined(ISOC_DEBUG)
			/* Undocumented BMU debug register */
			bmudbg = dwc_rd32(dev, (volatile u32 __iomem *)
						(dev->base + 0xc16c));
			dwc_isocdbg1(dev,
				     "(%01x) Missed Isoc! (cmpl as 0-len)\n",
				     status);
			/*dwc_isocdbg5(dev, "%08x %08x %08x %08x (%08x)\n",
			       *((unsigned *)desc), *((unsigned *)desc + 1),
			       *((unsigned *)desc + 2), *((unsigned *)desc + 3),
			       bmudbg);
			dwc_isocdbg5(dev, "prev: %08x %08x %08x %08x (%08x)\n",
				     old0, old1, old2, old3, old4);*/
#endif
			/* Only valid to check uFrame on TRBs with IOC set */
			if ((dwc_usb3_is_ioc(desc)) == 0U) {
				goto no_restart;
			}

			/* Check uFrame from event to see if we are too far off
			 * and need to restart the EP
			 */
			evt_uf &= 0x3fff;
			diff = now_uf - evt_uf;
			if (diff < 0) {
				diff += 0x4000;
			}
			intvl = 1 << ep->dwc_ep.intvl;
			dwc_isocdbg2(dev, "diff %1x intvl %1x\n", diff, intvl);
#if 0
			dwc_usb3_dump_dbgregs(pcd->usb3_dev);
#endif
			if (diff < intvl * 2) {
				goto no_restart;
			}

			/* Something has gone wrong, shut down the EP and then
			 * restart it
			 */
			dwc_isocdbg0(dev, "Restart!\n");
			if (ep->dwc_ep.is_in > 0U) {
				ep_reg = ep->dwc_ep.in_ep_reg;
				tri = ep->dwc_ep.tri_in;
				ep->dwc_ep.tri_in = 0;
				dwc_isocdbg1(dev, "IN tri=%1x\n", tri - 1);
			} else {
				ep_reg = ep->dwc_ep.out_ep_reg;
				tri = ep->dwc_ep.tri_out;
				ep->dwc_ep.tri_out = 0;
				dwc_isocdbg1(dev, "OUT tri=%1x\n", tri - 1);
			}

			if ((ep->dwc_ep.active > 0U) && (tri > 0)) {
				ep->dwc_ep.condition = 0;
				dwc_usb3_dis_usb2_phy_suspend(pcd);
				dwc_usb3_dep_endxfer(pcd, ep_reg, tri - 1,
						     DWC_ENDXFER_FORCE |
						     DWC_ENDXFER_NODELAY,
						     &ep->dwc_ep.condition);
				dwc_usb3_ena_usb2_phy_suspend(pcd);
			}

			ep->dwc_ep.xfer_started = 0;

			/* Tell caller to mark all queued requests as
			 * not started
			 */
			ret = -1;
no_restart:
			req->dwc_req.actual = 0;
			is_last = 1;
			goto done;

#if defined(DEBUG) || defined(ISOC_DEBUG)
		} else {
			old0 = *((unsigned *)desc);
			old1 = *((unsigned *)desc + 1);
			old2 = *((unsigned *)desc + 2);
			old3 = *((unsigned *)desc + 3);

			/* Undocumented BMU debug register */
			old4 = dwc_rd32(dev, (volatile u32 __iomem *)
						(dev->base + 0xc16c));
#endif
		}
	}

	if (ep->dwc_ep.is_in > 0U) {	/* IN endpoint */
		for (i = 0; i < req->dwc_req.numbuf; i++, desc++) {
			if (dwc_usb3_get_xfercnt(desc) == 0U) {
				req->dwc_req.actual += req->dwc_req.length;
				if (i == req->dwc_req.numbuf - 1) {
					is_last = 1;
				}
			} else {
				dwc_print0(dev, "Incomplete transfer!\n");
			}
		}

		if (i != 0) {
			desc--;
		}
		dwc_debug3(dev, "IN len=%d cnt=%d rem=%d\n",
			   req->dwc_req.length, req->dwc_req.actual,
			   dwc_usb3_get_xfercnt(desc));

	} else {		/* OUT endpoint */
		for (i = 0; i < req->dwc_req.numbuf; i++, desc++) {
			byte_count = req->dwc_req.length -
						dwc_usb3_get_xfercnt(desc);
			req->dwc_req.actual += byte_count;
		}

		if (i != 0) {
			desc--;
		}
		dwc_debug3(dev, "OUT len=%d cnt=%d rem=%d\n",
			   req->dwc_req.length, req->dwc_req.actual,
			   dwc_usb3_get_xfercnt(desc));
		is_last = 1;
	}
done:
	if ((event & DWC_DEPEVT_INTTYPE_BITS) ==
	    DWC_DEPEVT_XFER_CMPL << DWC_DEPEVT_INTTYPE_SHIFT) {
		if (ep->dwc_ep.is_in > 0U) {
			ep->dwc_ep.tri_in = 0;
		}
		else {
			ep->dwc_ep.tri_out = 0;
		}
	}

	/* Complete the request */
	if (is_last > 0) {
		dwc_usb3_pcd_request_done(pcd, ep, req, 0);
		//dwc_info2(dev, "ep_complete_request - start req %d-%s\n",
		//	  ep->dwc_ep.num, ep->dwc_ep.is_in ? "IN" : "OUT");
		if (ep->dwc_ep.type != UE_ISOCHRONOUS ||
						(ep->dwc_ep.xfer_started > 0U)) {
			/* If there is a request in the queue start it. */
			dwc_usb3_gadget_start_next_request(pcd, ep);
		}

#ifdef DWC_ISOC_INTR_MODERATION
		/* Handle Isoc interrupt moderation */
		if (ep->dwc_ep.type == UE_ISOCHRONOUS &&
		    ep->dwc_ep.xfer_started && !dwc_usb3_is_ioc(desc))
			/* Tell caller we want to process next TRB */
			ret = 1;
#endif
	} else {
		dwc_print2(dev, "### EP%d-%s is_last not set! ###\n",
			   ep->dwc_ep.num, ep->dwc_ep.is_in ? "IN" : "OUT");
	}

	return ret;
}

/**
 * This routine handles non-EP0 transfers.
 *
 * This routine gets the request corresponding to the completed transfer
 * and then calls the core routine for handling the completion.
 */
void dwc_usb3_complete_request(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			       u32 event)
{
	dwc_usb3_pcd_req_t *req;
	dwc_usb3_dma_desc_t *desc;
	int ret;

	dwc_debug1(pcd->usb3_dev, "%s()\n", __func__);
	dwc_debug1(pcd->usb3_dev, "Requests %d\n", pcd->request_pending);

	req = dwc_usb3_gadget_get_request(pcd, ep);
	if (!req) {
		dwc_print2(pcd->usb3_dev, "%s(%lx), ep->dwc_ep.queue empty!\n",
			   __func__, (unsigned long)ep);
		return;
	}
next:
	ret = dwc_usb3_ep_complete_request(pcd, ep, req, event);
	dwc_debug1(pcd->usb3_dev,
		   "dwc_usb3_ep_complete_request() returned %d\n", ret);
	if (ret == 0) {
		return;
	}

	req = dwc_usb3_gadget_get_request(pcd, ep);
	if (!req) {
		return;
	}

	if (ret < 0) {
		/* Isoc restart - mark all requests in queue as not started */
		dwc_usb3_gadget_set_ep_not_started(pcd, ep);
	} else {
		/* ep_complete_request() wants to process next TRB */
		dwc_debug1(pcd->usb3_dev, "Requests2 %d\n",
			   pcd->request_pending);
		desc = req->dwc_req.trb;
		if (desc && (req->dwc_req.flags & DWC_PCD_REQ_STARTED) &&
		    (dwc_usb3_is_hwo(desc) == 0U)) {
			dwc_debug0(pcd->usb3_dev, "Processing next TRB\n");
			goto next;
		}
	}
}

/**
 * Set the EP STALL.
 *
 * @param pcd   Programming view of DWC_usb3 peripheral controller.
 * @param ep    The EP to set the stall on.
 */
void dwc_usb3_pcd_ep_set_stall(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;

	dwc_info2(pcd->usb3_dev, "%s(%lx)\n", __func__, (unsigned long)ep);
	dwc_info2(pcd->usb3_dev, "ep_num=%d is_in=%d\n",
		  ep->dwc_ep.num, ep->dwc_ep.is_in);

	if (ep->dwc_ep.is_in > 0U) {
		ep_reg = ep->dwc_ep.in_ep_reg;
	}
	else {
		ep_reg = ep->dwc_ep.out_ep_reg;
	}

	dwc_usb3_dis_usb2_phy_suspend(pcd);
	dwc_usb3_dep_sstall(pcd, ep_reg);
	dwc_usb3_ena_usb2_phy_suspend(pcd);
}

/**
 * Clear the EP STALL.
 *
 * @param pcd   Programming view of DWC_usb3 peripheral controller.
 * @param ep    The EP to clear the stall on.
 */
void dwc_usb3_pcd_ep_clear_stall(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_usb3_dev_ep_regs_t __iomem *ep_reg;

	dwc_debug1(pcd->usb3_dev, "%s()\n", __func__);
	dwc_debug2(pcd->usb3_dev, "ep_num=%d is_in=%d\n",
		   ep->dwc_ep.num, ep->dwc_ep.is_in);

	if (ep->dwc_ep.is_in > 0U) {
		ep_reg = ep->dwc_ep.in_ep_reg;
	}
	else {
		ep_reg = ep->dwc_ep.out_ep_reg;
	}

	dwc_usb3_dis_usb2_phy_suspend(pcd);
	dwc_usb3_dep_cstall(pcd, ep_reg, 0);
	dwc_usb3_ena_usb2_phy_suspend(pcd);
}

/**
 * This routine returns a pointer to Out EP struct with number ep_num.
 */
dwc_usb3_pcd_ep_t *dwc_usb3_get_out_ep(dwc_usb3_pcd_t *pcd, u32 ep_num)
{
	//dwc_debug2(pcd->usb3_dev, "%s(%d)\n", __func__, ep_num);

	if (ep_num == 0U) {
		return pcd->ep0;
	}
	else {
		return pcd->out_ep[ep_num - 1U];
	}
}

/**
 * This routine returns a pointer to In EP struct with number ep_num.
 */
dwc_usb3_pcd_ep_t *dwc_usb3_get_in_ep(dwc_usb3_pcd_t *pcd, u32 ep_num)
{
	//dwc_debug2(pcd->usb3_dev, "%s(%d)\n", __func__, ep_num);

	if (ep_num == 0U) {
		return pcd->ep0;
	}
	else {
		return pcd->in_ep[ep_num - 1U];
	}
}

/**
 * This routine gets a pointer to an EP from the wIndex address value of the
 * control request.
 */
dwc_usb3_pcd_ep_t *dwc_usb3_pcd_get_ep_by_addr(dwc_usb3_pcd_t *pcd, u16 idx)
{
	u16 ep_num = UE_GET_ADDR(idx);

	//dwc_debug2(pcd->usb3_dev, "%s(%d)\n", __func__, idx);

	if (UE_GET_DIR(idx) == UE_DIR_IN) {
		return dwc_usb3_get_in_ep(pcd, ep_num);
	}
	else {
		return dwc_usb3_get_out_ep(pcd, ep_num);
	}
}

/* USB Endpoint Operations */
/*
 * The following sections briefly describe the behavior of the Gadget API
 * endpoint operations implemented in the DWC_usb3 driver software. Detailed
 * descriptions of the generic behavior of each of these routines can be
 * found in the Linux header file include/linux/usb_gadget.h.
 *
 * The Gadget API provides wrapper routines for each of the function
 * pointers defined in usb_ep_ops. The Gadget Driver calls the wrapper
 * routine, which then calls the underlying PCD routine. The following
 * sections are named according to the wrapper routines. Within each
 * section, the corresponding DWC_usb3 PCD routine name is specified.
 *
 */

/**
 * This routine is called by the Function Driver for each EP (except EP0) to
 * be configured for the current configuration (SET_CONFIGURATION).
 *
 * This routine initializes the dwc_usb3_ep_t data structure, and then
 * calls dwc_usb3_ep_activate.
 */
int dwc_usb3_pcd_ep_enable(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			   const usb_endpoint_descriptor_t *ep_desc,
			   const ss_endpoint_companion_descriptor_t *ep_comp)
{
	uByte dir;
	u16 maxpacket;
	u8 type;
	uByte num;

	dwc_debug5(pcd->usb3_dev, "%s(%lx,%lx,%lx,%lx)\n", __func__,
		   (unsigned long)pcd, (unsigned long)ep,
		   (unsigned long)ep_desc, (unsigned long)ep_comp);
	dwc_debug2(pcd->usb3_dev, "ep=%lx is_in=%d\n", (unsigned long)ep,
		   ep->dwc_ep.is_in);

	if (ep->dwc_ep.usb_ep_desc != NULL) {
		dwc_print1(pcd->usb3_dev, "%s, bad ep or descriptor!\n",
			   __func__);
		return -DWC_E_INVALID;
	}

	ep->dwc_ep.usb_ep_desc = ep_desc;

	/*
	 * Activate the EP
	 */
	ep->dwc_ep.stopped = 0;

	num = UE_GET_ADDR(ep_desc->bEndpointAddress);
	if (ep->dwc_ep.num != num) {
		dwc_print3(pcd->usb3_dev,
			   "%s, EP num mismatch, is %d asked %d!\n",
			   __func__, ep->dwc_ep.num, num);
	}

	dir = UE_GET_DIR(ep_desc->bEndpointAddress);
	if (ep->dwc_ep.is_in != (unsigned int)(dir == UE_DIR_IN)) {
		dwc_print3(pcd->usb3_dev,
			   "%s, EP dir mismatch, is %d asked %d!\n",
			   __func__, ep->dwc_ep.is_in, dir == UE_DIR_IN);
	}

	type = UE_GET_XFERTYPE(ep_desc->bmAttributes);
	maxpacket = UGETW(ep_desc->wMaxPacketSize);

	ep->dwc_ep.type = type;
	ep->dwc_ep.maxpacket = maxpacket & 0x7ffU;
	ep->dwc_ep.intvl = 0;
	ep->dwc_ep.mult = 0;
	ep->dwc_ep.maxburst = 0;
	ep->dwc_ep.num_streams = 0;
	ep->dwc_ep.xfer_started = 0;

	if (pcd->speed == USB_SPEED_SUPER && ep_comp) {
		ep->dwc_ep.maxburst = ep_comp->bMaxBurst;
	}

	switch (type) {
	case UE_ISOCHRONOUS:
		if (pcd->speed == USB_SPEED_SUPER && ep_comp) {
			ep->dwc_ep.mult = USSE_GET_MAX_PACKET_NUM(
						ep_comp->bmAttributes) + 1U;
			/* 3 packets at most */
			if (ep->dwc_ep.mult > 3U) {
				return -DWC_E_INVALID;
			}
		}
		/* FALL THRU */
	case UE_INTERRUPT:
		if (pcd->speed == USB_SPEED_SUPER) {
			ep->dwc_ep.intvl = ep_desc->bInterval - 1U;
			break;
		}

		ep->dwc_ep.intvl = ep_desc->bInterval - 1U;

		/*
		 * Bits 12:11 specify number of _additional_
		 * packets per microframe.
		 */
		ep->dwc_ep.mult = (maxpacket >> 11 & 3U) + 1U;

		/* 3 packets at most */
		if (ep->dwc_ep.mult > 3U) {
			return -DWC_E_INVALID;
		}

		break;

	case UE_BULK:
		if (pcd->speed == USB_SPEED_SUPER && ep_comp) {
			ep->dwc_ep.num_streams =
				USSE_GET_MAX_STREAMS(ep_comp->bmAttributes);
		}

		/* Set initial data PID */
		ep->dwc_ep.data_pid_start = 0;
		break;

	default :
		// do nothing
		break;
	}

	dwc_debug5(pcd->usb3_dev,
		   "type=%u maxpkt=%u mult=%u maxbst=%u numstrm=%u\n",
		   type, maxpacket, ep->dwc_ep.mult, ep->dwc_ep.maxburst,
		   ep->dwc_ep.num_streams);

	dwc_usb3_ep_activate(pcd, ep, 0);
	return 0;
}

/**
 * This routine is called when an EP (except EP0) is disabled due to
 * disconnect or change in configuration. Any pending requests will
 * terminate with a status of -ESHUTDOWN.
 *
 * This routine modifies the dwc_usb3_ep_t data structure for this EP,
 * and then calls ep_deactivate.
 */
int dwc_usb3_pcd_ep_disable(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep)
{
	dwc_debug2(pcd->usb3_dev, "%s(%lx)\n", __func__, (unsigned long)ep);
	dwc_debug2(pcd->usb3_dev, "ep=%lx is_in=%d\n", (unsigned long)ep,
		   ep->dwc_ep.is_in);

	if (!ep->dwc_ep.usb_ep_desc) {
		return -DWC_E_INVALID;
	}

	ep_deactivate(ep->dwc_ep.pcd, ep);
	dwc_usb3_gadget_request_nuke(pcd, ep);
	ep->dwc_ep.usb_ep_desc = NULL;

	return 0;
}

/**
 * This routine submits an I/O Request to an EP.
 *
 * - When the request completes the request's completion callback is called
 *   to return the request to the driver.
 * - An EP, except control EPs, may have multiple requests pending.
 * - Once submitted the request cannot be examined or modified.
 * - Each request is turned into one or more packets.
 * - A BULK EP can queue any amount of data; the transfer is packetized.
 * - Zero-length packets are specified with the request 'zero' flag.
 */
int dwc_usb3_pcd_ep_submit_req(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			       dwc_usb3_pcd_req_t *req, u32 req_flags)
{
	dwc_debug1(pcd->usb3_dev, "%s()\n", __func__);

	/* EP0 Transfer? */
	if (ep == pcd->ep0) {
		switch (pcd->ep0state) {
		case EP0_IN_DATA_PHASE:
			dwc_debug1(pcd->usb3_dev, "%s ep0: EP0_IN_DATA_PHASE\n",
				   __func__);
			break;

		case EP0_OUT_DATA_PHASE:
			dwc_debug1(pcd->usb3_dev,
				   "%s ep0: EP0_OUT_DATA_PHASE\n", __func__);
			if (pcd->request_config > 0U) {
				/* Complete STATUS PHASE */
				ep->dwc_ep.is_in = 1;
				pcd->ep0state = EP0_IN_WAIT_NRDY;
				return 1;
			}

			break;

		case EP0_IN_WAIT_GADGET:
			dwc_debug1(pcd->usb3_dev,
				   "%s ep0: EP0_IN_WAIT_GADGET\n", __func__);
			pcd->ep0state = EP0_IN_WAIT_NRDY;
			return 2;

		case EP0_OUT_WAIT_GADGET:
			dwc_debug1(pcd->usb3_dev,
				   "%s ep0: EP0_OUT_WAIT_GADGET\n", __func__);
			pcd->ep0state = EP0_OUT_WAIT_NRDY;
			return 3;

		case EP0_IN_WAIT_NRDY:
			dwc_debug1(pcd->usb3_dev, "%s ep0: EP0_IN_WAIT_NRDY\n",
				   __func__);
			pcd->ep0state = EP0_IN_STATUS_PHASE;
			break;

		case EP0_OUT_WAIT_NRDY:
			dwc_debug1(pcd->usb3_dev, "%s ep0: EP0_OUT_WAIT_NRDY\n",
				   __func__);
			pcd->ep0state = EP0_OUT_STATUS_PHASE;
			break;

		default:
			dwc_print2(pcd->usb3_dev, "%s ep0: odd state %d!\n",
				   __func__, pcd->ep0state);
			return -DWC_E_SHUTDOWN;
		}

		ep->dwc_ep.send_zlp = 0;

		if ((req_flags & DWC_PCD_REQ_ZERO) > 0U &&
				req->dwc_req.length != 0U &&
				(req->dwc_req.length &
					(ep->dwc_ep.maxpacket - 1U)) == 0U) {
			ep->dwc_ep.send_zlp = 1;
		}

		dwc_usb3_pcd_ep0_start_transfer(pcd, req);

#ifdef DWC_STAR_9000463548_WORKAROUND
		if (pcd->configuring) {
			dwc_usb3_pcd_ep_t *ept;
			int i;

			pcd->configuring = 0;

			for (i = 0; i < pcd->num_in_eps; i++) {
				ept = pcd->in_ep[i];
				if (ept->dwc_ep.active)
					dwc_usb3_ep_activate(pcd, ept, 0);
			}

			for (i = 0; i < pcd->num_out_eps; i++) {
				ept = pcd->out_ep[i];
				if (ept->dwc_ep.active)
					dwc_usb3_ep_activate(pcd, ept, 0);
			}
		}
#endif
	} else {
		/* Setup and start the Transfer */
		dwc_usb3_pcd_ep_start_transfer(pcd, ep, req, 0);
	}

	return 0;
}

/**
 * This routine cancels an I/O request from an EP.
 */
void dwc_usb3_pcd_ep_cancel_req(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
				dwc_usb3_pcd_req_t *req, u32 stream)
{
	dwc_debug4(pcd->usb3_dev, "%s(%lx,%lx) stream %d\n", __func__,
		   (unsigned long)ep, (unsigned long)req, stream);

	dwc_usb3_dis_usb2_phy_suspend(pcd);
	dwc_usb3_stop_xfer(pcd, ep);
	dwc_usb3_ena_usb2_phy_suspend(pcd);

	ep->dwc_ep.xfer_started = 0;
	dwc_usb3_pcd_request_done(pcd, ep, req, -DWC_E_DISCONNECT);
}

/**
 * usb_ep_set_halt stalls an endpoint.
 *
 * usb_ep_clear_halt clears an endpoint stall and resets its data toggle.
 *
 * Both of these routines are implemented with the same underlying routine.
 * The behavior depends on the value argument.
 *
 * @param pcd   The PCD structure.
 * @param ep    The endpoint to set halt or clear halt.
 * @param value - 0 means clear_halt.
 *              - 1 means set_halt.
 *              - 2 means clear stall lock flag.
 *              - 3 means set stall lock flag.
 */
void dwc_usb3_pcd_ep_set_halt(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			      int value)
{
	dwc_debug3(pcd->usb3_dev, "%s(%lx,%d)\n", __func__,
		   (unsigned long)ep, value);

	if (value == 0) {
		ep->dwc_ep.stall_clear_flag = 0;
		dwc_usb3_pcd_ep_clear_stall(pcd, ep);

		if (ep->dwc_ep.stopped > 0U) {
			ep->dwc_ep.stopped = 0;

			/* If there is a request in the EP queue start it */
			if (ep != pcd->ep0 && (ep->dwc_ep.is_in > 0U)) {
				dwc_usb3_gadget_start_next_request(pcd, ep);
			}
		}
	} else if (value == 1) {
stall:
		if (ep == pcd->ep0) {
			ep->dwc_ep.is_in = 0;
			dwc_usb3_pcd_ep_set_stall(pcd, ep);
			pcd->ep0state = EP0_STALL;
		} else {
			dwc_usb3_pcd_ep_set_stall(pcd, ep);
		}

		ep->dwc_ep.stopped = 1;

	} else if (value == 2) {
		ep->dwc_ep.stall_clear_flag = 0;

	} else if (value == 3) {
		ep->dwc_ep.stall_clear_flag = 1;
		goto stall;
	} else {
        // do nothing
	}
}

/**
 * This routine completes a request. It calls the request callback.
 */
void dwc_usb3_pcd_request_done(dwc_usb3_pcd_t *pcd, dwc_usb3_pcd_ep_t *ep,
			       dwc_usb3_pcd_req_t *req, int status)
{
	unsigned stopped = ep->dwc_ep.stopped;

	dwc_debug4(pcd->usb3_dev, "%s(%lx,%lx,%d)\n", __func__,
		   (unsigned long)ep, (unsigned long)req, status);

	if (ep != pcd->ep0) {
		req->dwc_req.flags &= ~DWC_PCD_REQ_STARTED;
		if (req->dwc_req.trb != NULL) {
			dwc_usb3_disable_desc(req->dwc_req.trb);
			ep->dwc_ep.desc_avail++;
			req->dwc_req.trb = NULL;
		}
	}

	/* don't modify queue heads during completion callback */
	ep->dwc_ep.stopped = 1;

	dwc_usb3_gadget_complete(pcd, ep, req, status);

	//req->dwc_req.actual = 0;
	ep->dwc_ep.stopped = stopped;
}

/**
 * This routine is called when the Device is disconnected. It stops any
 * active requests and informs the Function Driver of the disconnect.
 */
void dwc_usb3_pcd_stop(dwc_usb3_pcd_t *pcd)
{
	dwc_usb3_pcd_ep_t *ep;
	u32 i;

	dwc_debug1(pcd->usb3_dev, "%s()\n", __func__);

	/* don't disconnect drivers more than once */
	if (pcd->state == DWC_STATE_UNCONNECTED) {
		dwc_debug1(pcd->usb3_dev, "%s() Already Disconnected\n",
			   __func__);
	} else {
		pcd->state = DWC_STATE_UNCONNECTED;

		/* report disconnect; the driver is already quiesced */
		dwc_usb3_gadget_disconnect(pcd);
	}

	dwc_usb3_dis_usb2_phy_suspend(pcd);

	/* kill any outstanding requests, prevent new request submissions */
	for (i = 0; i < pcd->num_in_eps; i++) {
		ep = pcd->in_ep[i];
		dwc_usb3_stop_xfer(pcd, ep);
		dwc_usb3_gadget_request_nuke(pcd, ep);
		ep->dwc_ep.xfer_started = 0;
	}

	for (i = 0; i < pcd->num_out_eps; i++) {
		ep = pcd->out_ep[i];
		dwc_usb3_stop_xfer(pcd, ep);
		dwc_usb3_gadget_request_nuke(pcd, ep);
		ep->dwc_ep.xfer_started = 0;
	}

	dwc_usb3_ena_usb2_phy_suspend(pcd);
}

/**
 * Gets the current USB frame number.
 */
int dwc_usb3_pcd_get_frame_number(dwc_usb3_pcd_t *pcd)
{
	return dwc_usb3_get_frame(pcd);
}

/**
 * Initialize the PCD EP structures to their default state.
 *
 * @param pcd   The PCD structure.
 */
static void pcd_epinit(dwc_usb3_pcd_t *pcd)
{
	int num_out_eps = pcd->num_out_eps;
	int num_in_eps = pcd->num_in_eps;
	int ep_cntr, i;
    (void)i;
	dwc_usb3_pcd_ep_t *ep;

	dwc_debug2(pcd->usb3_dev, "%s(%lx)\n", __func__, (unsigned long)pcd);
	dwc_debug1(pcd->usb3_dev, "num_out_eps=%d\n", num_out_eps);
	dwc_debug1(pcd->usb3_dev, "num_in_eps=%d\n", num_in_eps);

	/*
	 * Initialize the EP0 structure
	 */
	ep = pcd->ep0;

	/* Init EP structure */
	ep->dwc_ep.dma_desc = NULL;
	ep->dwc_ep.dma_desc_dma = 0;
	ep->dwc_ep.usb_ep_desc = NULL;
	ep->dwc_ep.pcd = pcd;
	ep->dwc_ep.stopped = 1;
	ep->dwc_ep.is_in = 0;
	ep->dwc_ep.active = 0;
	ep->dwc_ep.phys = 0;
	ep->dwc_ep.num = 0;
#ifdef DWC_UTE
	pcd->txf_map[1] = 0;
#endif
	ep->dwc_ep.tx_fifo_num = 0;
	ep->dwc_ep.out_ep_reg = &pcd->out_ep_regs[0];
	ep->dwc_ep.in_ep_reg = &pcd->in_ep_regs[0];

	ep->dwc_ep.type = DWC_USB3_EP_TYPE_CONTROL;
	ep->dwc_ep.maxpacket = DWC_MAX_EP0_SIZE;
	ep->dwc_ep.send_zlp = 0;
	ep->dwc_ep.queue_sof = 0;

	pcd->ep0_req->dwc_req.buf[0] = NULL;
	pcd->ep0_req->dwc_req.bufdma[0] = 0;
	pcd->ep0_req->dwc_req.buflen[0] = 0;
	pcd->ep0_req->dwc_req.length = 0;
	pcd->ep0_req->dwc_req.actual = 0;

	/*
	 * Initialize the EP1-n structures
	 */
	ep_cntr = 0;

	for (i = 1; ep_cntr < num_out_eps; i++) {
		dwc_debug2(pcd->usb3_dev,
			   "initializing EP%d-OUT (out_ep[%d])\n", i, ep_cntr);
		ep = pcd->out_ep[ep_cntr];
		ep_cntr++;

		/* Init EP structure - but don't overwrite '.num', the gadget
		 * has already set that
		 */
		ep->dwc_ep.dma_desc = NULL;
		ep->dwc_ep.dma_desc_dma = 0;
		ep->dwc_ep.usb_ep_desc = NULL;
		ep->dwc_ep.pcd = pcd;
		ep->dwc_ep.stopped = 1;
		ep->dwc_ep.is_in = 0;
		ep->dwc_ep.active = 0;
		ep->dwc_ep.phys = (u8)ep_cntr << 1;
		ep->dwc_ep.tx_fifo_num = 0;
		ep->dwc_ep.out_ep_reg = &pcd->out_ep_regs[ep_cntr];

		/* Control until EP is activated */
		ep->dwc_ep.type = DWC_USB3_EP_TYPE_CONTROL;
		ep->dwc_ep.maxpacket = DWC_MAX_EP0_SIZE;
		ep->dwc_ep.send_zlp = 0;
		ep->dwc_ep.queue_sof = 0;
	}

	ep_cntr = 0;

	for (i = 1; ep_cntr < num_in_eps; i++) {
		dwc_debug2(pcd->usb3_dev,
			   "initializing EP%d-IN (in_ep[%d])\n", i, ep_cntr);
		ep = pcd->in_ep[ep_cntr];
		ep_cntr++;

		/* Init EP structure - but don't overwrite '.num', the gadget
		 * has already set that
		 */
		ep->dwc_ep.dma_desc = NULL;
		ep->dwc_ep.dma_desc_dma = 0;
		ep->dwc_ep.usb_ep_desc = NULL;
		ep->dwc_ep.pcd = pcd;
		ep->dwc_ep.stopped = 1;
		ep->dwc_ep.is_in = 1;
		ep->dwc_ep.active = 0;
		ep->dwc_ep.phys = (u8)ep_cntr << 1 | (u8)1U;
#ifdef DWC_UTE
		pcd->txf_map[ep_cntr << 1 | 1] = ep_cntr;
#endif
		ep->dwc_ep.tx_fifo_num = ep_cntr;
		ep->dwc_ep.in_ep_reg = &pcd->in_ep_regs[ep_cntr];

		/* Control until EP is activated */
		ep->dwc_ep.type = DWC_USB3_EP_TYPE_CONTROL;
		ep->dwc_ep.maxpacket = DWC_MAX_EP0_SIZE;
		ep->dwc_ep.send_zlp = 0;
		ep->dwc_ep.queue_sof = 0;
	}

	pcd->ep0state = EP0_IDLE;
	pcd->ep0->dwc_ep.maxpacket = DWC_MAX_EP0_SIZE;
	pcd->ep0->dwc_ep.type = DWC_USB3_EP_TYPE_CONTROL;
}

/**
 * Initialize the PCD portion of the driver.
 *
 * This routine should be called after dwc_usb3_pcd_common_init() and any
 * platform-specific initialization routines have been called.
 *
 * This routine must be called in a context that allows <em>dwc_msleep()</em>
 * to be used, because that function is called while waiting for the core to
 * come out of reset.
 *
 * @param dev   Programming view of DWC_usb3 controller.
 */
int dwc_usb3_pcd_init(dwc_usb3_device_t *dev)
{
	dwc_debug1(dev, "%s()\n", __func__);

	dev->pcd.usb3_dev = dev;
	dev->pcd.speed = USB_SPEED_UNKNOWN;

	/*
	 * Initialize EP structures
	 */
	pcd_epinit(&dev->pcd);

	/*
	 * Initialize the Core (also enables interrupts and sets Run/Stop bit)
	 */
	dwc_usb3_pcd_device_init(dev, 1, 0);

	return 0;
}

/**
 * Deinitialize the PCD portion of the driver.
 *
 * This routine should be called before any platform-specific deinitialization
 * routines and dwc_usb3_pcd_common_remove() are called.
 *
 * @param dev   Programming view of DWC_usb3 controller.
 */
void dwc_usb3_pcd_remove(dwc_usb3_device_t *dev)
{
	dwc_debug1(dev, "%s()\n", __func__);

	dwc_usb3_pcd_device_remove(dev);
}

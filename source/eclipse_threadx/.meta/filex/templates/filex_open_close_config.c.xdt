%%{
    let common = system.getScript("/common");
    let module = system.modules['/eclipse_threadx/filex/filex'];
    let mmcsd_instances = _.filter(module.$instances, function (inst) { return (inst.media == "SD" || inst.media == "EMMC");});
    let ramdisk_instances = _.filter(module.$instances, function (inst) { return (inst.media == "RAMDISK");})
%%}

/*
 * FileX
 */

FX_MEDIA gt_media[FILEX_NUM_INSTANCES];
static unsigned char gt_media_memory[FILEX_NUM_INSTANCES][16u * 1024];

% if (mmcsd_instances.length > 0) {
static fx_mmcsd_driver_data_t gt_mmcsd_driver_data[FILEX_MMCSD_NUM_INSTANCES];
% }

% for (let k = 0; k < ramdisk_instances.length; k++) {
static unsigned gt_ramdisk_`k`_mem[`ramdisk_instances[k].ramdisk_size`];
% }

% let filex_inst_ix = 0;
% let filex_inst;

void EclipseThreadx_FilexOpen(void)
{
    UINT status;

    /* Initialize FileX. */
     _fx_system_initialize();

% for (let k = 0; k < ramdisk_instances.length; k++) {
    %filex_inst = ramdisk_instances[k];
    /*************** `filex_inst.$name` *********************/
    memset(&gt_media[`filex_inst_ix`], 0, sizeof(FX_MEDIA));
    /* Try to open the media. If the media is not formatted, format and try again. */
    status = fx_media_open(&gt_media[`filex_inst_ix`], "`filex_inst.$name`", _fx_ram_driver, (void *)&gt_ramdisk_`k`_mem[0], gt_media_memory[`filex_inst_ix`], sizeof(gt_media_memory[`filex_inst_ix`]));
    if (status != FX_SUCCESS) {
% if (filex_inst.auto_format) {

        /* Format the media. */
        status = fx_media_format(&gt_media[`filex_inst_ix`], _fx_ram_driver, (void *)&gt_ramdisk_`k`_mem[0], gt_media_memory[`filex_inst_ix`], sizeof(gt_media_memory[`filex_inst_ix`]), 
                                 "`filex_inst.$name`", `filex_inst.fat_cnt`, `filex_inst.dir_entry_cnt`, `filex_inst.hidden_sec_cnt`, `filex_inst.ramdisk_size / filex_inst.sector_size`U, `filex_inst.sector_size`U, `filex_inst.sectors_per_cluster`, 1, 1);
        if (status != FX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_format() returned error %d !!!\r\n", status);
            return;
        }

        /* Open the media. */
        status =  fx_media_open(&gt_media[`filex_inst_ix`], "`filex_inst.$name`", _fx_ram_driver, (void *)&gt_ramdisk_`k`_mem[0], gt_media_memory[`filex_inst_ix`], sizeof(gt_media_memory[`filex_inst_ix`]));
        if (status != FX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_open() returned error %d !!!\r\n", status);
            return;
        }
% } else {
        if (status != FX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_open() returned error %d !!!\r\n", status);
            return;
        }  
% }
    }
    % filex_inst_ix++;
%}

% for (let k = 0; k < mmcsd_instances.length; k++) {
    %filex_inst = mmcsd_instances[k];
    /*************** `filex_inst.$name` *********************/
    gt_mmcsd_driver_data[`k`].mmcsd_hndl = MMCSD_getHandle(`filex_inst.peripheralDriver.$name`);
    if (gt_mmcsd_driver_data[`k`].mmcsd_hndl == NULL) {
        DebugP_logError("EclipseThreadx_FilexOpen() failed: MMCSD module instance %d not found !!!\r\n", `k`);
    }
    memset(&gt_media[`filex_inst_ix`], 0, sizeof(FX_MEDIA));
    /* Try to open the media. If the media is not formatted, format and try again. */
    status = fx_media_open(&gt_media[`filex_inst_ix`], "`filex_inst.$name`", _fx_mmcsd_driver, (void *)&gt_mmcsd_driver_data[`k`], gt_media_memory[`filex_inst_ix`], sizeof(gt_media_memory[`filex_inst_ix`]));
    if (status != FX_SUCCESS) {

% if (filex_inst.auto_format) {
        uint32_t blk_cnt;
        uint32_t blk_sz;

        blk_sz = MMCSD_getBlockSize(gt_mmcsd_driver_data[`k`].mmcsd_hndl);
        blk_cnt = MMCSD_getBlockCount(gt_mmcsd_driver_data[`k`].mmcsd_hndl);

        /* Format the media. */
        status = fx_media_format(&gt_media[`filex_inst_ix`], _fx_mmcsd_driver, (void *)&gt_mmcsd_driver_data[`k`], gt_media_memory[`filex_inst_ix`], sizeof(gt_media_memory[`filex_inst_ix`]), 
                                 "`filex_inst.$name`", `filex_inst.fat_cnt`, `filex_inst.dir_entry_cnt`, `filex_inst.hidden_sec_cnt`, ((uint64_t)blk_cnt * blk_sz) / `filex_inst.sector_size`U, `filex_inst.sector_size`U, `filex_inst.sectors_per_cluster`, 1, 1);
        if (status != FX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_format() returned error %d !!!\r\n", status);
            return;
        }

        /* Open the media. */
        status =  fx_media_open(&gt_media[`filex_inst_ix`], "`filex_inst.$name`", _fx_mmcsd_driver, (void *)&gt_mmcsd_driver_data[`k`], gt_media_memory[`filex_inst_ix`], sizeof(gt_media_memory[`filex_inst_ix`]));
        if (status != FX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_open() returned error %d !!!\r\n", status);
            return;
        }
% } else {
        if (status != FX_SUCCESS) {
            DebugP_logError("EclipseThreadx_FilexOpen() failed: fx_media_open() returned error %d !!!\r\n", status);
            return;
        }  
% }
    }
    % filex_inst_ix++;
%}
}

void EclipseThreadx_FilexClose(void)
{
    /* Nothing to do. */
}
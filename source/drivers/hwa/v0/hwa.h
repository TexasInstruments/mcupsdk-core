/*
 *  Copyright (C) 2021 Texas Instruments Incorporated
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/**
 *  \file     hwa.h
 *
 *  \brief    HWA driver interface for HWA2.0
 *
 */
/** \defgroup DRV_HWA_MODULE APIs for HWA
 *  \ingroup DRV_MODULE
 *
 *  The HWA driver provides APIs to configure, trigger and obtain results from the
 *  hardware accelerator
 */
/**
 *  \defgroup HWA_DRIVER_EXTERNAL_FUNCTION            HWA Driver External Functions
 *  \ingroup DRV_HWA_MODULE
 *  \brief
 *   The section has a list of all the exported API which the applications need to
 *   invoke in order to use the driver
 */
/**
 *  \defgroup HWA_DRIVER_EXTERNAL_DATA_STRUCTURE      HWA Driver External Data Structures
 *  \ingroup DRV_HWA_MODULE
 *  \brief
 *   The section has a list of all the data structures which are exposed to the application
 */
/**
 *  \defgroup HWA_DRIVER_ERROR_CODE                   HWA Driver Error Codes
 *  \ingroup DRV_HWA_MODULE
 *  \brief
 *   The section has a list of all the error codes which are generated by the HWA Driver
 *   module
 */

#ifndef HWA_H_
#define HWA_H_

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <drivers/hw_include/csl_complex_math_types.h>
#include <kernel/dpl/HwiP.h>
#include <drivers/hw_include/cslr_hwa.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ========================================================================== */
/*                             Macros & Typedefs                              */
/* ========================================================================== */

/** \brief transfer the CPU address to HWA address */
#define HWADRV_ADDR_TRANSLATE_CPU_TO_HWA(x)  (uint32_t)((uint32_t)(x) & 0x000FFFFFU)

/** \addtogroup HWA_DRIVER_ERROR_CODE
 *
 * \brief  HWA driver Error Codes
 *
 * @{
 */
/** \brief HWA driver error base */
#define HWA_ERRNO_BASE                                  (-2800)
/** \brief Error Code: Invalid argument */
#define HWA_EINVAL                                      (HWA_ERRNO_BASE-1)
/** \brief Error Code: Operation cannot be done as HWA_init is not done */
#define HWA_ENOINIT                                     (HWA_ERRNO_BASE-2)
/** \brief Error Code: input argument out of range */
#define HWA_EOUTOFRANGE                                 (HWA_ERRNO_BASE-3)
/** \brief Error Code: out of memory */
#define HWA_EOUTOFMEM                                   (HWA_ERRNO_BASE-4)
/** \brief Error Code: feature not supported */
#define HWA_ENOTSUPP                                    (HWA_ERRNO_BASE-5)
/** \brief Error Code: channel or resource in use */
#define HWA_EINUSE                                      (HWA_ERRNO_BASE-6)
/** \brief Error Code: address is not aligned to the expected boundary */
#define HWA_ENOTALIGNED                                 (HWA_ERRNO_BASE-7)
/** \brief Error Code: Invalid argument: paramset Start/Stop Idx and numLoops in common register */
#define HWA_EINVAL_COMMON_REGISTER_PARAMSET             (HWA_ERRNO_BASE-8)
/** \brief Error Code: Invalid argument: paramset Start/Stop Idx and numLoops for context switching in common register */
#define HWA_EINVAL_COMMON_REGISTER_PARAMSET_ALT         (HWA_ERRNO_BASE-9)
/** \brief Error Code: Invalid argument: for FFT config in common register */
#define HWA_EINVAL_COMMON_REGISTER_FFTCONFIG            (HWA_ERRNO_BASE-10)
/** \brief Error Code: Invalid argument: for DC estimation in common register */
#define HWA_EINVAL_COMMON_REGISTER_DCEST                (HWA_ERRNO_BASE-11)
/** \brief Error Code: Invalid argument: for CFAR config in common register */
#define HWA_EINVAL_COMMON_REGISTER_CFAR                 (HWA_ERRNO_BASE-12)
/** \brief Error Code: Invalid argument: for interference localization/mitigation in common register */
#define HWA_EINVAL_COMMON_REGISTER_INTERFERENCE         (HWA_ERRNO_BASE-13)
/** \brief Error Code: Invalid argument: for complex multiply in common register */
#define HWA_EINVAL_COMMON_REGISTER_COMPLEXMULT          (HWA_ERRNO_BASE-14)
/** \brief Error Code: Invalid argument: for channel combine in common register */
#define HWA_EINVAL_COMMON_REGISTER_CHANCOMB             (HWA_ERRNO_BASE-15)
/** \brief Error Code: Invalid argument: for zero insert in common register */
#define HWA_EINVAL_COMMON_REGISTER_ZEROINSERT           (HWA_ERRNO_BASE-16)
/** \brief Error Code: Invalid argument: for advanced statistics in common register */
#define HWA_EINVAL_COMMON_REGISTER_ADVSTAT              (HWA_ERRNO_BASE-17)
/** \brief Error Code: Invalid argument: for compress/decompression in common register */
#define HWA_EINVAL_COMMON_REGISTER_COMPRESS             (HWA_ERRNO_BASE-18)
/** \brief Error Code: Invalid argument: for local maximum in common register */
#define HWA_EINVAL_COMMON_REGISTER_LOCALMAXIMUM         (HWA_ERRNO_BASE-19)
/** \brief Error Code: Invalid argument: general config in paramset  */
#define HWA_EINVAL_PARAMSET_GENERALCONFIG               (HWA_ERRNO_BASE - 20)
/** \brief Error Code: Invalid argument: source(input formatter) in paramset */
#define HWA_EINVAL_PARAMSET_SOURCE                      (HWA_ERRNO_BASE - 21)
/** \brief Error Code: Invalid argument: destination(output formatter) in paramset */
#define HWA_EINVAL_PARAMSET_DEST                        (HWA_ERRNO_BASE - 22)
/** \brief Error Code: Invalid argument: src and dst address in paramset */
#define HWA_EINVAL_PARAMSET_SRCDST_ADDRESS              (HWA_ERRNO_BASE - 23)
/** \brief Error Code: Invalid argument: FFT mode: general config in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_GENERALCONFIG       (HWA_ERRNO_BASE - 24)
/** \brief Error Code: Invalid argument: FFT mode: FFT size in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_SIZE                (HWA_ERRNO_BASE - 25)
/** \brief Error Code: Invalid argument: FFT mode: post processing in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_POSTPROC            (HWA_ERRNO_BASE - 26)
/** \brief Error Code: Invalid argument: FFT mode: pre-processing in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_PREPROC             (HWA_ERRNO_BASE - 27)
/** \brief Error Code: Invalid argument: FFT mode: pre-processing interference localization/statistics/mitigation in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_PREPROC_INTERF      (HWA_ERRNO_BASE - 28)
/** \brief Error Code: Invalid argument: FFT mode: pre-processing complex multiply block in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_PREPROC_COMPLEXMULT (HWA_ERRNO_BASE - 29)
/** \brief Error Code: Invalid argument: CFAR mode: general configuration in paramset */
#define HWA_EINVAL_PARAMSET_CFARMODE_GENERALCONFIG      (HWA_ERRNO_BASE - 30)
/** \brief Error Code: Invalid argument: CFAR mode: CFAR-OS configuration in paramset */
#define HWA_EINVAL_PARAMSET_CFARMODE_OSCONFIG           (HWA_ERRNO_BASE - 31)
/** \brief Error Code: Invalid argument: CFAR mode: CFAR-CA configuration in paramset */
#define HWA_EINVAL_PARAMSET_CFARMODE_CACONFIG           (HWA_ERRNO_BASE - 32)
/** \brief Error Code: Invalid argument: compress/decompress mode: compress/decompress configuration in paramset */
#define HWA_EINVAL_PARAMSET_COMPRESSMODE                (HWA_ERRNO_BASE - 33)
/** \brief Error Code: Invalid argument: local maxima mode: local maxima configuration in paramset */
#define HWA_EINVAL_PARAMSET_LOCALMAXMODE                (HWA_ERRNO_BASE - 34)
/** \brief Error Code: if paramset interrupt is enabled, polling should be disabled */
#define HWA_PARAMSET_POLLINGNOTALLOWED                  (HWA_ERRNO_BASE - 35)
/** @} */

/** \brief Number of RX channels in pre-processing block */
#define HWA_NUM_RXCHANNELS              (12U)
/** \brief Number of programmable array of window parameters in interference mitigation block */
#define HWA_NUM_INTERFMITG_WINARRAY     (5U)
/** \brief The length of BPM Pattern sequence in words */
#define HWA_BPMPATTERN_LENGTH_INWORDS   (8U)
/** \brief The length of channel combining vector in words */
#define HWA_CHANCOMB_LENGTH_INWORDS     (8U)
/** \brief The length of zero insert mask in words */
#define HWA_ZEROINSERT_LENGTH_INWORDS   (8U)
/** \brief  The number of RAM types in HWA */
#define HWA_NUM_RAMS                    (10U)
/** \brief  The maximum number of loops in HWA */
#define HWA_MAXNUM_LOOPS                (4095U)
/** \brief  The length of EGE compression/decompression K-paramseters array */
#define HWA_CMP_K_ARR_LEN               (8U)

/** \addtogroup HWA_DRIVER_EXTERNAL_DATA_STRUCTURE
 @{ */
/**
 * \defgroup HWA_MACROS     HWA_MACROS
 * \brief Lists all the macros used in HWA driver
 * @{
 */
/**
 * \defgroup HWA_INTERRUPT_PRIORITY      HWA_INTERRUPT_PRIORITY
 * \brief HWA interrupt default priority, applied only to the processors, which support hardware priority, e.g R5F
 * @{
 */
/** \brief  Default HWA background thread done interrupt priority */
#define HWA_DONE_INTERRUPT_PRIORITY             (1U)
/** \brief  Default HWA background thread done interrupt priority */
#define HWA_ALTDONE_INTERRUPT_PRIORITY          (1U)
/** \brief  Default HWA paramset done interrupt 1 priority */
#define HWA_PARAMSETDONE_INTERRUPT1_PRIORITY    (1U)
/** \brief  Default HWA paramset done interrupt 2 priority */
#define HWA_PARAMSETDONE_INTERRUPT2_PRIORITY    (1U)
/** \brief  Default HWA local ram error interrupt priority */
#define HWA_LOCAL_RAM_ERR_PRIORITY              (1U)
/** @} */

/**
 * \defgroup HWA_FEATURE_BIT        HWA_FEATURE_BIT
 * \brief  General macro to use for enable/disable bits
 * @{
 */
#define HWA_FEATURE_BIT_ENABLE          ((uint8_t)1U)       /**<  Enable: use this macro to enable any feature bit */
#define HWA_FEATURE_BIT_DISABLE         ((uint8_t)0U)       /**<  Disable: use this macro to disable any feature bit */
/** @} */

/**
 * \defgroup HWA_SAMPLES_WIDTH      HWA_SAMPLES_WIDTH
 * \brief  Macros that define values for 16bit or 32bit width of input/output samples
 * @{
 */
#define HWA_SAMPLES_WIDTH_16BIT         ((uint8_t)0U)      /**<  sample width is 16 bit */
#define HWA_SAMPLES_WIDTH_32BIT         ((uint8_t)1U)      /**<  sample width is 32 bit */
/** @} */

/**
 * \defgroup HWA_SAMPLES_FORMAT     HWA_SAMPLES_FORMAT
 * \brief  Macros that define values for real/complex format of input/output samples
 * @{
 */
#define HWA_SAMPLES_FORMAT_COMPLEX      ((uint8_t)0U)      /**<  complex samples (I/Q) */
#define HWA_SAMPLES_FORMAT_REAL         ((uint8_t)1U)      /**<  real samples (I) */
/** @} */

/**
 * \defgroup HWA_SAMPLES_SIGN       HWA_SAMPLES_SIGN
 * \brief  Macros that define values for signed/unsigned property of input/output samples
 * @{
 */
#define HWA_SAMPLES_UNSIGNED            ((uint8_t)0U)      /**<  unsigned samples */
#define HWA_SAMPLES_SIGNED              ((uint8_t)1U)      /**<  signed samples */
/** @} */

/**
 * \defgroup HWA_WINDOW_SYMM        HWA_WINDOW_SYMM
 * \brief  Macros that define values for symmetric/non-symmetric property of the FFT window
 * @{
 */
#define HWA_FFT_WINDOW_NONSYMMETRIC     ((uint8_t)0U)      /**<  non-symmetric window for FFT windowing operation */
#define HWA_FFT_WINDOW_SYMMETRIC        ((uint8_t)1U)      /**<  symmetric window for FFT windowing operation
                                                                 Only the first half the window coefficients are expected
                                                                 to be present in the window RAM. The same coefficients are read in
                                                                 reverse direction for the second half. */
/** @} */

/**
 * \defgroup HWA_FFT_WINDOW_INTERPOLATE_MODE        HWA_FFT_WINDOW_INTERPOLATE_MODE
 * \brief  Macros that define values for interpolation property of the FFT window to
 *           achieve larger FFT size using stitching
 * @{
 */
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_NONE    ((uint8_t)0U)      /**<  no window interpolation is enabled */
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_4K      ((uint8_t)2U)      /**<  window interpolation to achieve 4K FFT */
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_8K      ((uint8_t)1U)      /**<  window interpolation to achieve 8K FFT */
/** @} */

/**
 * \defgroup HWA_FFT_MODE_MAGNITUDE_LOG2        HWA_FFT_MODE_MAGNITUDE_LOG2
 * \brief  Macros that define values for enabling/disabling the magnitude and log2 computation in FFT block
 * @{
 */
#define HWA_FFT_MODE_MAGNITUDE_LOG2_DISABLED        ((uint8_t)0U)        /**<  magnitude disabled and log2 disabled */
#define HWA_FFT_MODE_MAGNITUDE_ONLY_ENABLED         ((uint8_t)2U)        /**<  magnitude enabled and log2 disabled */
#define HWA_FFT_MODE_MAGNITUDE_LOG2_ENABLED         ((uint8_t)3U)        /**<  magnitude and log2 enabled */
/** @} */

/**
 * \defgroup HWA_FFT_MODE_OUTPUT        HWA_FFT_MODE_OUTPUT
 * \brief  Macros that define values for the various outputs of the FFT block
 * @{
 */
#define HWA_FFT_MODE_OUTPUT_DEFAULT                 ((uint8_t)0U)    /**<  Default output (i.e., main data path output is sent out - eg. FFT or Log-Mag output) */
#define HWA_FFT_MODE_OUTPUT_MAX_STATS               ((uint8_t)2U)    /**<  Statistics output - Max statistics is sent out (Max value on the I arm, Max index on the Q arm) */
#define HWA_FFT_MODE_OUTPUT_SUM_STATS               ((uint8_t)3U)    /**<  Statistics output - Sum statistics is sent out */
/** @} */

/**
 * \defgroup HWA_NOISE_AVG_MODE_CFAR        HWA_NOISE_AVG_MODE_CFAR
 * \brief  Macros that define values for CFAR Noise Averaging mode
 * @{
 */
#define HWA_NOISE_AVG_MODE_CFAR_CA                  ((uint8_t)0U)      /**<  cumulative average of left+right */
#define HWA_NOISE_AVG_MODE_CFAR_CAGO                ((uint8_t)1U)      /**<  cumulative average of the side (left or right) that is greater */
#define HWA_NOISE_AVG_MODE_CFAR_CASO                ((uint8_t)2U)      /**<  cumulative average of the side (left or right) that is smaller */
#define HWA_NOISE_AVG_MODE_CFAR_OS                  ((uint8_t)3U)      /**<  CFAR OS */
/** @} */

/**
 * \defgroup HWA_TRIG_MODE      HWA_TRIG_MODE
 * \brief  Macros that define values for the trigger mode of HWA paramsets
 * @{
 */
#define HWA_TRIG_MODE_IMMEDIATE                     ((uint8_t)0U)      /**<  state machine reads and immediately executes that paramset */
#define HWA_TRIG_MODE_SOFTWARE                      ((uint8_t)1U)      /**<  state machine reads the paramset but waits for s/w trigger before executing that paramset */
#define HWA_TRIG_MODE_RESERVED1                     ((uint8_t)2U)      /**<  Reserved */
#define HWA_TRIG_MODE_DMA                           ((uint8_t)3U)      /**<  state machine reads the paramset but waits for DMA trigger before executing that paramset */
#define HWA_TRIG_MODE_HARDWARE                      ((uint8_t)4U)      /**<  Hardware based trigger #1 */
#define HWA_TRIG_MODE_RESERVED2                     ((uint8_t)5U)      /**<  Hardware based trigger #2 */
#define HWA_TRIG_MODE_RESERVED3                     ((uint8_t)6U)      /**<  Hardware based trigger #3 */
#define HWA_TRIG_MODE_M4CONTROL                     ((uint8_t)7U)      /**<  equivalent to software trigger, M4 Micro-controller based trigger */
/** @} */

/**
 * \defgroup HWA_CONTEXTSWITCH_TRIG_MODE      HWA_CONTEXTSWITCH_TRIG_MODE
 * \brief  Macros that define values for the trigger mode of HWA paramsets
 * @{
*/
#define HWA_CONTEXTSWITCH_TRIG_MODE_DMA             ((uint8_t)3U)      /**<  state machine reads the paramset but waits for DMA trigger before executing that paramset */
#define HWA_CONTEXTSWITCH_TRIG_MODE_HARDWARE        ((uint8_t)4U)      /**<  Hardware based trigger #1 */
#define HWA_CONTEXTSWITCH_TRIG_MODE_SOFTWARE        ((uint8_t)5U)      /**<  software trigger */
/** @} */

/**
 * \defgroup HWA_THREAD      HWA_THREAD
 * \brief  Macros that define values for the trigger mode of HWA paramsets
 * @{
 */
#define HWA_THREAD_BACKGROUNDCONTEXT        ((uint8_t)0U)      /**< HWA background (low-priority thread) */
#define HWA_THREAD_ALTCONTEXT               ((uint8_t)1U)      /**< HWA context switch, ALT (high-priority) thread */
/** @} */

/**
 * \defgroup HWA_ACCELMODE      HWA_ACCELMODE
 * \brief  Macros that define values for the operational/accelerator mode of HWA
 * @{
 */
#define HWA_ACCELMODE_FFT                           ((uint8_t)0U)      /**<  HWA operational mode is FFT */
#define HWA_ACCELMODE_CFAR                          ((uint8_t)1U)      /**<  HWA operational mode is CFAR */
#define HWA_ACCELMODE_COMPRESS                      ((uint8_t)2U)      /**<  HWA operational mode is compression/decompression */
#define HWA_ACCELMODE_LOCALMAX                      ((uint8_t)3U)      /**<  HWA operational mode is local maxima */
#define HWA_ACCELMODE_NONE                          ((uint8_t)7U)      /**<  HWA dummy operational mode: use this for waiting for multiple triggers */
/** @} */

/**
 * \defgroup HWA_CFAR_OPER_MODE     HWA_CFAR_OPER_MODE
 * \brief  Macros that define values for the combination of CFAR operational mode (log, mag, mag sqr)
 *           and input samples type (real, complex)
 *
 *
 *Value  |CFAR_LOG_MODE  |CFAR_INP_MODE  |CFAR_ABS_MODE |register bits|description
 *-------| --------------|---------------|--------------|-------------|-------------
 * 0     |              1|              1|dont care     | 1100        |input are real, log-magnitude samples and no operation is needed inside HWA
 * 1     |              1|              0|3             | 0111        |input are complex samples and HWA should perform log-magnitude operation
 * 2     |              0|              1|dont care     | 1000        |input are real, magnitude samples and no operation is needed inside HWA
 * 3     |              0|              0|2             | 0010        |input are complex samples and HWA should perform magnitude operation
 * 4     |              0|              1|dont care     | 1000        |input are real, magnitude-sqr samples and no operation is needed inside HWA
 * 5     |              0|              0|0             | 0000        |input are complex samples and HWA should perform magnitude-sqr operation
 * 6     |              0|              0|3             | 0110        |input are complex samples and HWA should perform log-magnitude with linear cfar operation
 * @{
 */
#define HWA_CFAR_OPER_MODE_LOG_INPUT_REAL           0U     /**<  input are real samples in log scale and no operation is needed inside HWA */
#define HWA_CFAR_OPER_MODE_LOG_INPUT_COMPLEX        1U     /**<  input are complex samples and HWA should perform log-magnitude operation log cfar */
#define HWA_CFAR_OPER_MODE_MAG_INPUT_REAL           2U     /**<  input are real, magnitude samples and no operation is needed inside HWA */
#define HWA_CFAR_OPER_MODE_MAG_INPUT_COMPLEX        3U     /**<  input are complex samples and HWA should perform magnitude operation */
#define HWA_CFAR_OPER_MODE_MAG_SQR_INPUT_REAL       4U     /**<  input are real, magnitude-sqr samples and no operation is needed inside HWA */
#define HWA_CFAR_OPER_MODE_MAG_SQR_INPUT_COMPLEX    5U     /**<  input are complex samples and HWA should perform magnitude-sqr operation */
#define HWA_CFAR_OPER_MODE_LOG_INPUT_COMPLEX_LINEARCFAR    6U     /**<  input are complex samples. and HWA should perform log-magnitude, linear cfar */
/** @} */

/**
 * \defgroup HWA_CFAR_OUTPUT_MODE       HWA_CFAR_OUTPUT_MODE
 * \brief  Macros that define values for the output of CFAR block
 *
 * @details
 *             Value  |CFAR_ADV_ | CFAR_OUT|  I channel                           | Q channel
                      | OUT_MODE | _MODE   |                                      |
 *             0      |  0       |  00     | Noise average values for all cells   | Cell under test
 *             1      |  0       |  01     | Noise average values for all cells   | Binary detection flag
 *             2      |  0       |  10     | Peak Index                           | Surrounding noise value
 *             3      |  0       |  11     | Peak Index                           | Cell under test value
 *             4      |  1       |  01     | Input Array(I channel)And'ed with    | Input Array (Q channel) And'ed
                                           | binary detection result flag         | with binary detection result flag
 * @{
 */
#define HWA_CFAR_OUTPUT_MODE_I_nAVG_ALL_Q_CUT                   ((uint8_t)0U)     /**<  I channel=Noise average values for all cells;
                                                                                    Q channel=Cell under test (CUT) */
#define HWA_CFAR_OUTPUT_MODE_I_nAVG_ALL_Q_DET_FLAG              ((uint8_t)1U)     /**<  I channel=Noise average values for all cells;
                                                                                      Q channel=Binary detection flag */
#define HWA_CFAR_OUTPUT_MODE_I_PEAK_IDX_Q_NEIGHBOR_NOISE_VAL    ((uint8_t)2U)     /**<  I channel=Peak Index;
                                                                                        Q channel=Surrounding noise value */
#define HWA_CFAR_OUTPUT_MODE_I_PEAK_IDX_Q_CUT                   ((uint8_t)3U)     /**<  I channel=Peak Index;
                                                                                      Q channel=Cell under test (CUT) */
#define HWA_CFAR_OUTPUT_MODE_FILTER_LARGE_PEAK                  ((uint8_t)4U)     /**<  I channel = input Array (I channel) And'ed with binary detection result */
                                                                                  /**<  Q channel = input Array (Q channel) And'ed with binary detection result */
/** @} */

/**
 * \defgroup HWA_RAM_TYPE       HWA_RAM_TYPE
 * \brief  Macros that define values for the ramType argument of HWA_configRam() function.
 * @{
 */
#define HWA_RAM_TYPE_WINDOW_RAM             ((uint8_t)0U)         /**<  WINDOW RAM for windowing operation */
#define HWA_RAM_TYPE_VECTORMULTIPLY_RAM     ((uint8_t)1U)         /**<  Internal RAM for Vector Multiplication mode 1 and mode 2 */
#define HWA_RAM_TYPE_LUT_FREQ_DEROTATE_RAM  ((uint8_t)2U)         /**<  RAM for LUT based frequency detoration */
#define HWA_RAM_TYPE_SHUFFLE_RAM            ((uint8_t)3U)         /**<  shuffle LUT for shuffled addressing */
#define HWA_RAM_TYPE_HIST_THRESH_RAM        ((uint8_t)4U)         /**<  CDF threshold computation */
#define HWA_RAM_TYPE_2DSTAT_ITER_VAL        ((uint8_t)5U)         /**<  2-D maximum values of each iteration */
#define HWA_RAM_TYPE_2DSTAT_ITER_IDX        ((uint8_t)6U)         /**<  2-D maximum location of each iteration */
#define HWA_RAM_TYPE_2DSTAT_SAMPLE_VAL        ((uint8_t)7U)         /**<  2-D maximum values corresponding to each sample index */
#define HWA_RAM_TYPE_2DSTAT_SAMPLE_IDX        ((uint8_t)8U)         /**<  2-D maximum locations corresponding to each sample index */
#define HWA_RAM_TYPE_HISTOGRAM_RAM          ((uint8_t)9U)         /**<  histogram output corresponiding to each sample index */
/** @} */

/**
 * \defgroup HWA_CLIPREG_TYPE       HWA_CLIPREG_TYPE
 * \brief  Macros that define clip status registers for HWA_readClipStatus and HWA_clearClipStatus functions.
 * @{
 */
#define HWA_CLIPREG_TYPE_DCACC                          ((uint8_t)0U)         /**<  clip status for both I/Q of DC accumulators 0 to 11 */
#define HWA_CLIPREG_TYPE_DCEST                          ((uint8_t)1U)         /**<  clip status of DC estimates (both I & Q combined) */
#define HWA_CLIPREG_TYPE_DCSUB                          ((uint8_t)2U)         /**<  DC subtraction clip status */
#define HWA_CLIPREG_TYPE_INTFSTATS_MAGACC               ((uint8_t)3U)         /**<  interference magnitude accumulator clip status */
#define HWA_CLIPREG_TYPE_INTFSTATS_MAGDIFFACC           ((uint8_t)4U)         /**<  Interference magnitue difference accumulator clip status */
#define HWA_CLIPREG_TYPE_INTFSTATS_MAGTHRESHOLD         ((uint8_t)5U)         /**<  Interference magnitude threshold Clip status */
#define HWA_CLIPREG_TYPE_INTFSTATS_MAGDIFFTHRESHOLD     ((uint8_t)6U)         /**<  Interference magnitude threshold Clip status */
#define HWA_CLIPREG_TYPE_INTFSTATS_MAGSUM               ((uint8_t)7U)         /**<  Interference magnitude sum clip status */
#define HWA_CLIPREG_TYPE_INTFSTATS_MAGDIFFSUM           ((uint8_t)8U)         /**<  Interference magnitude diff sum clip status */
#define HWA_CLIPREG_TYPE_TWIDINCR_DELTAFRAC             ((uint8_t)9U)         /**<  the clip status for TWID_INCR_DELTA_FRAC accumulator */
#define HWA_CLIPREG_TYPE_CHANCOMB                       ((uint8_t)10U)        /**<  the clip status of the channel combination */
#define HWA_CLIPREG_TYPE_FFT                            ((uint8_t)11U)        /**<  FFT Clip Status */
#define HWA_CLIPREG_TYPE_INPUTFORMAT                    ((uint8_t)12U)        /**<  Indicates the input formatter clip status */
#define HWA_CLIPREG_TYPE_OUTPUTFORMAT                   ((uint8_t)13U)        /**<  output formatter clip status */
/** @} */

/**
 * \defgroup HWA_ACCUMULATORREG_TYPE       HWA_ACCUMULATORREG_TYPE
 * \brief  Macros that define values for different type of accumulator registers of HWA_readAccumulatorReg() function.
 * @{
*/
#define HWA_ACCUMULATORREG_TYPE_DC                      ((uint8_t)0U)         /**<  DC accumulator */
#define HWA_ACCUMULATORREG_TYPE_INTERF_MAG              ((uint8_t)1U)         /**<  interference magnitude accumulator */
#define HWA_ACCUMULATORREG_TYPE_INTERF_MAGDIFF          ((uint8_t)2U)         /**<  interference magnitude difference accumulator */
#define HWA_ACCUMULATORREG_TYPE_INTERF                  ((uint8_t)3U)          /**< for reset both INTERF_MAG and INTERF_MAGDIFF accumulators */
/** @} */

/**
 * \defgroup HWA_INTERFERENCE_THRESHOLD_TYPE       HWA_INTERFERENCE_THRESHOLD_TYPE
 * \brief  Macros that define values for different type of accumulator registers of HWA_readAccumulatorReg() function.
 * @{
 */
#define HWA_INTERFERENCE_THRESHOLD_TYPE_MAG             ((uint8_t)0U)         /**<  interference mag threshold register */
#define HWA_INTERFERENCE_THRESHOLD_TYPE_MAGDIFF         ((uint8_t)1U)         /**<  interference magdiff threshold register */
/** @} */

/**
 * \defgroup HWA_PARAMDONE_INTERRUPT_TYPE       HWA_PARAMDONE_INTERRUPT_TYPE
 * \brief  Macros that define values for the destination of interrupt (CPU or DMA)
             when the paramset is completed. The interrupt type HWA_PARAMDONE_INTERRUPT_TYPE_CPU
             may not be supported on all versions of the IP - see \ref HWA_Attrs::isConcurrentAccessAllowed.
 * @{
 */
#define HWA_PARAMDONE_INTERRUPT_TYPE_CPU_INTR1        ((uint8_t)1U)   /**<  CPU Interrupt 1 when paramset is completed */
#define HWA_PARAMDONE_INTERRUPT_TYPE_CPU_INTR2        ((uint8_t)2U)   /**<  CPU Interrupt 2 when paramset is completed */
#define HWA_PARAMDONE_INTERRUPT_TYPE_DMA              ((uint8_t)4U)   /**<  Trigger DMA when paramset is completed */
/** @} */

/**
 * \defgroup HWA_COMMONCONFIG_MASK      HWA_COMMONCONFIG_MASK
 * \brief  Macros that define values to use for \ref HWA_CommonConfig::configMask when specifying which values in
 *           the \ref HWA_CommonConfig are valid.
 * @{
 */
#define HWA_COMMONCONFIG_MASK_STATEMACHINE_CFG         ((uint64_t)0x00000001U)      /**<  Use when \ref HWA_CommonConfig::numLoops, \ref HWA_CommonConfig::paramStartIdx and \ref HWA_CommonConfig::paramStopIdx are valid */
#define HWA_COMMONCONFIG_MASK_STATEMACHINE_CFG_ALT     ((uint64_t)0x00000002U)      /**<  Use when \ref HWA_CommonConfig::numLoopsALT, \ref HWA_CommonConfig::paramStartIdxALT and \ref HWA_CommonConfig::paramStopIdxALT are valid */
#define HWA_COMMONCONFIG_CONTEXTSWITCH_TRIG_CFG        ((uint64_t)0x00000004U)      /**<  Use when \ref HWA_CommonConfig::contextswitchTriggerMode, and \ref HWA_CommonConfig::contextswitchTriggerSrc are valid */
#define HWA_COMMONCONFIG_MASK_BPMCFG                   ((uint64_t)0x00000008U)      /**<  Use when \ref HWA_CommonConfig::bpmRate and \ref HWA_CommonConfig::bpmPattern are valid */
#define HWA_COMMONCONFIG_MASK_TWIDDITHERENABLE         ((uint64_t)0x00000010U)      /**<  Use when \ref HWA_CommonConfig::twidDitherEnable is valid */
#define HWA_COMMONCONFIG_MASK_LFSRSEED                 ((uint64_t)0x00000020U)      /**<  Use when \ref HWA_CommonConfig::lfsrSeed is valid */
#define HWA_COMMONCONFIG_MASK_FFTSUMDIV                ((uint64_t)0x00000040U)      /**<  Use when \ref HWA_CommonConfig::fftSumDiv is valid */
#define HWA_COMMONCONFIG_MASK_CFARTHRESHOLDSCALE       ((uint64_t)0x00000080U)      /**<  Use when \ref HWA_CommonConfig::thresholdScale is valid */
#define HWA_COMMONCONFIG_MASK_DCEST_SCALESHIFT         ((uint64_t)0x00000100U)      /**<  use when \ref HWA_CommonConfig::scale and\ref HWA_CommonConfig::shift are valid */
#define HWA_COMMONCONFIG_MASK_DCSUB_SWVAL              ((uint64_t)0x00000200U)      /**<  use when \ref HWA_CommonConfig::swIVal and \ref HWA_CommonConfig::swQVal are valid */
#define HWA_COMMONCONFIG_MASK_INTERFMAG_THRESHOLD      ((uint64_t)0x00000400U)      /**<  Use when \ref HWA_CommonConfig::thresholdMagSw is valid */
#define HWA_COMMONCONFIG_MASK_INTERFMAGDIFF_THRESHOLD  ((uint64_t)0x00000800U)      /**<  Use when \ref HWA_CommonConfig::thresholdMagDiffSw is valid */
#define HWA_COMMONCONFIG_MASK_INTERFSUM_MAG            ((uint64_t)0x00001000U)      /**<  Use when \ref HWA_CommonConfig::sumMagScale and \ref HWA_CommonConfig::sumMagShift are valid */
#define HWA_COMMONCONFIG_MASK_INTERFSUM_MAGDIFF        ((uint64_t)0x00002000U)      /**<  Use when \ref HWA_CommonConfig::sumMagDiffScale and \ref HWA_CommonConfig::sumMagDiffShift are valid */
#define HWA_COMMONCONFIG_MASK_COMPLEXMULT_SCALEARRAY   ((uint64_t)0x00004000U)      /**<  Use when \ref HWA_CommonConfig::Iscale and \ref HWA_CommonConfig::Qscale are valid,
                                                                                        \ref HWA_ComplexMultiply::cmultMode = HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT, or HWA_COMPLEX_MULTIPLY_MODE_VEC_MULT,
                                                                                        and with HWA_ComplexMultiply:scaleCmultScaleEn = 1 or HWA_ComplexMultiply::cmultScaleEn=1 */
#define HWA_COMMONCONFIG_MASK_COMPLEXMULT_SCALECONST   ((uint64_t)0x00008000U)      /**<  Use when \ref HWA_CommonConfig::Iscale and \ref HWA_CommonConfig::Qscale are valid,
                                                                                         \ref HWA_ComplexMultiply::cmultMode = HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT, or HWA_COMPLEX_MULTIPLY_MODE_VEC_MULT,
                                                                                         and with \ref HWA_ComplexMultiply::scaleCmultScaleEn = 0 or \ref HWA_ComplexMultiply::cmultScaleEn = 0 */
#define HWA_COMMONCONFIG_MASK_RECWIN_RESET             ((uint64_t)0x00010000U)      /**<  Use when \ref HWA_CommonConfig::recWindowReset is valid */
#define HWA_COMMONCONFIG_MASK_TWIDINCR_DELTA_FRAC      ((uint64_t)0x00020000U)      /**<  Use when \ref HWA_CommonConfig::twiddleDeltaFrac is valid,
                                                                                          if \ref HWA_ComplexMultiply::cmultMode = HWA_COMPLEX_MULTIPLY_MODE_FREQSHIFT_FREQINCRE */
#define HWA_COMMONCONFIG_MASK_CHANCOMB_VEC_SIZE         ((uint64_t)0x00400000U)      /**<  Use when \ref HWA_CommonConfig::vector and \ref HWA_CommonConfig::size are valid */
#define HWA_COMMONCONFIG_MASK_ZEROINSERT_NUM_MASK       ((uint64_t)0x00800000U)      /**<  Use when \ref HWA_CommonConfig::number and \ref HWA_CommonConfig::mask are valid */
#define HWA_COMMONCONFIG_MASK_MAX2D_OFFSETBOTHDIM       ((uint64_t)0x01000000U)      /**<  Use when \ref HWA_CommonConfig::max2DoffsetDim1 and \ref HWA_CommonConfig::max2DoffsetDim2 are valid */
#define HWA_COMMONCONFIG_MASK_CDFCNT_THRESHOLD          ((uint64_t)0x02000000U)      /**<  Use when \ref HWA_CommonConfig::cdfCntThresh is valid */
#define HWA_COMMONCONFIG_MASK_LOCALMAXDIMB_THRESHOLDSW  ((uint64_t)0x04000000U)      /**<  Use when \ref HWA_CommonConfig::dimBThreshold is valid, if \ref HWA_AccelModeLocalMax::thresholdMode is set HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCREG or HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCRAM  */
#define HWA_COMMONCONFIG_MASK_LOCALMAXDIMC_THRESHOLDSW  ((uint64_t)0x08000000U)      /**<  Use when \ref HWA_CommonConfig::dimCThreshold is valid, if \ref HWA_AccelModeLocalMax::thresholdMode is set HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCREG or HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCREG  */
#define HWA_COMMONCONFIG_MASK_LOCALMAXDIMBTHRESH_OFFSET ((uint64_t)0x10000000U)      /**<  Use when \ref HWA_CommonConfig::dimBBaseAddress is valid, dimension B threshold is came from RAM, if \ref HWA_AccelModeLocalMax::thresholdMode is set HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCRAM or HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCREG */
#define HWA_COMMONCONFIG_MASK_LOCALMAXDIMCTHRESH_OFFSET ((uint64_t)0x20000000U)      /**<  Use when \ref HWA_CommonConfig::dimCBaseAddress is valid, dimension C threshold is came from RAM, if \ref HWA_AccelModeLocalMax::thresholdMode is set HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCRAM or HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCRAM */
#define HWA_COMMONCONFIG_MASK_INTERF_MITG_WINDOW_PARAM  ((uint64_t)0x40000000U)      /**<  Use when \ref HWA_CommonConfig::mitigationWindowParam array is valid */
#define HWA_COMMONCONFIG_MASK_EGECOMRESS_KPARAM         ((uint64_t)0x80000000U)      /**<  Use when \ref HWA_CommonConfig::EGEKparam array is valid */

#if defined (SOC_AWR294X)
#define HWA_COMMONCONFIG_MASK_CMP_LFSRSEED0            ((uint64_t)0x100000000U)     /**<  Use when \ref HWA_CommonConfig::cmpLfsrSeed0 is valid */
#define HWA_COMMONCONFIG_MASK_CMP_LFSRSEED1            ((uint64_t)0x200000000U)     /**<  Use when \ref HWA_CommonConfig::cmpLfsrSeed1 is valid */
#define HWA_COMMONCONFIG_MASK_SW_RESTART_LOOP          ((uint64_t)0x400000000U)     /**<  Use when \ref HWA_CommonConfig::swRestartLoop is valid */
#endif

/** @} */

/**
 * \defgroup HWA_SRC_SHUFFLE_AB_MODE      HWA_SRC_SHUFFLE_AB_MODE
 * \brief  Macros that define values for the shuffled addressing mode.
 * @{
 */
#define HWA_SRC_SHUFFLE_AB_MODE_DISABLE               ((uint8_t)0U)    /**  0-disable */
#define HWA_SRC_SHUFFLE_AB_MODE_ADIM                  ((uint8_t)1U)    /**  1-SHUFFLE_LUT is used for sample index re-ordering in A dimension */
#define HWA_SRC_SHUFFLE_AB_MODE_BDIM                  ((uint8_t)2U)    /**  2- SHUFFLE_LUT is used in B-dimension */
/** @} */

/**
 * \defgroup HWA_COMPLEX_MULTIPLY_MODE      HWA_COMPLEX_MULTIPLY_MODE
 * \brief  Macros that define values for the various modes of the Complex multiply block
 * @{
 */
#define HWA_COMPLEX_MULTIPLY_MODE_DISABLE                   ((uint8_t)0U)    /**  0-disable */
#define HWA_COMPLEX_MULTIPLY_MODE_FREQ_SHIFTER              ((uint8_t)1U)    /**  1-Freq Shifter mode, see \ref HWA_ComplexMultiply::freqShiftTwiddleIncr  */
#define HWA_COMPLEX_MULTIPLY_MODE_SLOW_DFT                  ((uint8_t)2U)    /**  2-slow DFT mode, see \ref HWA_CommonConfig::modeCfg::slowDFT::startFreq */
#define HWA_COMPLEX_MULTIPLY_MODE_FFT_STITCHING             ((uint8_t)3U)    /**  3-FFT stitching mode, see \ref HWA_CommonConfig::modeCfg::FFTstitching::twiddlePattern and HWA_CommonConfig::modeCfg::FFTstitching::winInterpolateMode */
#define HWA_COMPLEX_MULTIPLY_MODE_MAG_SQUARED               ((uint8_t)4U)    /**  4-Magnitude Squared mode */
#define HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT               ((uint8_t)5U)    /**  5-Scalar Multiplication mode, see \ref HWA_CommonConfig::modeCfg::scalerMultiply::scaleCmultScaleEn */
#define HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT               ((uint8_t)6U)    /**  6-Vector Multiplication mode, see \ref HWA_CommonConfig::modeCfg::vectorMultiplyMode1::cmultScaleEn and HWA_CommonConfig::modeCfg::vectorMultiplyMode1::ramAddrOffset */
#define HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT_2             ((uint8_t)7U)    /**  7-Vector Multiplication mode 2, see \ref HWA_CommonConfig::modeCfg::vectorMultiplyMode2::ramAddrOffset */
#define HWA_COMPLEX_MULTIPLY_MODE_RECURSIVE_WIN             ((uint8_t)8U)    /**  8- recursive windowing mode, see \ref HWA_CommonConfig::modeCfg::recursiveWin::recwinModeSel */
#define HWA_COMPLEX_MULTIPLY_MODE_LUT_FREQ_DEROTATE         ((uint8_t)9U)    /**  9- LUT based frequency de-rotation mode, see \ref HWA_CommonConfig::modeCfg::lutFreqDerotate::ramAddrOffset and HWA_CommonConfig::modeCfg::lutFreqDerotate::ramIdxIncrMode */
#define HWA_COMPLEX_MULTIPLY_MODE_FREQSHIFT_FREQINCREMENT   ((uint8_t)10U)   /**  10 - frequency shifter mode with frequency increment, see \ref HWA_CommonConfig::complexMultiplyConfig::twiddleDeltaFrac and \ref HWA_ComplexMultiply::twiddleIncr*/
/** @} */

/**
 * \defgroup HWA_FFT_STITCHING_TWID_PATTERN     HWA_FFT_STITCHING_TWID_PATTERN
 * \brief  Macros that define values for the complex multiply block with FFT stitching mode. Useful for 4K and 8K
 *           FFT calculation, set the last 2 bits in TWIDINCR register, the rest 12 bits should be set to 0.
 * @{
 */
#define HWA_FFT_STITCHING_TWID_PATTERN_4K                   ((uint8_t)1U)     /**  4K fft stitching twid factor pattern */
#define HWA_FFT_STITCHING_TWID_PATTERN_8K                   ((uint8_t)2U)     /**  8K fft stitching twid factor pattern */
/** @} */

/**
 * \defgroup HWA_RECURSIVE_WIN_MODE_SELECT     HWA_RECURSIVE_WIN_MODE_SELECT
 * \brief  Macros that define values for the complex multiply block with recursive windowing mode, specify the winodw
 *           computation paramster.
 * @{
 */
#define HWA_RECURSIVE_WIN_MODE_SELECT_ITERATION_COUNT        ((uint8_t)0U)     /**  iteration count */
#define HWA_FFT_STITCHING_TWID_PATTERN_EXE_COUNT             ((uint8_t)1U)     /**  execution count */
/** @} */

/**
 * \defgroup HWA_WINDOW_MODE        HWA_WINDOW_MODE
 * \brief  Macros that define values for windowing mode of the FFT window
 * @{
 */
#define HWA_WINDOW_MODE_18BITREAL         ((uint8_t)0U)      /**<  window coefficients are 18-bit signed real values,
                                                                   upto 2048 real coefficients can be stored in RAM */
#define HWA_WINDOW_MODE_16BITREAL         ((uint8_t)1U)      /**<  window coefficients are 16-bit signed real values,
                                                                   upto 4096 real coefficients can be stored in RAM */
#define HWA_WINDOW_MODE_COMPLEX           ((uint8_t)2U)      /**<  window coefficients are 16-bit I/Q complex values,
                                                                   upto 2048 complex coefficients can be stored in RAM */
/** @} */

/**
 * \defgroup HWA_FFT3x_BFLY_SCALING        HWA_FFT3x_BFLY_SCALING
 * \brief  Macros that define values for butterfly scaling for radix-3 stage
 * @{
 */
#define HWA_FFT3x_BFLY_SCALING_MSBSATURATED           ((uint8_t)0U)      /**<  26 bit output after radix-3 sate is saturated at MSB to get back to 24 bits */
#define HWA_FFT3x_BFLY_SCALING_MSBSATLSBRND           ((uint8_t)1U)      /**<  26 bit output after radix-3 sate is convergent-rounded to remove 1 LSB bit, then
                                                                            25 bits output is saturated to 24 bits */
#define HWA_FFT3x_BFLY_SCALING_LSBROUNDED             ((uint8_t)2U)      /**<  26 bit output after radix-3 sate is rounded to 24 bits by removing 2 LSB */
/** @} */

/**
 * \defgroup HWA_DCEST_INTERFSUM_RESET_MODE     HWA_DCEST_INTERFSUM_RESET_MODE
 * \brief  Macros that define values for the various reset modes in pre-processing block,
 *           appied to DCESTRESET and INTERFSUMRESET
 * @{
 */
#define HWA_DCEST_INTERFSUM_RESET_MODE_NOUPDATE                     ((uint8_t)0U)     /**  Hold the internal accumulators without updating */
#define HWA_DCEST_INTERFSUM_RESET_MODE_SOFTWARERESET                ((uint8_t)1U)     /**  free-running without automatic reset, software can reset the accumulators by writing to either DC_EST_RESET_SW register for DC accumulator, or INTF_STATUS_RESET_SW for interference statistics */
#define HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET                   ((uint8_t)2U)     /**  Reset the internal accumulators at the start of parameter set (i.e per chirp accumulation) */
#define HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT        ((uint8_t)3U)     /**  Reset the internal accumulators at the start of parameter set only if loop counter is 0 (i.e per frame accumulation) */
/** @} */

/**
 * \defgroup HWA_INTERFTHRESH_MODE     HWA_INTERFTHRESH_MODE
 @ brief    Macros that define values for the various modes of the interference threshold mode in pre-processing block
 * @{
 */
#define HWA_INTERFTHRESH_MODE_MAG_OR_MAGDIF           ((uint8_t)0U)     /**  interference threshold  magnitude or Magnitude difference */
#define HWA_INTERFTHRESH_MODE_MAGDIFF                 ((uint8_t)1U)     /**  interference threshold only magnitude difference */
#define HWA_INTERFTHRESH_MODE_MAG                     ((uint8_t)2U)     /**  interference threshold only magnitude */
#define HWA_INTERFTHRESH_MODE_MAG_AND_MAGDIFF         ((uint8_t)3U)     /**  interference threshold magnitude AND magnitude difference */
/** @} */

/**
 * \defgroup HWA_DCSUB_SELECT     HWA_DCSUB_SELECT
 * \brief  Macros that define values for the various source select of threshold in pre-processing block
 * @{
 */
#define HWA_DCSUB_SELECT_DCSW                    ((uint8_t)0U)     /**  DC subtracted value comes from user defined through DC_I_SW[12] and DC_Q_SW[12] register */
#define HWA_DCSUB_SELECT_DCEST                   ((uint8_t)1U)     /**  DC subtracted value comes from built-in DC estimation hardware, DC_EST_I_VAL[12] and DC_EST_I_VAL[12] registers */
/** @} */

/**
 * \defgroup HWA_INTERFTHRESH_SELECT     HWA_INTERFTHRESH_SELECT
 * \brief  Macros that define values for the various source select of threshold in pre-processing block
 * @{
 */
#define HWA_INTERFTHRESH_SELECT_SW                   ((uint8_t)0U)     /**  interference threshold selection through user defined
                                                                           via INTF_LOC_THRESH_MAGDIFF_SW[12] and INTF_LOC_THRESH_MAG_SW[12] register*/
#define HWA_INTERFTHRESH_SELECT_EST_AVERAGE          ((uint8_t)1U)     /**  interference threshold is average of all threshold computations
                                                                            across 12 iterations via interference statistics outputs INTF_LOC_THRESH_MAGDIFF_VAL[12] or INTF_LOC_THRESH_MAG_VAL[12] */
#define HWA_INTERFTHRESH_SELECT_EST_INDIVIDUAL       ((uint8_t)2U)     /**  interference threshold is individual threshold via
                                                                            interference statistics outputs INTF_LOC_THRESH_MAGDIFF_VAL[12] or INTF_LOC_THRESH_MAG_VAL[12] */
/** @} */

/**
 * \defgroup HWA_INTERFMITIGATION_PATH_SELECT     HWA_INTERFMITIGATION_PATH_SELECT
 * \brief  Macros that define values for the various source select of threshold in pre-processing block
 * @{
 */
#define HWA_INTERFMITIGATION_PATH_ZEROOUT                ((uint8_t)0U)     /**  select the zero-out path in the interference mitigation module */
#define HWA_INTERFMITIGATION_PATH_WINDOWZEROOUT          ((uint8_t)1U)     /**  select the windowed zero-out path in the interference mitigation module */
#define HWA_INTERFMITIGATION_PATH_LINEARINTERPOLATION    ((uint8_t)2U)     /**  select the linear interpolation path path in the interference mitigation module */
#define HWA_INTERFMITIGATION_PATH_UNUSED                 ((uint8_t)3U)     /**  un-used mode in the interference mitigation module */
/** @} */

/**
 * \defgroup HWA_LUT_FREQ_DEROTATE_RAMIDX_INCR     HWA_LUT_FREQ_DEROTATE_RAMIDX_INCR
 * \brief  Macros that define values for the complex multiply block with LUT based frequency de-rotation mode, set
 * the RAM index incremented mode after each iteration, either auto-increment mode, in which the ram index is incremented
   automatically after each iteration, with either saturates at 63 or wraps around, or non-increment mode, in which the ram
 * index is constant for all iterations,
 * @{
 */
#define HWA_LUT_FREQ_DEROTATE_RAMIDX_AUTOINCR_WRAPAROUND    ((uint8_t)0U)     /**  auto-increment mode, with wrap around */
#define HWA_LUT_FREQ_DEROTATE_RAMIDX_AUTOINCR_SATURATED     ((uint8_t)1U)     /**  auto-increment mode, with saturates at 63 */
#define HWA_LUT_FREQ_DEROTATE_RAMIDX_NONINCR                ((uint8_t)2U)     /**  non-increment mode */
/** @} */

/**
 * \defgroup HWA_HISTOGRAM_MODE        HWA_HISTOGRAM_MODE
 * \brief  Macros that define values for histogram computation mode
 * @{
 */
#define HWA_HISTOGRAM_MODE_DISABLED                      ((uint8_t)0U)    /**<  disable */
#define HWA_HISTOGRAM_MODE_HISTOGRAM                     ((uint8_t)1U)    /**<  Statistics output - Histogram computation */
#define HWA_HISTOGRAM_MODE_CDF                           ((uint8_t)2U)    /**<  Statistics output - CDF computation */
#define HWA_HISTOGRAM_MODE_CDF_THRESHOLD                 ((uint8_t)3U)    /**<  Statistics output - CDF threshold computation, user specified the threshold via HWA_CommonConfig::advStatConfig::cdfCntThresh */
/** @} */

/**
 * \defgroup HWA_LOCALMAX_THRESH_BITMASK        HWA_LOCALMAX_THRESH_BITMASK
 * \brief  Macros that define values to enable and disable for detection threshold comparison
 * @{
 */
#define HWA_LOCALMAX_THRESH_BITMASK_BOTH_EN            ((uint8_t)0U)    /**<  enable CUT comparison with detection threshold in both dimensions */
#define HWA_LOCALMAX_THRESH_BITMASK_CDIM_EN            ((uint8_t)1U)    /**<  enable CUT comparison with detection threshold in row dimension only (C-dimension threshold) */
#define HWA_LOCALMAX_THRESH_BITMASK_BDIM_EN            ((uint8_t)2U)    /**<  enable CUT comparison with detection threshold in column dimension only(B-dimension) */
#define HWA_LOCALMAX_THRESH_BITMASK_BOTH_DIS           ((uint8_t)3U)    /**<  disable CUT comparison with detection threshold in both dimensions */
/** @} */

/**
 * \defgroup HWA_LOCALMAX_THRESH_SELECT        HWA_LOCALMAX_THRESH_SELECT
 * \brief  Macros that define values for CUT threshold selection in local maxima block
 * @{
 */
#define HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCREG       ((uint8_t)0U)    /**<  both B and C dimension threshold are taken from software configured register LM_THRESH_VAL */
#define HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCREG      ((uint8_t)1U)    /**<  only C threshold is taken from software configured register LM_THRESH_VAL and B dim threshold is taken from Advanced statistics RAM */
#define HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCRAM      ((uint8_t)2U)    /**<  only B threshold is taken from software configured register LM_THRESH_VAL and C dim threshold is taken from Advanced statistics RAM */
#define HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCRAM     ((uint8_t)3U)    /**<  Both B and C dimension threshold are taken from advance statistics RAM, NOT from software configured register LM_THRESH_VAL */
/** @} */

/**
 * \defgroup HWA_COMPRESS_METHOD        HWA_COMPRESS_METHOD
 * \brief  Macros that define values for
 * @{
 */
#define HWA_COMPRESS_METHOD_EGE                 ((uint8_t)0U)    /**<  Exp-Golomb algorithm */
#define HWA_COMPRESS_METHOD_BFP                 ((uint8_t)1U)    /**<  Block Floating point algorithm */
/** @} */

/**
 * \defgroup HWA_CMP_DCMP        HWA_CMP_DCMP
 * \brief  Macros that define values for
 * @{
 */
#define HWA_CMP_DCMP_COMPRESS          ((uint8_t)0U)    /**<  compression */
#define HWA_CMP_DCMP_DECOMPRESS        ((uint8_t)1U)    /**<  decompression */
/** @} */

/**
 * \defgroup HWA_COMPRESS_PATHSELECT        HWA_COMPRESS_PATHSELECT
 * \brief  Macros that define values for
 * @{
 */
#define HWA_COMPRESS_PATHSELECT_BOTHPASSES      ((uint8_t)3U)    /**<  run both 1st PASS and 2rd pass */
#define HWA_COMPRESS_PATHSELECT_SECONDPASS      ((uint8_t)1U)    /**<  bypass 1st pass, only run 2rd pass */
/** @} */

/** @} */


/**
 * \defgroup HWA_PARAMSET_CONTEXT_SWITCH_CFG        HWA_PARAMSET_CONTEXT_SWITCH_CFG
 * \brief  Context switch enable/disable configuration in the paramset
 * @{
 */
/** \brief disable the context switch in the paramset */
#define HWA_PARAMSET_CONTEXTSWITCH_DISABLE          (0U)
/** \brief context swtich is allowed at the end the a paramset,  CONTEXTSW_EN register bit  is set */
#define HWA_PARAMSET_CONTEXTSWITCH_NONFORCE_ENABLE  (1U)
/** \brief after the paramset, the context switch is forced to happen wihthout the need of any trigger,
 *  the  register FORCED_CONTEXTSW_EN in the parameter-set is set. */
#define HWA_PARAMSET_CONTEXTSWITCH_FORCE_ENABLE     (2U)
/** @} */

/**
 * \defgroup HWA_APP_MEMINIT_CFG        HWA_APP_MEMINIT_CFG
 * \brief  Bit mask to specify HWA MEM BANKs, used with HWA_initializeRAM()
 * @{
 */
/** \brief Bit mask to specify PARAM RAM MEM BANK, used with HWA_initializeRAM() */
#define HWA_APP_MEMINIT_PARAM_RAM                      (1U << 8U)
/** \brief Bit mask to specify PARAM RAM MEM BANK, used with HWA_initializeRAM() */
#define HWA_APP_MEMINIT_WINDOW_RAM                     (1U << 9U)
/** \brief Bit mask to specify PARAM RAM MEM BANK, used with HWA_initializeRAM() */
#define HWA_APP_MEMINIT_PER_SAMPLE_MAX_VAL_EVEN_RAM    (1U << 10U)
/** \brief Bit mask to specify PARAM RAM MEM BANK, used with HWA_initializeRAM() */
#define HWA_APP_MEMINIT_PER_SAMPLE_MAX_VAL_ODD_RAM     (1U << 11U)
/** \brief Bit mask to specify PARAM RAM MEM BANK, used with HWA_initializeRAM() */
#define HWA_APP_MEMINIT_PER_ITER_MAX_VAL_RAM           (1U << 12U)
/** \brief Bit mask to specify PARAM RAM MEM BANK, used with HWA_initializeRAM() */
#define HWA_APP_MEMINIT_HIST_EVEN_RAM                  (1U << 13U)
/** \brief Bit mask to specify PARAM RAM MEM BANK, used with HWA_initializeRAM() */
#define HWA_APP_MEMINIT_HIST_ODD_RAM                   (1U << 14U)
/** @brief Bit mask to specify ALL MEM BANKs, used with HWA_initializeRAM() */
#define HWA_APP_MEMINIT_MEMBANK_ALL                    (HWA_APP_MEMINIT_PARAM_RAM | \
                                                        HWA_APP_MEMINIT_WINDOW_RAM | \
                                                        HWA_APP_MEMINIT_PER_SAMPLE_MAX_VAL_EVEN_RAM | \
                                                        HWA_APP_MEMINIT_PER_SAMPLE_MAX_VAL_ODD_RAM | \
                                                        HWA_APP_MEMINIT_PER_ITER_MAX_VAL_RAM | \
                                                        HWA_APP_MEMINIT_HIST_EVEN_RAM | \
                                                        HWA_APP_MEMINIT_HIST_ODD_RAM )
/** @} */

/* ========================================================================== */
/*                         Structures and Enums                               */
/* ========================================================================== */

/**
 *  \brief    A handle that is returned from a HWA_open() call.
 */
typedef void* HWA_Handle;

/**
 *  \brief  HWA Interrupt callback function after every paramset completion
 *
 *  HWA Interrupt callback function to be used with HWA_enableParamSetInterrupt() call
 *
 */
typedef void (*HWA_ParamDone_IntHandlerFuncPTR)(uint32_t intrIdx, uint32_t paramSet, void * arg);

/**
 *  \brief  HWA Interrupt callback function after all paramsets completion
 *
 *  HWA Interrupt callback function to be used with HWA_enableDoneInterrupt() call
 *
 */
typedef void (*HWA_Done_IntHandlerFuncPTR)(uint32_t threadIdx, void * arg);

/**
 *  \brief  HWA H/W Parameters
 *
 *  HWA parameters are used to with the HWA_open() call.
 *
 */
typedef struct HWA_Attrs_t {
    uint32_t                instanceNum;                /**<  HWA Instance num - this is related to actual H/W instance of this IP */
    volatile uint32_t       ctrlBaseAddr;               /**<  HWA Peripheral's base address for the control/common register space */
    volatile uint32_t       paramBaseAddr;              /**<  HWA Peripheral's base address for the paramset space */
    volatile uint32_t       ramBaseAddr;                /**<  HWA Peripheral's base address for the Window/Internal RAM space */
    volatile uint32_t       dssBaseAddr;                /**<  DSS base address for the common settings */
    uint32_t                numHwaParamSets;            /**<  Number of HWA paramsets in this instance */
    uint32_t                intNum1ParamSet;            /**<  HWA Peripheral's interrupt vector 1 for individual paramset completion */
    uint32_t                intNum2ParamSet;            /**<  HWA Peripheral's interrupt vector 2 for individual paramset completion */
    uint32_t                intNumDone;                 /**<  HWA Peripheral's interrupt vector for completion of all programmed paramset in background thread */
    uint32_t                intNumDoneALT;              /**<  HWA Peripheral's interrupt vector for completion of all programmed paramset in ALT thread */
    uint32_t                intNumLocalRamErr;          /**<  HWA Peripheral's interrupt vector for Local RAM access error */
    uint32_t                numDmaChannels;             /**<  Number of DMA channels available for HWA (src or dst) */
    volatile uint32_t       accelMemBaseAddr;           /**<  HWA Accelerator processing memory base address */
    uint32_t                accelMemSize;               /**<  HWA Accelerator processing memory size in bytes */
    bool                    isConcurrentAccessAllowed;  /**<  Flag to say if read access of Common Registers is allowed in hardware when
                                                             HWA is executing paramsets */
} HWA_Attrs;

/**
 *  \brief  HWA RAM Parameters
 *
 *  HWA parameters are used to with the HWA_configRam() call.
 *
 */
typedef struct HWA_RAMAttrs_t
{
    uint32_t      ramBaseAddress;                     /**<  HWA RAM base address */
    uint32_t      ramSizeInBytes;                     /**<  HWA RAM size in bytes */
} HWA_RAMAttrs;

/**
 *  \brief  Source trigger DMA parameters
 *
 *  Source trigger DMA parameters that the user can use to configure a generic DMA channel to trigger the HWA
 *
 *  Note: source and destination addresses represent CPU view of HWA address.
 *        Depending on the SOC and the dma engine which is used for transfer, they may need to be translated by caller.
 *
 *  Example: SOC_translateAddr API with SOC_TranslateAddr_Dir_TO_EDMA should be used
 *           when passing it to EDMA API for configuration.
 */
typedef struct HWA_SrcDMAConfig_t {
    uint32_t       srcAddr;             /**<  source Address for the DMA programming */
    uint32_t       destAddr;            /**<  destination Address for the DMA programming */
    uint16_t       aCnt;                /**<  A count for the DMA programming */
    uint16_t       bCnt;                /**<  B count for the DMA programming */
    uint16_t       cCnt;                /**<  C count for the DMA programming */
} HWA_SrcDMAConfig;

/**
 *  \brief  HWA Common Config
 *
 *  HWA common config parameters that are used with the HWA_ConfigCommon() call.
 *
 */
typedef struct HWA_CommonConfig_t {
    uint64_t           configMask;             /**<  See \ref HWA_COMMONCONFIG_MASK macros for correct values.
                                                     Set this to specify which of the fields are valid when calling
                                                     HWA_ConfigCommon API. */
    uint16_t            numLoops;               /**<  12 bits value: number of loops to run from paramStartIdx to paramStopIdx
                                                     valid value: 0-4094; 4095 for infinite.
                                                     Sets the NUMLOOPS in the PARAM_RAM_LOOP register */

    uint16_t            paramStartIdx;         /**<  6 bits value: start index of paramset through which state machine loops through
                                                     valid value: 0-63
                                                     Sets the PARAM_START_IDX bit in  PARAM_RAM_IDX register */
    uint16_t            paramStopIdx;          /**<  6 bits value: stop index of paramset through which state machine loops through
                                                     valid value: 0-63
                                                     Sets the PARAM_END_IDX in PARAM_RAM_IDX register */
    uint16_t            numLoopsALT;            /**<  same as HWA_CommonConfig::numLoops, but applicable to altername context for context switching
                                                    sets the PARAM_RAM_LOOP_ALT_NUMLOOPS in the PARAM_RAM_LOOP_ALT registers */

    uint16_t            paramStartIdxALT;       /**<  same as HWA_CommonConfig::paramStartIdx, but applicable to altername context for context switching
                                                    sets the PARAM_RAM_IDX_ALT_PARAM_START_IDX in the PARAM_RAM_IDX_ALT registers */

    uint16_t            paramStopIdxALT;        /**<  same as HWA_CommonConfig::paramStopIdx, but applicable to altername context for context switching
                                                    sets the PARAM_RAM_IDX_ALT_PARAM_STOP_IDX in the PARAM_RAM_IDX_ALT registers */

    uint8_t             contextswitchTriggerMode; /**<  4 bit value: See \ref HWA_CONTEXTSWITCH_TRIG_MODE macros for correct values, used for context switching
                                                   Sets the CS_CONFIG_CS_TRIGMODE bits of CS_CONFIG register */

    uint8_t             contextswitchTriggerSrc;  /**<  5 bit value: if contextswitchTriggerMode is set to HWA_CONTEXTSWITCH_TRIG_MODE_DMA, specifies the DMA channel number to be monitored in context switching,
                                                  if contextswitchTriggerMode is set to HWA_CONTEXTSWITCH_TRIG_MODE_HARDWARE, specifies which CSI2 trigger signal (out of 20 possible trigger signals) to wait
                                                  for in context switch.
                                                  sets the CS_CONFIG_CS_TRGSRC bits of CS_CONFIG register */
#if defined (SOC_AWR294X)
    /* This Field is applicable for only AWR294x ES2.0 devices */
    uint8_t             swRestartLoop;          /**< 1-bit value: This is a self clearing sofware trigger bit for low priority thread .
                                                     When sw_restart_loop is 1 , low priority thread is reconfigured with param_start_idx,param_end_idx,num_loops */
#endif
    struct {
        uint16_t        bpmRate;               /**<  10 bit value: specifies the number of input samples corresponding to each BPM bit..
                                                     value of 0 is invalid, BPM is enabled/disabled by setting \ref HWA_AccelModeFFT::bpmEnable bit in paramset
                                                     Sets BPM_RATE bits in BPM_RATE register */

        uint32_t        bpmPattern[HWA_BPMPATTERN_LENGTH_INWORDS];
                                               /**<  256-bit value: specifies a Binary Phase Modulation (BPM) pattern to be removed on
                                                     the input samples prior to FFT, split into 8 32 bits register,
                                                     BPM is enabled/disabled by setting \ref HWA_AccelModeFFT::bpmEnable bit in paramset.
                                                     Sets BPM_PATTERN_n 8 registers */

        uint8_t         twidDitherEnable;      /**<  See \ref HWA_FEATURE_BIT macros for correct values.
                                                     Setting to 1 Enable Dithering for Twiddle Factors
                                                     It is recommended to keep this register bit always set to 1 (i.e., dithering enabled)
                                                     FFT is enabled/disabled by setting \ref HWA_AccelModeFFT::fftEn in paramset.
                                                     Sets the DITHER_TWID_EN bit in DITHER_TWID_EN register */
        uint32_t        lfsrSeed;              /**<  29-bit value: LFSR seed, if \ref HWA_CommonConfig::twidDitherEnable is enabled.
                                                    Sets the LFSR_SEED bits in LFSR_SEED */

        uint8_t         fftSumDiv;             /**<  5-bit value: specifies the number of bits to right-shift the sum statistic (36-bit)
                                                     before it is written to destination memory (24-bit), applied if \ref HWA_PostProcStat::fftOutMode
                                                     is set to HWA_FFT_MODE_OUTPUT_MAX_STATS or HWA_FFT_MODE_OUTPUT_SUM_STATS.
                                                     Sets the FFTSUMDIV bits in FFTSUMDIV register */
    } fftConfig;


    struct {
        uint16_t        scale;                 /**<  9 bit value: scale applied to 12 accumulators. multiplies the
                                                      accumulator outputs by dcEstScale/256. default value is 256, giving a scale of 1.0
                                                      if \ref HWA_PreProcessing::dcEstResetMode is set to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET
                                                      or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                      sets DC_EST_SCALE in DC_EST CTRL register */

        uint8_t         shift;                 /**<  4 bit value: applied to all 12 accumulator outputs, can not
                                                    bypassed, the accumulator outputs are scaled by 2^(8+6+ \ref HWA_CommonConfig::shift).
                                                    if \ref HWA_PreProcessing::dcEstResetMode is set to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET
                                                    or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                    sets DC_EST_SHIFT in DC_EST_CTRL register */
    } dcEstimateConfig;

    struct
    {
        int32_t    swIVal[HWA_NUM_RXCHANNELS];        /**<  24 bit value: SW programmed DC values used in subtraction
                                                                if \ref HWA_PreProcessing::dcSubEnable is enabled and
                                                                \ref HWA_PreProcessing::dcSubSelect is set to HWA_DCSUB_SELECT_DCSW.
                                                                sets DC_SW_I_n_val in DC_SW_I_n register */

        int32_t    swQVal[HWA_NUM_RXCHANNELS];        /**<  24 bit value: SW programmed DC values used in subtraction,
                                                                 if \ref HWA_PreProcessing::dcSubEnable is enabled and
                                                                 \ref HWA_PreProcessing::dcSubSelect is set to HWA_DCSUB_SELECT_DCSW.
                                                                 sets DC_SW_Q_n_val bits in DC_SW_Q_n register */
    } dcSubtractConfig;


    struct {

        uint32_t  thresholdMagSw[HWA_NUM_RXCHANNELS]; /**<  24-bit value: Interference zero-out threshold - is used to zero-out sample(s),
                                                                 whose magnitude (24-bit absolute value of the 24-bit complex input) is very
                                                                 high, prior to computing the FFT
                                                                 The \ref HWA_PreProcessing::thresholdEnable is enabled, and
                                                                 \ref HWA_PreProcessing::thresholdSelect is set to HWA_INTERFTHRESH_SELECT_SW
                                                                 in the intended paramset for this threshold to be used
                                                                 sets in INTERFTHRESH_MAGn_VAL register */

        uint32_t  thresholdMagDiffSw[HWA_NUM_RXCHANNELS];  /**<  24-bit value: Interference zero-out threshold, is used to zero-out sample(s),
                                                                      whose magnitude diff (24-bit absolute value of the 24-bit complex input)
                                                                      is very high, prior to computing the FFT
                                                                      if the \ref HWA_PreProcessing::thresholdEnable is enabled and
                                                                      \ref HWA_PreProcessing::thresholdSelect is set to HWA_INTERFTHRESH_SELECT_SW
                                                                      in the intended paramset for this threshold to be used
                                                                      sets in INTERFTHRESH_MAGDIFFn_VAL registers */

        uint8_t         sumMagScale;               /**<  8 bits value:unsigned 8 bits, 5 integer bits, and 3 fractional bits,
                                                        applied to INTERSUM_MAGn from interference statistics block,
                                                        default value is 8, corresponding to scale 1.0
                                                        if the \ref HWA_PreProcessing::resetMode is set
                                                        to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                        sets INTERFSUM_MAG_SCALE in INTERFSTATS_CTRL register */

        int8_t          sumMagShift;               /**<  3 bits: right shift after scaling, the shift value is 2^(3+6+interfsumMagShift)
                                                       if the \ref HWA_PreProcessing::resetMode is set
                                                      to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                       sets INTERFSUM_MAG_SHIFT in  INTERFSTATS_CTRL register */

        uint8_t         sumMagDiffScale;           /**<  8 bits: similar to interfsumMagScale, applied to INTERSUM_MAGDIFFn from interference statistics block,
                                                        if the \ref HWA_PreProcessing::resetMode is set
                                                        to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                        sets INTERFSUM_MAGDIFF_SCALE in INTERFSTATS_CTRL register */

        int8_t          sumMagDiffShift;           /**<  3 bits: right shift after scaling, similar to interfsumMagShift
                                                       if the \ref HWA_PreProcessing::resetMode is set
                                                       to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                      sets INTERFSUM_MAGDIFF_SHIFT in INTERFSTATS_CTRL register */

        uint8_t         mitigationWindowParam[HWA_NUM_INTERFMITG_WINARRAY];
                                                  /**<  5 bit value: unsigned 5 bit integer, set the window parameters
                                                       if \ref HWA_PreProcessing::enable is enabled, and
                                                          \ref HWA_PreProcessing::pathSelect is set to HWA_INTERFMITIGATION_PATH_WINDOWZEROOUT
                                                       sets the INTF_MITG_WINDOW_PARAM_0_INTF_MITG_WINDOW_PARAM_0 in
                                                       INTF_MITG_WINDOW_PARAM_x register */
     } interfConfig;


    struct {

        int32_t         Iscale[HWA_NUM_RXCHANNELS]; /**<  21 bits: complex scalars used in \ref HWA_ComplexMultiply::cmultMode =  HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT,
                                                               HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT or HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT_2
                                                               if \ref HWA_ComplexMultiply::cmultScaleEn is set to 0, only cmultIScale[0] is used as
                                                               constant scalar multiplication,
                                                               sets the ICMULT_SCALEn bits in ICMULT_SCALn registers */

        int32_t         Qscale[HWA_NUM_RXCHANNELS]; /**<  21 bits: complex scalars used in \ref HWA_ComplexMultiply::cmultMode =  HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT,
                                                               HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT or HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT_2
                                                               if \ref HWA_ComplexMultiply::cmultScaleEn is set to 0, only cmultIScale[0] is used as
                                                               constant scalar multiplication
                                                               sets the ICMULT_SCALEn bits in ICMULT_SCALn registers */

        int16_t          twiddleDeltaFrac;          /**<  signed 10 bit value: only applied to if \ref HWA_ComplexMultiply::cmultMode is set to
                                                        HWA_COMPLEX_MULTIPLY_MODE_FREQSHIFT_FREQINCRE, frequency shifter with frequency increment mode, \ref HWA_ComplexMultiply::twiddleIncr
                                                        specifies how much the frequency could change for each successive input sample.
                                                        additionally, twiddleDeltaFrac can be added to the derotation frequency to compensate for doppler induced phase shifts,
                                                        it is reset at the start of paramset execution and again after the paramsets are executed.
                                                        for other modes, it is ignored.
                                                        sets the TWID_INCR_DELTA_FRAC bits in the TWID_INCR_DELTA_FRAC register */

        uint8_t         recWindowReset;           /**<  1 bit value: resets the param set counter used in Recursive window mode, applied to
                                                        \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_RECURSIVE_WIN,
                                                        sets the RECWIN_RESET_SW_RECWIN_RESET_SW bits in the RECWIN_RESET_SW register */
    } complexMultiplyConfig;

    struct {

        uint8_t         size;                      /**<  8 bit value: specifies the number of samples after channel combined in current iteration,
                                                         if \ref HWA_PreProcessing::chanCombEn is enabled.
                                                         sets NUM_SAMPLES_AFTER_COMB in the CHAN_COMB_CTRL register */

        uint32_t        vector[HWA_CHANCOMB_LENGTH_INWORDS];
                                                   /**<  256 bit value: vector indicated the samples indices that need to be combined
                                                        if if \ref HWA_PreProcessing::chanCombEn is enabled.
                                                        A string of "1" or "0" sums the samples corresponding to the indices. A "10" or "01"
                                                        demarcates the groups. The LSB of the bit-vector corresponds to the first input samples.
                                                        sets the register CHAN_COMB_VEC_0 - CHAN_COMB_VEC_7 registers */


    } chanCombConfig;

    struct {

        uint8_t         number;                    /**<  8 bit value: number of zeros to be inserted in current iteration
                                                        if \ref HWA_PreProcessing::zeroInsertEn is enabled.
                                                        sets ZERO_INSERT_NUM bit in ZERO_INSERT_CTRL register */

        uint32_t        mask[HWA_ZEROINSERT_LENGTH_INWORDS];
                                                   /**<  256 bit value: holds the positions of zero-insertion.
                                                        if \ref HWA_PreProcessing::zeroInsertEn is enabled.
                                                        A bit-field of '0' inserts a zero
                                                        at location based on bit-field index. "1" means the input is passed through.
                                                        sets ZERO_INSERT_MASK_n bits in the ZERO_INSERT_MASK_0 - ZERO_INSERT_MASK_7 registers */

    } zeroInsertConfig;

    struct {

        uint32_t        thresholdScale;            /**<  18-bit value: specifies the threshold scale factor that is used to
                                                        either multiply or add to the 'surrounding noise average' to determine
                                                        the threshold used for detection of the present cell under test
                                                        in log mode, if HWA_ParamConfig_t:: accelMode is set to HWA_ACCELMODE_CFAR.
                                                        this value should be represented as 7.11.
                                                        in mag/mag-sqr mode, this value should be represented as 14.4.
                                                        Sets the CFAR_THRESH_CFAR_THRESH bits in CFAR_THRESH register */
    } cfarConfig;

    struct {

        int32_t         max2DoffsetDim1;           /**<  24 bit value: sets offset to be added to dimension 1 maxima result,
                                                        if \ref HWA_PostProcStat::max2Denable is enabled.
                                                        sets MAX2D_OFFSET_DIM1 bits in  MAX2D_OFFSET_DIM1 register */

        int32_t         max2DoffsetDim2;           /**<  24 bit value: sets offset to be added to dimension 2 maxima result,
                                                        if \ref HWA_PostProcStat::max2Denable is enabled.
                                                        sets IM2_MAX2D_OFFSET_DIM2 in  MAX2D_OFFSET_DIM2 register */


        uint16_t        cdfCntThresh;              /**<  12 bit value: is applied in CDF count threshold mode of operation, i.e.
                                                        if \ref HWA_PostProcStat::histogramMode is set to HWA_HISTOGRAM_MODE_CDF_THRESHOLD.
                                                        CDF is computed over the histogram till the value of CDF exceeds the cdfCntThresh
                                                        value is 0-4095
                                                        sets CDF_CNT_THRESH bits in CDF_CNT_THRESH register */

    } advStatConfig;

    struct {

        uint16_t        dimBThreshold;             /**<  16 bits value: specify column threshold for local maxima,
                                                        if \ref HWA_AccelModeLocalMax::thresholdMode is set to HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCREG or
                                                        HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCRAM
                                                        sets LM_THRESH_VAL_DIMB_THRESH_VAL  bits in LM_THRESH_VAL register*/

        uint16_t        dimCThreshold;             /**< 16 bits value: specify row threshold for local maxima
                                                        if \ref HWA_AccelModeLocalMax::thresholdMode is set to either HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCREG or
                                                        HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCREG
                                                        sets LM_THRESH_VAL_DIMC_THRESH_VAL  bits in LM_THRESH_VALregister*/

        uint16_t       dimBBaseAddress;            /**< 12 bits value: specify the base address in Stats RAM for the threshold values correspoinding to dimension B,
                                                        if \ref HWA_AccelModeLocalMax::thresholdMode is set to HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCRAM or
                                                        HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCREG
                                                        sets LM_2DSTATS_BASE_ADDR_BASE_ADDR_DIMB bits in LM_2DSTATS_BASE_ADDR register */

        uint16_t       dimCBaseAddress;            /**< 12 bits value: specify the base address in Stats RAM for the threshold values correspoinding to dimension C,
                                                       if \ref HWA_AccelModeLocalMax::thresholdMode is set to HWA_LOCALMAX_THRESH_SELECT_DIMBRAM_DIMCRAM or
                                                       HWA_LOCALMAX_THRESH_SELECT_DIMBREG_DIMCRAM
                                                       sets LM_2DSTATS_BASE_ADDR_BASE_ADDR_DIMC bits in LM_2DSTATS_BASE_ADDR register */
    } localMaxConfig;

    struct {

        uint8_t         EGEKparam[HWA_CMP_K_ARR_LEN];         /**<  5 bit value: valid value is from 0 - 31. the list of Golomb parameters to optimize over in the first pass.
                                                        The maixmum  length is 8, the valid length of the list is programmed by
                                                        HWA_AccelModeCompress::compressEGEKarrayLength parameter.
                                                        sets CMP_EGE_K0123_CMP_EGE_K0-k3 and CMP_EGE_K4567_CMP_EGE_K4-k7 bits in the
                                                        CMP_EGE_K0123 and CMP_EGE_K4567 registers */
#if defined (SOC_AWR294X) /* These fields are applicable for only ES2.0 devices. */
        uint32_t       cmpLfsrSeed0;              /**<  29-bit value: LFSR seed, if HWA_ParamConfig::cmpLfsrSel is set to 0
                                                    Sets the REG_CMP_LFSRSEED0 bits in LREG_CMP_LFSRSEED0 */
        uint32_t       cmpLfsrSeed1;              /**<  29-bit value: LFSR seed, if HWA_ParamConfig::cmpLfsrSel is set to 1
                                                    Sets the REG_CMP_LFSRSEED0 bits in LREG_CMP_LFSRSEED0 */
#endif

    } compressConfig;

} HWA_CommonConfig;

/**
 *  \brief  HWA Paramset Config for Input Formatter/Source block
 *
 *  HWA paramset config parameters for the Input Formatter/Source block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
 *
 */
typedef struct HWA_SourceConfig_t {
    uint32_t    srcAddr;                    /**<  20 bit value:  specifies the starting address of the input samples
                                                    in the accelerator memory. Value of 0x0000 points to the
                                                    first byte of accelerator memory and 17-bit value covers
                                                    the entire address space of the eight memories (8x16KB= 128 KB)
                                                 Sets the SRCADDR bits of SRC register in paramset */
    uint16_t    srcAcnt;                    /**<  12 bit value: specifies the number of samples (minus 1) from the source memory
                                                    to process for every iteration.
                                                    Note: The unit is samples and not bytes.
                                                 Sets the SRCACNT bits of SRCA register in paramset */
    int32_t     srcAIdx;                    /**<  20 bit value: specifies the number of bytes separating successive samples
                                                    in the source memory, maximum is 2^17-1
                                                 Sets the SRCAINDX bits of SRCA register in paramset */
    uint16_t    srcBcnt;                    /**<  12 bit value: specifies the number of times (minus 1) the processing should be iterated
                                                 Sets the BCNT bits of SRCB register in paramset */
    int32_t     srcBIdx;                    /**<  20 bit value: Specifies the number of bytes separating the start
                                                    address of samples for successive iterations in the
                                                    source memory (in bytes, signed value), maximum is 2^17-1
                                                Sets the SRCBINDX bits in SRCB register in paramset */
    uint16_t    srcCcnt;                    /**<  12 bit value: specify the C-dimension count, only applied to LOCAL maxima engine.
                                                sets the CCNT bit of SRCC register in paramset */
    int32_t     srcCIdx;                    /**<  20 bit value:  specifies the number of bytes separating the starting address
                                                  of input samples for successive sets of B-dimension iterations.
                                                  sets the SRCCINDX bit of SRCC register in paramset */

    uint16_t    srcAcircShift;              /**<  12 bit value: specifies the circular shift in A-dimension (offset in samples) that should
                                                    be applied on the sequence of input samples before feeding them
                                                    to the Core Computational unit
                                                 Sets the SRCA_CIRCSHIFT bits of CIRCSHIFT register in paramset */
    uint8_t     srcAcircShiftWrap;          /**<  4 bit value: indicates at what number the sample count value should wraparound,
                                                    when using A-dimension circular shift, if the bit in srcCircShiftWrap3 corresponding to
                                                    dim A is set to 0, the wrap around point is at
                                                    (2^ srcAcircShiftWrap -1), if the bit in srcCircShiftWrap3 is set to 1, the wrap around point
                                                    is (3 x 2^ srcAcircShiftWrap -1)
                                                 Sets the SRCA_CIRCSHIFTWRAP bits of CIRCSHIFT2 register in paramset */

    uint16_t    srcBcircShift;               /**<  12 bit value: specifies the circular shift in B-dimension (offset in samples) that should
                                                  be applied on the sequence of input samples before feeding them to the Core Computational unit
                                                  Sets the SRCB_CIRCSHIFT bits of CIRCSHIFT register in paramset */
    uint8_t     srcBcircShiftWrap;           /**<  4 bit value: indicates at what number the sample count value should wraparound,
                                                  when using B-dimension circular shift. if the bit in srcCircShiftWrap3 corresponding to
                                                  dim B is set to 0, the wrap around point is at
                                                  (2^ srcAcircShiftWrap -1), if the bit in srcCircShiftWrap3 is set to 1, the wrap around point
                                                  is (3 x 2^ srcAcircShiftWrap -1)
                                                  Sets the SRCB_CIRCSHIFTWRAP bits of CIRCSHIFT2 register in paramset */

    uint16_t    srcCcircShift;               /**<  12 bit value: specifies the circular shift in C-dimension (offset in samples) that should
                                                  be applied on the sequence of input samples before feeding them
                                                  to the Core Computational unit
                                                  Sets the SRCC_CIRCSHIFT bits of  CIRCSHIFT2 register in paramset */
    uint8_t     srcCcircShiftWrap;           /**<  4 bit value: indicates at what number the sample count value should wraparound,
                                                  when using C-dimension circular shift. if the bit in srcCircShiftWrap3 corresponding to
                                                  dim C is set to 0, the wrap around point is at
                                                  (2^ srcAcircShiftWrap -1), if the bit in srcCircShiftWrap3 is set to 1, the wrap around point
                                                   is (3 x 2^ srcAcircShiftWrap -1)
                                                   Sets the SRCC_CIRCSHIFTWRAP bits of CIRCSHIFT2 register in paramset */

    uint8_t     srcCircShiftWrap3;           /**<  3 bit value: used in conjunction with srcAcircShiftWrap, srcBcircShiftWrap and srcCcircShiftWrap,
                                                in radix-3 FFT mode, bit 0 corresponds to A-dim, bit 1 corresponds to B-dim, and bit 3 corresponds to C-dim,
                                                sets the SRC_CIRCSHIFTWRAP3X bit of CIRCSHIFT2 register in paramset */

    uint8_t     shuffleMode ;               /**<  see \ref HWA_SRC_SHUFFLE_AB_MODE macros for correct values, HWA_SRC_SHUFFLE_AB_MODE_DISABLE mode disable the shuffle LUT
                                                  sets the SHUFFLE_AB bit of SRC register in paramset */

    uint8_t     srcRealComplex;              /**<  See \ref HWA_SAMPLES_FORMAT macros for correct values.
                                                  specify real or Complex data in the source memory.
                                                  Sets the SRCREAL bits in SRC register in paramset */
    uint8_t     srcWidth;                    /**<  See \ref HWA_SAMPLES_WIDTH macros for correct values.
                                                   16-bit or 32-bit data width in source memory.
                                                   Sets the SRC16b32b bits of SRC register in paramset */
    uint8_t     srcSign;                     /**<  See \ref HWA_SAMPLES_SIGN macros for correct values.
                                                  Signed or Unsigned data in the source memory.
                                                  This setting is only relevant for srcWidth=0 (16 bits),
                                                  because that is when sign-extension
                                                  may be required to convert to internal 24-bit width.
                                                  Sets the SRCSIGNED bits of SRC register in paramset */

    uint8_t     srcConjugate;                /**<  See \ref HWA_FEATURE_BIT macros for correct values.
                                                  Enable/Disable Conjugation of the input samples.
                                                    0: No conjugation
                                                    1: Enable conjugation
                                                  This register only makes sense for srcRealComplex=0 (complex).
                                                  It is useful in conjunction with DSTCONJ to derive an IFFT
                                                  mode (by conjugating at both input and output)
                                                  Sets the SRCCONJ bit of SRC register in paramset */

    uint8_t     srcScale;                    /**<  4 bit value: Specifies a programmable scaling, via right bit-shift,
                                                    Sets the SRCSCAL bits of SRC register in paramset.
                                                    Based on the REG_SRCSCAL register value, a right bit-shift of
                                                    0 to 8 bits is applied first, with additional MSB sign-extension
                                                    (based on REG_SRCSIGNED) and LSB rounding.  The resulting 32-bit
                                                    sample is then saturated to a 24-bit number by saturating the 8 MSBs */

   uint8_t      srcIQSwap;                   /**<  see \ref HWA_FEATURE_BIT macros for correct values,
                                                  sets SRC_IQSWAP bits of register SRC in paramset */

   uint32_t     wrapComb;                    /**<  20 bit value: applied in shuffled addressing mode. The combined A-B dimnsion based address in
                                                  wrapped around this number .
                                                  sets the bits WRAP_COMB of WRAPCOMB register in paramset */

   uint8_t     shuffleStart;                 /**<  4 bit value: start index for the shuffle LUT, the value together with 4 zeros padded at the LSB
                                                   is the 8-bit starting index for the 256 elements HWA_RAM_TYPE_SHUFFLE_RAM.
                                                   sets the bits SHUFFLE_START of WRAPCOMB register in paramset */
} HWA_SourceConfig;

/**
 *  \brief  HWA Paramset Config for Output Formatter/Destination block
 *
 *  HWA paramset config parameters for the Output Formatter/Destination block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
 *
 */
typedef struct HWA_DestConfig_t {

    uint32_t    dstAddr;                    /**<  20 bit value: specifies the starting address of the output samples
                                                    in the accelerator memory. Value of 0x0000 points to the
                                                    first byte of accelerator memory and 17-bit value covers
                                                    the entire address space of the four memories (8x16KB = 128 KB)
                                                    Sets the DSTADDR bits of DST register in paramset */
    uint16_t    dstAcnt;                    /**<  12 bit value: specifies the number of samples (minus 1) from the destination
                                                    memory to process for every iteration.
                                                    Note: The unit is samples and not bytes.
                                                 Sets the DSTACNT bits of DSTA register in paramset */

    int32_t     dstAIdx;                    /**<  20 bit value: specifies the number of bytes separating successive samples
                                                    in the destination memory
                                                 Sets the DSTAINDX bits of register DSTA in paramset */

    int32_t     dstBIdx;                    /**<  20 bit value: Specifies the number of bytes separating the start
                                                 address of samples for successive iterations in the
                                                 destination memory (in bytes, signed value)
                                                 Sets the DSTBINDX bits of register DSTB in paramset */

    uint8_t     dstRealComplex;             /**<  See \ref HWA_SAMPLES_FORMAT macros for correct values.
                                                 Real or Complex data in the destination memory.
                                                 Sets the DSTREAL bits of register DST in paramset */

    uint8_t     dstWidth;                   /**<  See \ref HWA_SAMPLES_WIDTH macros for correct values.
                                                 16-bit or 32-bit alignment of data in destination memory.
                                                 Sets the DST16b32b bits of register DST in paramset */

    uint8_t     dstSign;                    /**<  See \ref HWA_SAMPLES_SIGN macros for correct values.
                                                 Signed or Unsigned data in the destination memory.
                                                  This setting is only relevant for dstWidth=0,
                                                  because that is when sign-extension
                                                  may be required to convert to internal 24-bit width.
                                                  Sets the DSTSIGNED bits of register DST in paramset */

    uint8_t     dstConjugate;               /**<  See \ref HWA_FEATURE_BIT macros for correct values.
                                                 Enable/Disable Conjugation of the output samples.
                                                    0: No conjugation
                                                    1: Enable conjugation
                                                 This register only makes sense for dstRealComplex=0.
                                                 It is useful in conjunction with DSTCONJ to derive an IFFT
                                                 mode (by conjugating at both output and output)
                                                 Sets the DSTCONJ bit of register DST in paramset */

    uint8_t     dstScale;                   /**<  4 bit value: Specifies a programmable scaling using bit shift.
                                                 sets DSTSCAL bits of register DST in paramset */

    uint16_t    dstSkipInit;                /**<  10 bit value: Number of samples to skip in the beginning (for each
                                                    iteration) before writing samples to the destination
                                                    memory. The total number of samples written to destination memory is
                                                    DSTACNT+1-dstSkipInit.
                                                   Sets the REG_DST_SKIP_INIT bits of DSTB register in paramset */

    uint8_t     dstIQswap;                  /*  See \ref HWA_FEATURE_BIT macros for correct values
                                               sets bits DST_IQSWAP of register DST in paramset */
} HWA_DestConfig;

/**
*  \brief  HWA Paramset Config for post-processing and the statistics control registers
*
*  HWA paramset config parameters for post-processing and the statistics control register inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
*
*/
typedef struct HWA_PostProcStat_t {

    uint8_t       magLogEn;                 /**<  See \ref HWA_FFT_MODE_MAGNITUDE_LOG2 macros for correct values.
                                            Enable/Disable for Magnitude and Log2 computation
                                            Sets the LOG2_EN, ABS_EN bits of register POSTPROCWIN in paramset */


    uint8_t      fftOutMode;                /**<  See \ref HWA_FFT_MODE_OUTPUT macros for correct values.
                                            Configures the output mode of the FFT Engine path
                                            For stats mode, following parameters will be override  in
                                            \ref HWA_DestConfig of that paramset
                                            dstAcnt=4095, dstAIdx=dstBIdx=8, dstWidth=1, dstRealComplex=0.
                                            Sets the FFT_OUTPUT_MODE bits of register POSTPROCWIN in paramset */


    uint8_t     max2Denable;                /**<  2-D maxima computation enable or disable, see \ref HWA_FEATURE_BIT macros for correct values
                                                 if enable, one maxima array for A-Dimension and another for B-Dimension are computed,
                                                 sets the bits MAX2D_EN of register POSTPROCWIN in paramset */

    uint8_t     histogramMode;              /**<  sets the histogram computation mode, see \ref HWA_HISTOGRAM_MODE for correct values.
                                                 if it is set to HWA_HISTOGRAM_MODE_DISABLED, disable the histogram, and CDF calculations.
                                                 sets the bits HWA_HISTOGRAM_MODE of register PREPROC in paramset */


    uint8_t     histogramScaleSelect;         /**<  4 bit value: selects the input scale before histogram computations.
                                                 valid values are 7-13. If register is set to X, the bin ranges are [0 2^x-1],
                                                 [2^x, 2x2^x-1],[2x2^x, 3x2^x-1], and so on
                                                 sets the bits HIST_SCALE_SEL of register POSTPROCWIN in paramset */

    uint8_t     histogramSizeSelect;          /**<  4 bit value: used to select the histogram number of bins. the size is
                                                 configurable in powers of 2. valid values are 3-6, corresponding to
                                                 histogram sizes of 8,16,32, and 64.
                                                 sets the bits HIST_SIZE_SEL of register POSTPROCWIN in paramset */
} HWA_PostProcStat;

/**
*  \brief  HWA Paramset Config for ComplexMultiply block
*
*  HWA paramset config parameters for the ComplexMultiply block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
*
*/
typedef struct HWA_ComplexMultiply_t {

    uint8_t      cmultMode;                /**<  See \ref HWA_COMPLEX_MULTIPLY_MODE macros for correct values.
                                           Configuration for the Complex Multiplier block. Set it into HWA_COMPLEX_MULTIPLY_MODE_DISABLE
                                           to disable the complex multiply block
                                           Sets the CMULT_MODE in the PRE_PROCESSING register in paramset */

    union {
        struct
        {
            uint16_t    freqShiftTwiddleIncr;           /**<  14 bit value: specifies the de-rotation frequency if \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_FREQ_SHIFTER
                                                     sets the TWID_INCR bits in TWID_INCR register */

        } freqShift;

        struct
        {
            uint16_t    startFreq;             /**<  14 bit value: specifies the starting frequency for DFT,
                                                   if \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_SLOW_DFT.
                                                   and \ref HWA_CommonConfig::twiddleDeltaFrac should be set to zero,
                                                   the phase change is provided by the HWA_AccelModeFFT::fftSize.
                                                   sets TWID_INCR bits in TWID_INCR register */
        } slowDFT;

        struct
        {
            uint16_t    twiddlePattern;        /**<  specify the twiddler factor pattern,if \ref HWA_ComplexMultiply::cmultMode is set to
                                                    HWA_COMPLEX_MULTIPLY_MODE_FFT_STITCHING, (FFT stitching mode),
                                                    see \ref HWA_FFT_STITCHING_TWID_PATTERN macros for the correct values,
                                                    sets 2 lsb bits of TWID_INCR bits in TWID_INCR register */

            uint8_t     winInterpolateMode;    /**<  2 bit value: See \ref HWA_FFT_WINDOW_INTERPOLATE_MODE macros for correct values.
                                                    Configures linear interpolation for the window coefficients, which is
                                                    relevant for large-size FFT computation (i.e., FFT sizes of 4K, 8K) that
                                                    is obtained via stitching multiple smaller-size FFTs.
                                                    (Note: winSymm should be set to 0 when using 4K or 8K mode)
                                                    Sets the WINDOW_INTERP_FRACTION bits of register POSTPROCWIN in paramset */
        } FFTstitching;

        struct
        {
            uint8_t      scaleCmultScaleEn;             /**<  see \ref HWA_FEATURE_BIT macros for the correct values, it is applied if
                                                        \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT,
                                                        if it is enabled, the input samples are multiplied by 12 different scalar,
                                                        programmed in \ref HWA_CommonConfig::Iscale[HWA_NUM_RXCHANNELS], and
                                                        \ref HWA_CommonConfig::Qscale[HWA_NUM_RXCHANNELS]. per
                                                        iteration based on REG_BCNT. if it is disabeld, a constant complex scalar
                                                        \ref HWA_CommonConfig::Iscale[0], and
                                                        \ref HWA_CommonConfig::Qscale[0]
                                                        is applied to all samples
                                                        sets CMULT_SCALE_EN bits of PRE_PROCESSING register in paramset */
        } scalerMultiply;

        struct
        {
            uint8_t      cmultScaleEn;             /**<  see \ref HWA_FEATURE_BIT macros for the correct values, if
                                                      \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT.
                                                      if it is enabled, the input samples are multiplied successively by 12 different complex values,,
                                                      programmed in \ref HWA_CommonConfig::Iscale[HWA_NUM_RXCHANNELS], and
                                                      \ref HWA_CommonConfig::Qscale[HWA_NUM_RXCHANNELS].
                                                      If it is disabled, the input samples are multiplied by upto 1024 complex samples saved in internal RAM.
                                                      Sets the CMULT_SCALE_EN bits of PRE_PROCESSING register in paramset */
           uint16_t     vecMultiMode1RamAddrOffset;    /**<  specifies an address offset for RAM, if \ref HWA_ComplexMultiply::cmultScaleEn is disabled
                                                        sets the 12 msb in TWID_INCR bits in TWID_INCR register, the 2 lsb must kept to 0 */
        } vectorMultiplyMode1;

        struct
        {
            uint16_t    vecMultiMode2RamAddrOffset;             /**<  specifies an address offset for RAM, if
                                                         \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT_2
                                                         sets the 12 msb in TWID_INCR bits in TWID_INCR register, the 2 lsb must kept to 0 */

        } vectorMultiplyMode2;

        struct
        {
            uint8_t     recwinModeSel;              /**<  see \ref HWA_RECURSIVE_WIN_MODE_SELECT macro for the correct values, applied to
                                                         \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_RECURSIVE_WIN mode.
                                                         sets the bits RECWIN_MODE_SEL of register PREPROC in paramset */
        } recursiveWin;

        struct
        {
            uint16_t    ramAddrOffset;              /**<  specifies an address offset for RAM, if \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_LUT_FREQ_DEROTATE
                                                         sets the 6 lsb in TWID_INCR bits in TWID_INCR register */
            uint8_t     ramIdxIncrMode;            /**<  see \ref HWA_LUT_FREQ_DEROTATE_RAMIDX_INCR for the correct values
                                                       sets bit 13, and 12 of TWID_INCR bits in TWID_INCR register */

        } lutFreqDerotate;

        struct
        {
            uint16_t    twiddleIncr;           /**<  14 bit value: specifies the de-rotation frequency if \ref HWA_ComplexMultiply::cmultMode is set to HWA_COMPLEX_MULTIPLY_MODE_FREQSHIFT_FREQINCRE
                                                     sets the TWID_INCR bits in TWID_INCR register */

        } freqShiftWithFreIncrement;
    } modeCfg ;
} HWA_ComplexMultiply;

/**
*  \brief  HWA Paramset Config for pre-processing block
*
*  HWA paramset config parameters for the preprocessing block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
*
*/
typedef struct HWA_PreProcessing_t {

    uint8_t      dcEstResetMode;             /**<  controls the reset behavior for all 12 accumulators,
                                               see \ref HWA_DCEST_INTERFSUM_RESET_MODE macros for correct values.
                                               set into HWA_DCEST_INTERFSUM_RESET_MODE_NOUPDATE to bybass DC estimation.
                                               sets the bits DCEST_RESET_MODE in register PREPROC in paramset */

    uint8_t      dcSubEnable;                /**<  enable/bypass DC subtraction, see \ref HWA_FEATURE_BIT macros for correct values.
                                                  set into HWA_FEATURE_BIT_DISABLE to disable the DC subtraction.
                                                  sets the bits DCSUB_EN of the register PREPROC in paramset */

    uint8_t      dcSubSelect;                /**<  see \ref HWA_DCSUB_SELECT macros for the correct values
                                                  sets bits DCSUB_SELECT of the register PREPROC in paramset */

    struct {
        uint8_t      thresholdEnable;         /**<  enable/disable interference marking out, see \ref HWA_FEATURE_BIT macros for correct values
                                                   if set into  HWA_FEATURE_BIT_DISABLE to disable the interference localization.
                                                   sets the bits INTERFTHRESH_EN of the register PREPROC in paramset */

        uint8_t      thresholdMode;           /**<  specifies interference threshold mode, see \ref HWA_INTERFTHRESH_MODE macros
                                                   for the correct values
                                                   sets the bits INTERFTHRESH_MODE of the register PREPROC in paramset */

        uint8_t      thresholdSelect;         /**<  select the source of the threshold, see \ref HWA_INTERFTHRESH_SELECT macros
                                              for the correct values
                                              sets bits INTERFTHRESH_SELECT of the register PREPROC in paramset */


    } interfLocalize;

    struct {
       uint8_t      resetMode;               /**<  control reset behavior for all mag sum and magdiff sum accumulators,
                                                   if it is set to HWA_DCEST_INTERFSUM_RESET_MODE_NOUPDATE, it is bypassed.
                                                   see \ref HWA_DCEST_INTERFSUM_RESET_MODE macros for the correct values
                                                   sets the INTERFSUM_MAG_RESET bits of the register PREPROC in paramset */

    } interfStat;

    struct {

        uint8_t      enable;                  /**<  enable/disable interference mitigation path, see \ref HWA_FEATURE_BIT macros
                                                for the correct values
                                                sets the bits INTF_MITG_EN of register PRE_PROCESSING in paramset */

        uint8_t      countThreshold;          /**<  5 bits value: the number of non-zero IIB within the hysteresis window
                                                should exceed the threshold for the CUT to be considered to be affected
                                                by interference. valid values are from 0 to 31.
                                                sets the bits INTF_MITG_CNTTHRESH of the register PRE_PROCESSING in paramset */

        uint8_t      pathSelect;              /**<  see \ref HWA_INTERFMITIGATION_PATH_SELECT macros for the correct values, select
                                                 one of the three paths in the interference mitigation module
                                                 sets the bits INFT_MITG_PATH_SEL of register PRE_PROCESSING in paramset */

        uint8_t      leftHystOrder;           /**<  4 bits value: the length of the IIB array considered on the left side of the CUT,
                                                 valid values from 0 to 15.
                                                 sets the bits INTF_MITG_LEFT_HYST_ORD of the register PRE_PROCESSING in paramset */

        uint8_t      rightHystOrder;          /**<  4 bits value: he length of the IIB array considered on the right side of the CUT,
                                                  valid values from 0 to 15.
                                                  sets the bits INTF_MITG_RIGHT_HYST_ORD of the register PRE_PROCESSING in paramset */

    } interfMitigation;

    uint8_t     chanCombEn;                   /**<  enable/disable synthetic channel combining, see \ref HWA_FEATURE_BIT
                                                  macros for the correct values. if set into HWA_FEATURE_BIT_DISABLE to disable
                                                  the channel combining.
                                                  sets the bits CHANCOMB_EN of the register PREPROC in paramset */

    uint8_t      zeroInsertEn;              /**<  enable/disable zero-insertion, fill the zeros at arbitrary
                                            locations in the A-dimension, prior to windowing and FFT, only applied to FFTSIZE
                                            upto 256. see \ref HWA_FEATURE_BIT macros for the correct values
                                            sets the bits ZEROINSERT_EN of register BFLYFFT in paramset */

    HWA_ComplexMultiply     complexMultiply;  /**<  Complex multiply related params used when \ref HWA_ParamConfig::accelMode
                                                   is not \ref HWA_ACCELMODE_CFAR */
} HWA_PreProcessing;

/**
 *  \brief  HWA Paramset Config for FFT block
 *
 *  HWA paramset config parameters for the FFT block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
 *
 */
typedef struct HWA_AccelModeFFT_t{
    uint8_t      fftEn;                     /**<  Enable/Disable for FFT computation See \ref HWA_FEATURE_BIT macros for correct values.
                                                  0 - FFT disabled (Pipelined FFT sub-block bypassed)
                                                  1 - FFT enabled  (Pipelined FFT sub-block enabled)
                                                Sets the FFT_EN bits of register BFLYFFT in paramset */

    uint8_t      fftSize;                   /**<  4 bit value: Specifies the number of FFT radix-2 butterfly stages employed.
                                                Actual FFT size is equal to 3^fftsize3xen x 2^(fftSize)
                                                if fftsize3xen is set to 0, supported values are [1..11] , which correspond to FFT sizes [2.4 8 ... 2048].
                                                if fftsize3xen is set to 1, supported values are [0..9], which corresponds to FFT size [3 6 12 24 48 96 192 384 768 1536]
                                                The actual FFT size should be equal to or larger than srcAcnt
                                                Sets the FFTSIZE bits of BFLYFFT register in paramset */

    uint16_t     butterflyScaling;          /**<  12 bit value: 1 bit per butterfly stage. LSB is for last stage and MSB is for the first stage
                                                   for each bit,
                                                    0 - MSB is saturated
                                                    1 - convergent rounded at LSB (divide by 2)
                                                  Number of valid bits in this field depends on the fftSize.
                                                Sets the BFLY_SCALING bits of BFLYFFT register in paramset */

    uint8_t      windowEn;                  /**<  See \ref HWA_FEATURE_BIT macros for correct values.
                                                Enable/Disable for Windowing operation
                                                Sets the WINDOW_EN bits of register POSTPROCWIN in paramset */

    uint16_t     windowStart;               /**<  11 bit value: (0-4095) Specifies the offset from the actual Window RAM base address
                                                 and represents the starting address of the window function
                                                 in the Window RAM. The value of this register depends on the WIN_MODE.
                                                 Sets the WINDOW_START bits of register POSTPROCWIN in paramset */

    uint8_t      winSymm;                   /**<  See \ref HWA_WINDOW_SYMM macros for correct values.
                                                 Indicates whether the window function is symmetric or not
                                                 Sets the WINSYMM bits of register POSTPROCWIN in paramset */


    uint8_t      windowMode;                /**<  specifies the windowing mode  See \ref HWA_WINDOW_MODE macros for correct values
                                                 sets the WINDOW_MODE bits of register POSTPROCWIN in paramset */

    uint8_t     fftSize3xEn;                /**<  indicates whether to engage the additional FFT radix-3 butterfly state,
                                                 see \ref HWA_FEATURE_BIT macros for correct values
                                                 sets the FFTSIZE3XEN bits of BFLYFFT register in paramset */


    uint8_t      fftSizeDim2;               /**<  4 bit value: default is 0. FFT engine computes the usual one dimensional FFT.
                                                 otherwise , FFT engine computes 2-D FFT with size 2^(fftSize - fftSizeDim2) by
                                                 2^fftSizeDim2
                                                 sets the FFTSIZE_DIM2 bits of BFLYFFT register in paramset */

    uint8_t      butterflyScalingFFT3x;     /**<  specifies the scaling for radix-3 stage, see \ref HWA_FFT3x_BFLY_SCALING macros
                                                 for the correct values
                                                 sets the bits BFLY_SCALING_FFT3X of register BFLYFFT in paramset */


    uint8_t      bpmEnable;                 /**<  Enable/Disable for BPM removal operation,
                                                  See \ref HWA_FEATURE_BIT macros for correct values.
                                                  0: disable
                                                  1: enable
                                                  Sets the bits BPM_EN of the register BFLYFFT in paramset */

    uint8_t      bpmPhase;                  /**<  4 bit value: Specifies the starting phase of the BPM pattern
                                                 Sets the BPM_PHASE bits of the register BFLYFFT in paramset */

    HWA_PostProcStat   postProcCfg;        /**<  advanced statistics config */

    HWA_PreProcessing preProcCfg;           /**< pre-processing block config */
} HWA_AccelModeFFT;

/**
 *  \brief  HWA Paramset Config for CFAR block
 *
 *  HWA paramset config parameters for the CFAR block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
 *
 */
typedef struct HWA_AccelModeCFAR_t{
    uint8_t      numNoiseSamplesLeft;       /**<  6 bit value: specify the number of samples used for noise averaging
                                                 to the left of the cell under test.
                                                 Note: The actual number of samples used for noise averaging in H/W is equal
                                                 to the value of this field multiplied by 2. for cfar-ca mode, it supports 0-63, not support 1
                                                 for cfar-os mode, it supports 0,4,6,8,12,16,24, 32 only.
                                                 Sets the CFAR_AVG_LEFT (add note of factor of 2) bits of CFAR_CFG register in paramset */
    uint8_t      numNoiseSamplesRight;      /**<  6 bit value: specify the number of samples used for noise averaging
                                                 to the right of the cell under test.
                                                 Note: The actual number of samples used for noise averaging in H/W is equal
                                                 to the value of this field multiplied by 2
                                                 Sets the CFAR_AVG_RIGHT (add note of factor of 2) bits of CFAR_CFG in paramset */
    uint8_t      numGuardCells;             /**<  3 bit value: specifies the number of guard cells to ignore on either side of the cell under test
                                                Sets the CFAR_GUARD_INT bits of CFAR_CFG register in paramset */
    uint8_t      nAvgDivFactor;             /**<  4 bit value: specifies the division factor by which the noise sum calculated from the
                                                left and right noise windows are divided by in order to get the final
                                                surrounding noise average value.
                                                The division factor is equal to 2^nAvgDivFactor
                                                Valid values: 0-8
                                                Sets the CFAR_NOISEDIV bits of CFAR_CFG register in paramset */
    uint8_t      nAvgMode;                  /**<  See \ref HWA_NOISE_AVG_MODE_CFAR macros for correct values.
                                                 configures the noise averaging mode in the CFAR detector
                                                 Sets the CFAR_CA_MODE bits of CFAR_EN register in paramset */

    uint8_t     cfarOsKvalue;               /**<  7 bit value: specifies ordered statistics, in CFAR-OS mode, maximum is 127
                                                 sets the CFAR_OS_KVAL bits of CFAR_CFG register in paramset */

    uint8_t     cfarOsEdgeKScaleEn;         /**<  1 bits: enable scaling of K value for the edge samples in non-cyclic CFAR-OS mode;
                                                 only used in CFAR-oS in non-cyclic mode.
                                                 sets the CFAR_OS_KVAL bits of CFAR_CFG register in paramset */

    uint8_t      operMode;                  /**<  See \ref HWA_CFAR_OPER_MODE macros for correct values.
                                                 Sets the CFAR_LOG_MODE, CFAR_INP_MODE, CFAR_ABS_MODE bits of CFAR_EN register in paramset */

    uint8_t      outputMode;                /**<  See \ref HWA_CFAR_OUTPUT_MODE macros for correct values.
                                                 select the output mode of the CFAR engine
                                                 Sets the CFAR_OUT_MODE bits of  CFAR_EN register in paramset */

    uint8_t     cfarAdvOutMode;             /**<  See \ref HWA_FEATURE_BIT macros for correct values.
                                                 if it is disabled, HWA_AccelModeCFAR::outputMode, see \ref HWA_CFAR_OUTPUT_MODE
                                                 if it is enabled,   HWA_AccelModeCFAR::outputMode should be set to 1.
                                                 sets the CFAR_ADV_OUT_MODE bits of CFAR_EN register in paramset */

    uint8_t      peakGroupEn;               /**<  See \ref HWA_FEATURE_BIT macros for correct values.
                                                 specifies whether peak grouping should be enabled
                                                 HWA_FEATURE_BIT_DISABLE - peak grouping is disabled, which means that a peak is declared as detected
                                                 as long as the cell under test exceeds the threshold
                                                 HWA_FEATURE_BIT_ENABLE - peak is declared as detected only if it the cell under test exceeds the threshold,
                                                 as well as, if the cell under test exceeds the two neighboring cells to its immediate
                                                 left and right
                                                 Sets the CFAR_GROUPING_EN bits of CFAR_EN register in paramset */

    uint8_t      cyclicModeEn;              /**<  See \ref HWA_FEATURE_BIT macros for correct values.
                                                 specifies whether the CFAR-CA detector needs to work in cyclic mode or in non-cyclic mode
                                                 HWA_FEATURE_BIT_DISABLE=non-cyclic mode
                                                 HWA_FEATURE_BIT_ENABLE=cyclic mode
                                                 Sets the CFAR_CYCLIC  bits of CFAR_EN register in paramset */
} HWA_AccelModeCFAR;

/**
 *  \brief  HWA Paramset Config for Local maxima block
 *
 *  HWA paramset config parameters for the Local maxima block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
 *
 */
typedef struct HWA_AccelModeLocalMax_t{

    uint8_t   neighbourBitmask;            /**<  8 bit value: for neighbouring cells to enable or disable the comparison with CUT.
                                                starting from left top corner and moving in clock-wise direction
                                                sets LM_NEIGH_BITMASK bits of register LOCMAXPATH in paramset */

    uint8_t   thresholdBitMask;            /**<  enable/disable for detection threshold comparison,
                                                see \ref HWA_LOCALMAX_THRESH_BITMASK macros for the correct values
                                                sets theLM_THRESH_BITMASK bits of register LOCMAXPATH in paramset */

    uint8_t   thresholdMode;               /**<  sets the threshold select, see \ref HWA_LOCALMAX_THRESH_SELECT macros for the correct values
                                                sets the LM_THRESH_MODE bits of register LOCMAXPATH in paramset */

    uint8_t   dimBNonCyclic;                 /**< sets dimension B non cyclic, if enable, set local maximum detection to non-cyclic mode, otherwise
                                                  set local maximum detection to cyclic mode */
    uint8_t   dimCNonCyclic;                 /**< sets dimension C non cyclic, if enable, set local maximum detection to non-cyclic mode, otherwise
                                                  set local maximum detection to cyclic mode */
} HWA_AccelModeLocalMax;

/**
*  \brief  HWA Paramset Config for compression and decompression
*
*  HWA paramset config parameters for the Local compression and decompression block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
*
*/
typedef struct HWA_AccelModeCompress_t {
    uint8_t     EGEKidx;                 /**<  4 bits values: the k-index used for HWA_COMPRESS_METHOND_EGE algorithm,
                                                  if the first pass is bypassed
                                                  sets the CMP_EGE_OPT_K_INDX bits of register CMPDCMP in paramset */
    uint8_t     EGEKarrayLength;          /**<  4 bits value: The size of K-array used in the EGE, valid range is 1 to 3. Applied to
                                                  \ref HWA_AccelModeCompress::method is set to HWA_COMPRESS_METHOND_EGE only
                                                  sets the CMP_EGE_K_ARR_LEN bits of register CMPDCMP in paramset */
    uint8_t     scaleFactorBW;             /**<  4 bits value: it specifies the number of bits for storing the scale
                                                  both BFP and EG algorithm. If the input is 16-bit (real or complex),
                                                  scaleFactorBW is set to 4, if the input is 32-bit (real or complex), the scaleFactorBW
                                                  is set to 5. Valid range is 0 to 7.
                                                  sets the CMP_SCALEFAC_BW bits of register CMPDCMP in paramset */
	uint8_t     BFPMantissaBW;             /**<  5 bits value: specify the number of bits for mantissa, applied to
												  \ref HWA_AccelModeCompress::method is set to HWA_COMPRESS_METHOD_BFP only
												  sets the CMP_BFP_MANTISSA_BW bits of register CMPDCMP in paramset */
	uint8_t     scaleFactor;               /**<  5 bits values: hard coded scale factor for BFP, only if first pass is disabled.,
												  sets the CMP_SCALEFAC bits of register CMPDCMP in paramset */
    uint8_t     passSelect;                /**<  see \ref HWA_COMPRESS_PATHSELECT macro for the correct values,
                                                 sets the CMP_PASS_SEL bits of register CMPDCMP in paramset */
    uint8_t     headerEnable;              /**<  see \ref HWA_FEATURE_BIT macro for the correct values,
                                                  it enable/disable the header in the compressed data.
                                                 sets the CMP_HEADER_EN bits of register CMPDCMP in paramset */

    uint8_t     method;                    /**<  see \ref HWA_COMPRESS_METHOD macro for the correct values, it selects one of
                                                  the two compress algorithms.
                                                  sets the CMP_METHOD bits of register CMPDCMP in paramset */
    uint8_t     compressDecompress;        /**<  see \ref HWA_CMP_DCMP macros for correct values.
                                                sets the CMP_DCMP bits of register CMPDCMP in paramset */
    uint8_t     ditherEnable;              /**<  see \ref HWA_FEATURE_BIT macros for correct values, the register bit enable/disable dithering.
                                                sets the CMP_DITHER_EN bits of register CMPDCMP in paramset */

#if defined (SOC_AWR294X)
    /* These fields are applicable for only AWR294x ES2.0 devices. */
    uint8_t     decrImagBitw;              /**< see \ref HWA_FEATURE_BIT macros for correct values, the register bit enables/disables bitwidth of mantissa.
                                                sets the DECR_IMAG_BITW bits of register in CMPDCMP2 in paramset */
    uint8_t     cmpRoundEn;                 /**< see \ref HWA_FEATURE_BIT macros for correct values, the register bit enables/disables rounding.
                                                sets the CMP_ROUND_EN bits of register in CMPDCMP2 in paramset */
    uint8_t     selLfsr;                     /**< see \ref HWA_FEATURE_BIT macros for correct values, the register bit selects which LFSR seed is to be used.
                                                sets the CMP_ROUND_EN bits of register in CMPDCMP2 in paramset */
#endif
} HWA_AccelModeCompress;

/**
 *  \brief  HWA Paramset Config
 *
 *  HWA paramset config parameters that are used with the HWA_ConfigParamSet() call.
 *
 */
typedef struct HWA_ParamConfig_t {
     uint8_t            triggerMode;                /**<  4 bit value: See \ref HWA_TRIG_MODE macros for correct values.
                                                         Sets the TRIGMODE bits of HEADER in paramset */
     uint8_t            triggerSrc;                 /**<  5 bit value:  If \ref HWA_ParamConfig::triggerMode is set \ref HWA_TRIG_MODE::HWA_TRIG_MODE_DMA,
                                                          this field specifies DMA channel number to be monitored. If \ref HWA_ParamConfig::triggerMode
                                                          is set \ref HWA_TRIG_MODE::HWA_TRIG_MODE_HARDWARE, this field specifies one of the possible csirx IRQs.
                                                          this field only applied to the \ref HWA_TRIG_MODE::HWA_TRIG_MODE_DMA and
                                                          \ref HWA_TRIG_MODE::HWA_TRIG_MODE_HARDWARE.
                                                         Sets the DMA2ACC_TRIGSRC bits of HEADER in paramset */
     uint8_t            accelMode;                  /**<  2 bit value: See \ref HWA_ACCELMODE macros for correct values.
                                                          Configures the mode of operation of the accelerator for
                                                          the current parameter-set.
                                                         Sets the ACCEL_MODE bits of register HEADER in paramset */

     HWA_SourceConfig   source;                     /**<  Source related params */
     HWA_DestConfig     dest;                       /**<  Dest related params */

    union {
        HWA_AccelModeFFT          fftMode;                /**<  FFT mode related params */
        HWA_AccelModeCFAR         cfarMode;               /**<  CFAR mode related params */
        HWA_AccelModeLocalMax     localMaxMode;           /**<  local maxima related params */
        HWA_AccelModeCompress     compressMode;           /**<  compression and decompression related params */
    } accelModeArgs;

    uint8_t                       contextswitchCfg;       /**< enable/disable the context switch, if enabled, specify if it is forced or not-forced enable
                                                            See \ref HWA_PARAMSET_CONTEXT_SWITCH_CFG macros for correct values */
} HWA_ParamConfig;

/**
 *  \brief  HWA Interrupt Config
 *
 *  HWA interrupt config parameters that are used with the HWA_enableParamSetInterrupt() call.
 *
 */
typedef struct HWA_InterruptConfig_t {
    uint8_t             interruptTypeFlag;      /**<  Flag to specify whether Interrupt to CPU and/or DMA
                                                     is desired on completion of paramset.
                                                     Defines for \ref HWA_PARAMDONE_INTERRUPT_TYPE can be ORed to
                                                     specify this flag.
                                                     Interrupt types HWA_PARAMDONE_INTERRUPT_TYPE_CPU may not be supported on all
                                                     versions of the IP - see \ref HWA_Attrs::isConcurrentAccessAllowed */
    struct {
        HWA_ParamDone_IntHandlerFuncPTR   callbackFn;       /**<  Callback function to be called when interrupt destination is CPU */
        void                             *callbackArg;      /**<  Callback function argument */
           } cpu;
    struct {
        uint8_t                           dstChannel;     /**<  DMA channel number to be triggered on paramset completion
                                                               if interrupt destination to DMA is desired */
    } dma;
} HWA_InterruptConfig;

/**
 *  \brief  HWA Statistics from the STATISTICS block
 *
 *  HWA statistics - MAX and SUM - that are output from the statistics block.
 *
 */
typedef struct HWA_Stats_t {
    uint32_t             maxValue;      /**<  24 bits value from MAXnVALUE register */
    uint16_t             maxIndex;      /**<  24 bits value from MAXnINDEX register */
    uint8_t              iSumMSB;       /**<  upper 4 bits of 36-bit value of iSUM; read from ISUMnMSB */
    uint8_t              qSumMSB;       /**<  upper 4 bits of 36-bit value of qSUM; read from QSUMnMSB */
    uint32_t             iSumLSB;       /**<  lower 32 bits of 36-bit value of iSUM; read from ISUMnLSB */
    uint32_t             qSumLSB;       /**<  lower 32 bits of 36-bit value of qSUM; read from QSUMnLSB */
} HWA_Stats;

/**
*  \brief  HWA Accumulator register value data structure
*
*/
typedef struct HWA_AccmulatorVal_t {
    uint32_t             accValLSB;      /**<  LSB value */
    uint16_t             accValMSB;      /**<  MSB value */
} HWA_AccmulatorVal;

/**
 *  \brief  HWA Debug statistics
 *
 *  HWA debug - current paramset, loopcount, trigger status - that are output from the statistics block.
 *
 */
typedef struct HWA_DebugStats_t {
    uint8_t             currentParamSet;        /**<  Index of the current paramset that is under execution.
                                                   useful for debug, where parameter-sets can be executed
                                                   one-by-one using SW trigger mode for each of them.  In
                                                   such a debug, this register indicates which parameter-set
                                                   is currently waiting for the SW trigger */
    uint8_t             paramSetIdxCpuIntr0;    /**<  paramset index  when PARAM_DONE_INTR0 is generated */
    uint8_t             paramSetIdxCpuIntr1;    /**<  paramset index  when PARAM_DONE_INTR1 is generated */
    /**<  Indicates the overall state of the HWA state machine
     *  000:  State Machine is in IDLE state
     *  001:  State machine is in thread 1 Load params state
     *  010:  State machine is in thread 1 wait trigger state
     *  011:  State machine is in thread 1 run state
     *  100:  State machine is in thread 2 Load params state
     *  101:  State machine is in thread 2 wait trigger state
     *  110:  State machine is in thread 2 run state
     *  111:  State machine is in context switch state
     */
    uint8_t             fsmStateInfo;
    uint16_t            currentLoopCount;       /**<  the loop count that is presently running */

    uint16_t            otherThreadLoopCount;   /**<  the loop count for alternate thread */
    uint32_t            trigStatus[2];          /**<  trigger status */
} HWA_DebugStats;

/**
 *  \brief  HWA Local memory Information
 *
 *  HWA Local processing memory info - base address and Size.
 *
 */
typedef struct HWA_MemInfo_t {
    uint32_t    baseAddress;        /**<  Base Address of HWA Local memory */
    uint16_t    bankSize;           /**<  Total size in bytes of one bank */
    uint16_t    numBanks;           /**<  number of banks can be used of HWA Local memory */
} HWA_MemInfo;

/**
 *  \brief  HWA Histogram Threshold RAM data structure
 *
 *  CDF_CNT_BINNUM, CDF_CNT_CDFVAL, CDF_CNT_HISTVAL in HWA Histogram threshold RAM if CDF count threshold is enabled
 *
 */
typedef struct HWA_CdfThreshold_t {

    uint32_t    pdfValue  : 12;           /**<  \brief the histogram count at bin  binNumber*/
    uint32_t    cdfValue  : 12;           /**<  \brief the CDF count at binNumber bin*/
    uint32_t    binNumber : 6;            /**<  \brief the bin number at which the specified count is hit */
    uint32_t    reserved  : 2;            /**<  \brief not used */

} HWA_CdfThreshold;

/**
 *  \brief  HWA interrupt priority for HWA background thread done, ALT thread done,  paramset done interrupt 1 and paramset done 2 interrupt
 *
 */
typedef struct HWA_InterruptPriority_t {

    uint32_t    backgroundDone;                /**<  \brief HWA interrupt priority for the background thread done */
    uint32_t    ALTDone;                       /**<  \brief HWA interrupt priority for the ALT thread done */
    uint32_t    paramsetDone1;                 /**<  \brief HWA interrupt priority for paramset done interrupt 1 */
    uint32_t    paramsetDone2;                 /**<  \brief HWA interrupt priority for paramset done interrupt 2 */
    uint32_t    loalRamErr;                    /**<  \brief HWA local RAM error interrupt priority */

} HWA_InterruptPriority;

/**
 *  \brief  HWA configuration structure, which describes the configuration information, needed for hwa handle open
 *
 */
typedef struct HWA_OpenConfig_t {

    HWA_InterruptPriority    interruptPriority ;  /**<  \brief structure holds the HWA interrupt priorities. This structure is applicable
                                                        for processors that support a hardware priority, e.g R5F.
                                                        In HWA, even though the four interrupts can not be generated at the same time,
                                                        during the ISR execution of a HWA interrupt say L, if another HWA interrupt event H happens
                                                        of a higher priority because of HWA progressing in its execution flow during this time,
                                                        then the L's ISR will be preempted by H's ISR and the corresponding user provided call
                                                        back function of L can therefore also get preempted by H's ISR or H's callback.
                                                        User needs to keep this in mind in the design and implementation of the call back
                                                        functions that were intended to benefit from such prioritization.
                                                        In most use cases, it is not expected that such prioritization will be beneficial
                                                        and so it is recommended to leave these settings to the default state of same
                                                        priority level for all HWA interrupts. */

} HWA_OpenConfig;

/** @} */   /* end of HWA_DRIVER_EXTERNAL_DATA_STRUCTURE*/

/* ========================================================================== */
/*                  Internal/Private Structure Declarations                   */
/* ========================================================================== */

/**
 * \brief
 *  HWA Interrupt context structure for paramset done interrupt
 *
 * @details
 *  HWA interrupt context structure per paramSet.
 *
 */
typedef struct HWA_InterruptCtx_t {
    HWA_ParamDone_IntHandlerFuncPTR     callbackFn;      /**< HWA interrupt callback function */
    void                                *callbackArg;    /**< HWA interrupt callback function argument */
} HWA_InterruptCtx;

/**
 * \brief
 *  HWA Interrupt context structure for done interrupt
 *
 * @details
 *  HWA interrupt context structure for done interrupt which is triggered when all paramsets are executed
 *
 */
typedef struct HWA_DoneInterruptCtx_t {
    bool                                bIsEnabled;      /**< boolean to store enable/disable status of HWA interrupt */
    HWA_Done_IntHandlerFuncPTR          callbackFn;      /**< HWA interrupt callback function */
    void                                *callbackArg;    /**< HWA interrupt callback function argument */
} HWA_DoneInterruptCtx;

/**
 *  \brief  HWA driver internal Config
 */
typedef struct HWA_Driver_t {
    /**
     * \brief HWA instance number
     */
    uint32_t                        instanceNum;
    /**
     * \brief HWA instance reference (open) count
     */
    uint32_t                        refCnt;
    /**
     * \brief HWA instance config is in progress.
     *          Protects Common register acccess in HWA_configCommon() and HWA_configRam().
     */
    uint8_t                        configInProgress;
    /**
     * \brief HWA paramset config is in progress [used as bitmap].
     *          Protects Paramset register access in HWA_configParamSet(),
     *          HWA_enableParamSetInterrupt() and HWA_disableParamSetInterrupt()
     */
    uint16_t                       paramSetMapInProgress;
    /**
     * \brief HWA Hardware related params
     */
    HWA_Attrs          const       *hwAttrs;

    /**
     * \brief Registered Interrupt Handler for each paramset completion
     */
    HwiP_Object                     hwiHandleParamSet;

    /**
     * \brief Registered Interrupt Handler for interrupt at the end of group of paramsets
     */
    HwiP_Object                     hwiHandleDone;

    /**
     * \brief Registered Interrupt Handler for each paramset completion in the ALT thread
     */
    HwiP_Object                     hwiHandleParamSetALT;

    /**
     * \brief Registered Interrupt Handler for interrupt at the end of group of paramsets in the ALT thread
     */
    HwiP_Object                     hwiHandleDoneALT;

    /**
     * \brief Registered Interrupt Handler for local ram error
     */
    HwiP_Object                     hwiHandleLocalRamErr;

    /**
     * \brief interrupt context for each paramset
     */
    HWA_InterruptCtx                *interruptCtxParamSet; /*[NUM_HWA_PARAMSETS_PER_INSTANCE];*/

    /**
     * \brief interrupt enable mask for background thread
     */
    uint64_t                        interrupt1ParamSetMask;

    /**
     * \brief interrupt enable mask for ALT thread
     */
    uint64_t                        interrupt2ParamSetMask;


    /**
     * \brief interrupt context for all paramset done interrupt
     */
    HWA_DoneInterruptCtx             interruptCtxDone;

    /**
     * \brief interrupt context for all paramset done interrupt in the ALT thread
     */
    HWA_DoneInterruptCtx             interruptCtxDoneALT;

#if defined (SOC_AWR294X)
    /**
     * \brief interrupt context for all paramset done interrupt in the ALT thread
     */
    bool                             isES2P0Device;
#endif
} HWA_Object;

/** \brief Externally defined driver configuration array */
extern HWA_Attrs        gHwaAttrs[];
/** \brief Externally defined driver RAM configuration array */
extern HWA_RAMAttrs     gHwaRamCfg[HWA_NUM_RAMS];
/** \brief Externally defined driver object */
extern HWA_Object       gHwaObject[];
/** \brief Externally defined driver object pointer */
extern HWA_Object      *gHwaObjectPtr[];
/** \brief Externally defined driver configuration array size */
extern uint32_t         gHwaConfigNum;

/* ========================================================================== */
/*                         Global Variables Declarations                      */
/* ========================================================================== */

/* None */

/* ========================================================================== */
/*                          Function Declarations                             */
/* ========================================================================== */

/** \addtogroup HWA_DRIVER_EXTERNAL_FUNCTION
 @{ */

/**
 *  \brief  Function to initialize the HWA module
 *
 *  @pre    This function must be called once per system and before
 *          any other HWA driver APIs. It resets the HWA H/W instances in the system.
 *
 */
extern void HWA_init(void);

/**
 *  \brief  Function to deinitialize the HWA module
 */
extern void HWA_deinit(void);

/**
 *  \brief  Function to initialize HWA specified by the
 *  particular index value.
 *
 *  @pre    HWA_init() has been called
 *
 *  @param  index         HWA instance number
 *  @param  hwaCfg        pointer to HWA configuration, it is only applied to the processors, which support the hardware interrupt priority, e.g R5F.
 *                        for other processors, set it to NULL. For the processors, which support the hardware interrupt priority, setting to NULL
 *                        uses the default interrupt priorities, otherwise, the interrupt priorities are provided through hwaCfg.
 *  @param  errCode       [out] valid errorCode if NULL handle returned.
 *
 *  @return A HWA_Handle upon success. NULL if an error occurs.
 *
 *  @sa     HWA_init()
 *  @sa     HWA_close()
 */
extern HWA_Handle HWA_open(uint32_t index, HWA_OpenConfig * hwaCfg, int32_t* errCode);

/**
 *  \brief  Function to close a HWA peripheral specified by the HWA handle
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle      A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_close(HWA_Handle handle);

/**
 *  \brief  Function to reset the internal state machine of the HWA
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_reset(HWA_Handle handle);

/**
*  \brief  Function to initialize RAM memory banks in HWA
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*  @param  ramMemBankMask  Bit mask to specify HWA MEM BANK,
*                           see \ref HWA_APP_MEMINIT_CFG for correct values
*                           HWA_APP_MEMINIT_PARAM_RAM
*                           HWA_APP_MEMINIT_WINDOW_RAM
*                           HWA_APP_MEMINIT_PER_SAMPLE_MAX_VAL_EVEN_RAM
*                           HWA_APP_MEMINIT_PER_SAMPLE_MAX_VAL_ODD_RAM
*                           HWA_APP_MEMINIT_PER_ITER_MAX_VAL_RAM
*                           HWA_APP_MEMINIT_HIST_EVEN_RAM
*                           HWA_APP_MEMINIT_HIST_ODD_RAM
*                           HWA_APP_MEMINIT_MEMBANK_ALL
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_initializeRAM(HWA_Handle handle, uint32_t ramMemBankMask);

/**
 *  \brief  Function to returns the HWA common control base address
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *
 *  @return Common control base address upon success else NULL on failure
 *
 *  @sa     HWA_open()
 */
extern DSSHWACCRegs *HWA_getCommonCtrlAddr(HWA_Handle handle);

/**
 *  \brief  Function to returns the HWA paramSet base address
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx     A valid paramSet index for which the base address is returned.
 *
 *
 *  @return Param set address upon success else NULL on failure
 *
 *  @sa     HWA_open()
 */
extern DSSHWACCPARAMRegs *HWA_getParamSetAddr(HWA_Handle handle, uint8_t paramsetIdx);

/**
 *  \brief  Function to set the common HWA configuration parameters
 *          needed for the next operations/iterations/paramsets of HWA
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  commonConfig    HWA Common Config Parameters
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configCommon(HWA_Handle handle, HWA_CommonConfig *commonConfig);

/**
 *  \brief  Function to set the HWA configuration parameters for a given paramSet
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx     A valid paramSet index for which the paramConfig is provided.
 *
 *  @param  paramConfig     HWA ParamSet Config Parameters
 *
 *  @param  dmaConfig       [out] This parameter is set by the driver with values that user
 *                                should use to program the source trigger DMA. user should provide
 *                                a valid buffer here if the triggerMode is set to DMA in paramConfig
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configParamSet(HWA_Handle handle, uint8_t paramsetIdx, HWA_ParamConfig *paramConfig, HWA_SrcDMAConfig *dmaConfig);

/**
*  \brief  Function to get the config to program the DMA for a given DMA Trigger channel.
*          Application should use the returned config to program the DMA so that it can then
*          in turn trigger the paramset. Application should make sure that the channel provided
*          here in dmaTriggerSrc should match the \ref HWA_ParamConfig::triggerSrc passed
*          to HWA_configParamSet()
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  dmaTriggerSrc   Same as \ref HWA_ParamConfig::triggerSrc of the paramset for
*                          whom this DMA is getting configured
*
*  @param  dmaConfig       [out]This parameter is set by the driver with values that user
*                               should use to program the source trigger DMA. user should provide
*                               a valid buffer here if the triggerMode is set to DMA in paramConfig
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_getDMAconfig(HWA_Handle handle, uint8_t dmaTriggerSrc, HWA_SrcDMAConfig *dmaConfig);

/**
 *  \brief  Function to set the HWA RAM : HWA_RAM_TYPE_WINDOW_RAM, HWA_RAM_TYPE_VECTORMULTIPLY_RAM, HWA_RAM_TYPE_LUT_FREQ_DEROTATE_RAM or HWA_RAM_TYPE_SHUFFLE_RAM
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  ramType         Use defines \ref HWA_RAM_TYPE
 *
 *  @param  data            data pointer that needs to be copied to RAM
 *
 *  @param  dataSize        Size of data to be copied in size of bytes
 *
 *  @param  startIdx        start index (in terms of bytes) within RAM where data needs to be copied
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configRam(HWA_Handle handle, uint8_t ramType, uint8_t *data, uint32_t dataSize, uint32_t startIdx);

/**
*  \brief  Function to get the RAM starting address for one specified RAM type
*
*  @param  ramType           the RAM type see \ref HWA_RAM_TYPE for correct RAM types defined in HWA
*
*  @return the RAM starting address, or NULL if error occurs
*
*  @sa     HWA_open()
*/
extern uint32_t HWA_getRamAddress(uint8_t ramType);

/**
*  \brief  Function to read the HWA 2D statistics output RAM, including HWA_RAM_TYPE_2DSTAT_ITER_VAL, HWA_RAM_TYPE_2DSTAT_ITER_IDX, HWA_RAM_TYPE_2DSTAT_SAMPLE_VAL, HWA_RAM_TYPE_2DSTAT_SAMPLE_IDX
*   or HWA_RAM_TYPE_HISTOGRAM_RAM, except the HWA_RAM_TYPE_HIST_THRESH_RAM
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  ramType         Use defines \ref HWA_RAM_TYPE, except HWA_RAM_TYPE_HIST_THRESH_RAM
*
*  @param  data            data pointer that needs to be copied to RAM
*
*  @param  dataSize        Size of data to be copied in size of bytes
*
*  @param  startIdx        start index (in terms of bytes) within RAM where data needs to be copied
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_readRam(HWA_Handle handle, uint8_t ramType, uint8_t *data, uint32_t dataSize, uint32_t startIdx);

/**
*  \brief  Function to read the HWA HWA_RAM_TYPE_HIST_THRESH_RAM RAM
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*
*  @param  cdfThresholdResult   buffer the CDF threshold results see \ref HWA_CdfThreshold,
*
*  @param  numSampleIndices    the number of sample indices, which needs to be read out.
*
*  @param  startSampleIdx    the start sample indice
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_readHistThresholdRam(HWA_Handle handle, HWA_CdfThreshold *cdfThresholdResult, uint8_t numSampleIndices, uint8_t startSampleIdx);

/**
 *  \brief  Function to enable the CPU and/or DMA interrupt after a paramSet completion.
 *          The CPU interrupt for every paramset completion may not be supported on all
 *          devices - see \ref HWA_Attrs::isConcurrentAccessAllowed
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx     A valid paramSet index for which the intrConfig is provided.
 *
 *  @param  intrConfig      HWA Interrupt Config Parameters
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enableParamSetInterrupt(HWA_Handle handle, uint8_t paramsetIdx, HWA_InterruptConfig *intrConfig);

/**
*  \brief  Function to poll the PARAM_DONE_SET_STATUS_0 and PARAM_DONE_SET_STATUS_1 registers to check if the
*          specified paramsets are finished.
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  numParamSets    number of paramsets need to poll.
*
*  @param  paramsetsArray  the specified paramset array
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_paramSetDonePolling(HWA_Handle handle, uint8_t numParamSets, uint8_t *paramsetsArray);

/**
*  \brief  Function to poll the PARAM_DONE_SET_STATUS_0 or PARAM_DONE_SET_STATUS_1 registers to check if one single
*          specified paramset is finished.
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  paramsetIndex    the specified paramset index
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_singleParamSetDonePolling(HWA_Handle handle, uint8_t paramsetIndex);

/**
 *  \brief  Function to enable the CPU interrupt after all programmed paramSets have been completed in the background or ALT thread.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  threadIdx       the thread Idx, see \ref HWA_THREAD for the correct value
 *
 *  @param  callbackFn      user defined callback function to be called when this interrupt is generated
 *
 *  @param  callbackArg     user defined callback arg for the callback function
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enableDoneInterrupt(HWA_Handle handle, uint8_t threadIdx, HWA_Done_IntHandlerFuncPTR callbackFn, void * callbackArg);

/**
 *  \brief  Function to disable the CPU and/or DMA interrupt after a paramSet completion.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle              A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx         A valid paramSet index for which the interrupt is to be disabled
 *
 *  @param  interruptTypeFlag   Flag to indicate if CPU and/or DMA interrupts are to be disabled
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_disableParamSetInterrupt(HWA_Handle handle, uint8_t paramsetIdx, uint8_t interruptTypeFlag);

/**
 *  \brief  Function to disable the CPU interrupt after all programmed paramSets have been completed.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  threadIdx       the thread Idx, see \ref HWA_THREAD for the correct value
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_disableDoneInterrupt(HWA_Handle handle, uint8_t threadIdx);

/**
 *  \brief  Function to enable the state machine of the HWA. This should be called after
 *          paramset and RAM have been programmed
 *
 *  @pre    HWA_open() HWA_ConfigCommon() HWA_ConfigParamSet HWA_ConfigRam has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  flagEnDis       Enable/Disable Flag: 0-disable, 1-enable
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enable(HWA_Handle handle, uint8_t flagEnDis);

/**
*  \brief  Function to enable or disable the context switching in hwa
*
*  @pre    HWA_open() HWA_ConfigCommon() HWA_ConfigParamSet HWA_ConfigRam and HWA_enable has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  flagEnDis       Enable/Disable Flag: 0-disable, 1-enable
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_enableContextSwitch()
*/
extern int32_t HWA_enableContextSwitch(HWA_Handle handle, uint8_t flagEnDis);

/**
*  \brief  Function to manually trigger the execution of the state machine via software,
*           the software trigger through either FW2HWA_TRIG_0 or FW2HWA_TRIG_1 register
*           if the trigger is set to HWA_TRIG_MODE_SOFTWARE from DSP, trigger is done through FW2HWA_TRIG_0
*           if the trigger is set to HWA_TRIG_MODE_M4CONTROL from M4, trigger is done through FW2HWA_TRIG_1
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_setSoftwareTrigger(HWA_Handle handle);

/**
*  \brief  Function to manually trigger the execution of the state machine via software in context switch,
*           the software trigger through CS_FW2ACC_TRIG register
*
*  @pre    HWA_open() and HWA_enableContextSwitch() have been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_setContextswitchSoftwareTrigger(HWA_Handle handle);

/**
*  \brief  Function to manually trigger the execution of the state machine via DMA trigger in context switch
*
*  @pre    HWA_open() and HWA_enableContextSwitch() have been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  idx            DMA channel number for whom software should simulate the trigger
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_setContextswitchDMAManualTrigger(HWA_Handle handle,uint8_t idx);

/**
*  \brief  Function for sofware to reset the DC accumulators or interference statistics accumulators
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*  @param  accumulatortype  see maros \ref HWA_ACCUMULATORREG_TYPE, takes value either HWA_ACCUMULATORREG_TYPE_DC
*                           or HWA_ACCUMULATORREG_TYPE_INTERF
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_softwareResetAccumulators(HWA_Handle handle, uint8_t accumulatortype);

/**
*  \brief  Function resets the paramset counter used in recurise windowing mode with REC_WIN_MODE_SEL is set to 1
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_softwareResetRecursiveWinKvalue(HWA_Handle handle);

/**
*  \brief  Function resets the execution counter if complex multiply is configured as frequency shifter mode with frequency increment (mode 10)
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_softwareResetTwidIncrDeltaFrac(HWA_Handle handle);

/**
 *  \brief  Function to manually trigger the execution of the state machine waiting on DMA via software
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  idx            DMA channel number for whom software should simulate the trigger
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_setDMA2ACCManualTrig(HWA_Handle handle, uint8_t idx);

/**
*  \brief  Function to set the source address for one paramset
*
*  @pre    HWA_open() has been called.
*
*  @param  handle             A HWA_Handle returned from HWA_open()
*
*  @param  paramIdx           the paramset index
*
*  @param  sourceAddress      source address
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_setSourceAddress(HWA_Handle handle, uint16_t paramIdx, uint32_t sourceAddress);

/**
*  \brief  Function to read the Clip Status registers
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  clipStatusResult  the clip status result
*                        if it is HWA_CLIPREG_TYPE_DCACC, the 12 lsb are the clip status of bot I / Q of DC acculuators 0 to 11
*                        if it is HWA_CLIPREG_TYPE_DCEST, the 12 lsb are the clip sttus of DC estimatsion(both I / Q combined)
*                        if it is HWA_CLIPREG_TYPE_DCSUB, the last lsb is the DC subtraction clip status
*                        if it is HWA_CLIPREG_TYPE_INTFSTATS_MAGACC or HWA_CLIPREG_TYPE_INTFSTATS_MAGDIFFACC, the 12 lsb are the interference magnitude or magnitude diff accumulator clip status
*                        if it is HWA_CLIPREG_TYPE_INTFSTATS_MAGSUM or HWA_CLIPREG_TYPE_INTFSTATS_MAGDIFFSUM, the 1 bit in lsb is the interference magnitude sum or magnitude diff sum clip status
*                        if it is HWA_CLIPREG_TYPE_INTFSTATS_MAGTHRESHOLD or HWA_CLIPREG_TYPE_INTFSTATS_MAGDIFFTHRESHOLD, the 12 lsb are the interference magnitude difference threshold clip status
*                        if it is HWA_CLIPREG_TYPE_TWIDINCR_DELTAFRAC, the last 1 lsb is the clip status for TWID_INCR_DELTA_FRAC accumulator
*                        if it is HWA_CLIPREG_TYPE_CHANCOMB, the last lsb is the clip status of the channel combination
*                        if it is HWA_CLIPREG_TYPE_FFT, the last 13 lsb indicates any saturation / clipping for each FFT butterfly stages
*                        if it is HWA_CLIPREG_TYPE_INPUTFORMAT or HWA_CLIPREG_TYPE_OUTPUTFORMAT, the alst lsb is the clip stauts for input or output formatter
*
*  @param  type            see \ref HWA_CLIPREG_TYPE macro for correct clip register values .
*
*  @return 0 upon success.error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readClipStatus(HWA_Handle handle, uint16_t *clipStatusResult, uint8_t type);

/**
 *  \brief  Function to clear the Clip Status registers
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *  @param  type            see \ref HWA_CLIPREG_TYPE macro for correct clip register values .
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_clearClipStatus(HWA_Handle handle, uint8_t type);

/**
 *  \brief  Function to read the 4 sets of 'MAX' statistics register
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pStats          pointer to a memory of type HWA_Stats where value of all the
 *                          Max and statistics Registers would be copied
 *
 *  @param  numIter         number of iterations to read. Value 1-4 should be provided.
 *                          User is expected to provide enough space for the pStats to hold 'numIter' worth of HWA_Stats
 *                          Ex: HWA_Stats appHWAStats[3]; HWA_readStatsReg(appHWAhandle,appHWAStats,3);
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_readStatsReg(HWA_Handle handle, HWA_Stats *pStats, uint8_t numIter);

/**
 *  \brief  Function to read the PEAKCNT register
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pbuf            pointer to a memory where value of the
 *                          PEAKCNT Registers would be copied
 *
 *  @param  size            size (in bytes) of the pbuf register provided.
 *                          It should be atleast 2 bytes.
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_readCFARPeakCountReg(HWA_Handle handle, uint8_t *pbuf, uint8_t size);

/**
 *  \brief  Function to read the debug registers (paramcurr, loopcou, acc_trig_in_stat)
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pStats          pointer to a memory of type HWA_debugStats where value of the
 *                          RDSTATUS and HWACCREG12 Registers would be copied
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_readDebugReg(HWA_Handle handle, HWA_DebugStats *pStats);

/**
 *  \brief  Function to clear the debug registers (acc_trig_in_clr)
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_clearDebugReg(HWA_Handle handle);

/**
 *  \brief  Function to get HWA processing Memory information including address,
 *          size and number of banks.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  memInfo         Pointer to save HWA processing memory information
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getHWAMemInfo(HWA_Handle handle, HWA_MemInfo *memInfo);

/**
 *  \brief  Function to get the dma destination index with a given EDMA channel number
 *          This function assumes the EDMA channel number is from the first EDMA instance.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  edmaChanId      EDMA channell id
 *
 *  @param  hwaDestChan     Pointer to save destination channel index
 *
 *  @return     =0          Success
 *              <0          Error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getDMAChanIndex(HWA_Handle handle, uint8_t edmaChanId, uint8_t *hwaDestChan);

/**
 *  \brief  Function to get the edma EDMA channel number from a given HWA paramset destination channel.
 *          This function assumes the EDMA channel number is from the first EDMA instance.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  hwaDMAdestChan  Destination channle id set in a paramset
 *
 *  @return     >=0         Upon success, EDMA channel number
 *              <0          Error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getEDMAChanId(HWA_Handle handle, uint8_t hwaDMAdestChan);

/**
*  \brief  Function to read the DC_EST_I/Q register
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  pbuf            pointer to a memory where value of the
*                          DC_EST_I/Q Registers would be copied, even element is I value, and odd element is Q value
*
*  @param  startIdx        The estimated DC results for the first RX channel Idx, must be less than 11.
*
*  @param  size            The number of Rx channels needed to be read.
*                          It should be less than 12.
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readDCEstimateReg(HWA_Handle handle, cmplx32ImRe_t *pbuf, uint8_t startIdx, uint8_t size);

/**
*  \brief  Function to read the interference threshold MAG or MAGDIFF Accumulator register
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  accBuf          pointer to the accumulator result buffer for MAG or MAGDIFF
*
*  @param  type            see \ref HWA_INTERFERENCE_THRESHOLD_TYPE macro for the either MAG or MAGDIFF accumulator .
*
*  @param  startIdx        The first accumulator channel needs to be read, must be less than 11.
*
*  @param  size            The number of channels needed to be read.
*                          It should be less than 12.
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readIntfAccReg(HWA_Handle handle, uint64_t *accBuf, uint8_t type, uint8_t startIdx, uint8_t size);

/**
*  \brief  Function to read the DC estimation accumulator register,
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  accbuf           pointer to a memory for accumulator results.
*
*  @param  startIdx        The first accumulator channel needs to be read, must be less than 11.
*
*  @param  size            The number of channels needed to be read.
*                          It should be less than 12.
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readDCAccReg(HWA_Handle handle, cmplx64ImRe_t *accbuf,  uint8_t startIdx, uint8_t size);

/**
*  \brief  Function to read the number of samples that exceeded the threshold in a chirp
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  numInterfSamplesChirp       number of samples that exceeded the interference threshold in a chirp
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readInterfChirpCountReg(HWA_Handle handle, uint16_t *numInterfSamplesChirp);

/**
*  \brief  Function to read the number of samples that exceeded the threshold in a frame
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  numInterfSamplesFrame    number of samples exceeded the interference threshold in a frame
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readInterfFrameCountReg(HWA_Handle handle, uint32_t *numInterfSamplesFrame);

/**
*  \brief  Function to read the interference statistics INTF_LOC_THRESH_MAG_VAL or INTF_LOC_THRESH_MAG_VAL registers
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  pbuf            pointer to a memory where the register values are copied into
*
*  @param  startIdx        The first channel index needs to be read, must be less than 11.
*
*  @param  size            The number of channels needed to be read.
*                          It should be less than 12.
*  @param  type            see \ref HWA_INTERFERENCE_THRESHOLD_TYPE for correct values
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readInterfThreshReg(HWA_Handle handle, uint32_t *pbuf, uint8_t startIdx, uint8_t size, uint8_t type);

/**
*  \brief  Function to control the suspend mode of the peripheral when the controlling processor (where this driver is instantiated) is halted
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  flagEnDis       0- HWA is not suspended and continues to run in the background even when controlling processor is halted
*                          1- HWA is suspended/halted when controlling processor is halted
*  @return 0 upon success. error code if an error occurs.
*
*/
extern int32_t  HWA_controlPeripheralSuspendMode(HWA_Handle handle, uint8_t flagEnDis);

/*!
*  @brief  Function to enable/disable single-stepping approach which pauses the HWA execution after each param-set.
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  flagEnDis       0- Disables single stepping approach
*                          1- Enabled single stepping approach
*  @return 0 upon success. error code if an error occurs.
*
*/
extern int32_t  HWA_configureSingleStep(HWA_Handle handle, uint8_t flagEnDis);

/*!
*  @brief  Function to Trigger single-step. This triggers state machine to execute one parameter-set at a time and
*          wait for the next single step trigger.
*
*  @pre    HWA_open(), HWA_configureSingleStep() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @return 0 upon success. error code if an error occurs.
*
*/
extern int32_t  HWA_triggerSingleStep(HWA_Handle handle);

/** @} */  /* end of addgroup HWA_DRIVER_EXTERNAL_FUNCTION*/

#ifdef __cplusplus
}
#endif

#endif /* HWA_H_ */



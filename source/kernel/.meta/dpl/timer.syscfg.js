
let common = system.getScript("/common");
let soc = system.getScript(`/kernel/dpl/timer_${common.getSocName()}`);
let hwi = system.getScript("/kernel/dpl/hwi.js");

function getStaticConfigArr() {
    return soc.getStaticConfigArr();
}

function getInstanceConfig(moduleInstance) {
    let solution = moduleInstance[getInterfaceName(moduleInstance)].$solution;
    let staticConfigArr = getStaticConfigArr();
    let staticConfig = staticConfigArr.find( o => o.timerName === solution.peripheralName);

    let clkSelMuxValue = soc.getTimerClockSourceValue(moduleInstance);

    return {
        ...staticConfig,
        ...moduleInstance,
        clkSelMuxValue : clkSelMuxValue,
        usecPerTick : Math.trunc( moduleInstance.usecPerTick ),
        nsecPerTick : Math.trunc( moduleInstance.usecPerTick * 1000 ),
        actualNsecPerTick : Math.trunc( moduleInstance.actualUsecPerTick * 1000 ),
    }
};

function timerFilter(peripheral) {
    /* timers used by ClockP */
    let blocked_timers = soc.getBlockedTimers();
    let found = blocked_timers.find(
        function(str) {
            return str == peripheral.name;
        }
    );
    return ! found;
}

function pinmuxRequirements(inst) {
    let interfaceName = getInterfaceName(inst);

    let peripheral = {
        name          : interfaceName,
        displayName   : "Timer Instance",
        interfaceName : interfaceName,
        filter        : timerFilter,
        resources     : [],
    };

    return [peripheral];
}

function getInterfaceName(inst) {
    return soc.getInterfaceName(inst);
}

function validate(instance, report) {
    common.validate.checkNumberRange(instance, report, "usecPerTick", 1, 1000000, "dec");
    common.validate.checkNumberRange(instance, report, "timerInputClkHz", 32000, 1000000000, "dec");
    common.validate.checkValidCName(instance, report, "timerCallback");
    common.validate.checkNumberRange(instance, report, "intrPriority", 0, hwi.getHwiMaxPriority(), "dec");
}

/* some timers dont support one shot mode, dont show this config for such timers */
function oneShotModeConfig()
{
    let config = {
        name: "enableOneShotMode",
        displayName: "One-Shot Mode Enable",
        default: false,
        description: `Select one-shot mode, or periodic mode`,
        readOnly: false,
    };

    if(soc.oneShotModeSupport === false)
    {
        config.default = false;
        config.hidden = true;
    }
    return config;
}

/* some timers dont support DMA trigger, dont show this config for such timers */
function dmaTriggerSupport()
{
    let config = {
        name: "enableDmaTrigger",
        displayName: "DMA Trigger Enable",
        default: false,
        description: `Enabel DMA Trigger from Timer`,
        readOnly: false,
    };

    if(soc.dmaTriggerSupport === false)
    {
        config.default = false;
        config.hidden = true;
    }
    return config;
}

function onChangeUsecPerTick(instance, ui)
{
    let requiredNsecs = Math.trunc( instance.usecPerTick * 1000 );
    let timerCycles   = Math.trunc( instance.timerInputClkHz * requiredNsecs / 1000000000 );
    let actualNsecs   = Math.trunc( (1000000000 / instance.timerInputClkHz) * timerCycles );

    instance.actualUsecPerTick  = actualNsecs / 1000;
}

function onChangeClkSource(instance, ui)
{
    instance.timerInputClkHz  = soc.getTimerClockSourceHz( instance.clkSource );

    onChangeUsecPerTick(instance, ui);
}

let timer_module_name = "/drivers/timer/timer";

let timer_module = {
    displayName: "TIMER",
    longDescription:
`This module allows a user to setup a HW timer on the SOC. Some timers will be reserved for
 use by Clock module, which is used for periodic OS tick.
 So you will not see all timers listed in this module.

 Further, when interrupt is enabled, user needs to implement the ISR function specified
in the UI. User need not clear the interrupt and overflow status at the timer, that is
done by the code generated by SysConfig. For example,

    uint32_t gTimerCount = 0;

    void myISR(void *args)
    {
        gTimerCount++;
    }

To pass argument to the ISR, call the below function with the argument you want to pass, before starting the
timer, in this case you should not start timer via SysConfig UI option but instead start it
 as shown in below example.

    struct MyArgs {
        uint32_t arg1;
        uint32_t arg2;
    } gMyArgs;

    HwiP_setArgs(&gTimerHwiObj[CONFIG_TIMER0], &gMyArgs);
    TimerP_start(&gTimerHwiObj[CONFIG_TIMER0]
`,
    templates: {
        "/kernel/dpl/dpl_config.c.xdt": {
            dpl_config: "/kernel/dpl/timer.c.xdt",
            dpl_init: "/kernel/dpl/timer_init.c.xdt",
            dpl_deinit: "/kernel/dpl/timer_deinit.c.xdt",
        },
        "/kernel/dpl/dpl_config.h.xdt": "/kernel/dpl/timer.h.xdt",
    },
    config: [
        {
            name: "timerInputClkHz",
            displayName: "Input Clock Frequency (Hz)",
            default: soc.getTimerClockSourceHz( soc.getTimerClockSourceConfigArr()[0].name ),
            description: "Make sure the value put here matches the actual input clock frequency provided on the board/SOC"
        },
        {
            name: "clkSource",
            displayName: "Input Clock Source",
            default: soc.getTimerClockSourceConfigArr()[0].name,
            options: soc.getTimerClockSourceConfigArr(),
            onChange: onChangeClkSource,
        },
        {
            name: "usecPerTick",
            displayName: "Tick Period (usecs)",
            default: 1000,
            description: "Timer tick period in units of usecs. MUST be >= 1.000 and <= 1000000.0000",
            longDescription: "Decimal values to get time periods in units of nsecs is allowed. eg. 15.625 usecs",
            onChange: onChangeUsecPerTick,
        },
        {
            name: "actualUsecPerTick",
            displayName: "Actual Tick Period (usecs)",
            default: 1000,
            description: "This is the actual time period for which the timer will be configured.",
            longDescription: "The actual value may not match required value if the input clock Hz precision is not high enough to get the required timer resolution",
            readOnly: true,
        },
        oneShotModeConfig(),
        dmaTriggerSupport(),
        {
            name: "startTimer",
            displayName: "Start Timer After Setup",
            default: false,
            description: `Check this to start the timer operation after config`,
            longDescription: "If timer is not started via this checkbox, then you can start the timer by doing `TimerP_start()` later"
        },
        {
            name: "enableIntr",
            displayName: "Interrupt Mode Enable",
            default: true,
        },
        {
            name: "intrPriority",
            displayName: "Interrupt Priority",
            default: 4,
            description: `Interrupt Priority: 0 (highest) to ${hwi.getHwiMaxPriority()} (lowest)`,
        },
        {
            name: "timerCallback",
            displayName: "Timer Callback",
            default: "NULL",
            description: "Callback function to call when timer expires",
        },
    ],
    defaultInstanceName: "CONFIG_TIMER",
    validate: validate,
    modules: function(inst) {
        return [{
            name: "system_common",
            moduleName: "/system_common",
        }]
    },
    pinmuxRequirements,
    getInstanceConfig,
    getInterfaceName,
};

exports = timer_module;

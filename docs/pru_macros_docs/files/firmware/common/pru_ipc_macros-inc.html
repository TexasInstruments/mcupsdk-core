<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>pru_ipc_macros.inc</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css" /><script type="text/javascript" src="../../../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../../../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.1.1 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="pru_ipc_macros.inc"></a><a name="Topic7"></a><div class="CTopic TFile LAssembly first">
 <div class="CTitle">pru_ipc_macros.inc</div>
 <div class="CBody"><div class="CHeading">Register Memory Used</div><p>26 Bytes (6.5 regs)</p><div class="CHeading">DRAM Memory Used</div><p>(8 + 4*noOfBuffers) Bytes</p></div>
</div>

<a name="s_PruIpc_config"></a><a name="Topic8"></a><div class="CTopic TStruct LAssembly">
 <div class="CTitle">s_PruIpc_config</div>
 <div class="CBody"><p>Strucutre to store the configurable parameters for the Pru Ipc Instance</p><div class="CHeading">Size</div><p>5 bytes</p><div class="CHeading">Elements</div><table class="CDefinitionList"><tr><td class="CDLEntry">blockSize</td><td class="CDLDefinition"><p>Number of data packets per Block</p></td></tr><tr><td class="CDLEntry">noOfBlocks</td><td class="CDLDefinition"><p>Number of Blocks per Buffer</p></td></tr><tr><td class="CDLEntry">noOfBuffers</td><td class="CDLDefinition"><p>Maximum Number of Active Buffers</p></td></tr></table><div class="CHeading">See Also</div><table class="CDefinitionList"><tr><td class="CDLEntry">dataSize</td><td class="CDLDefinition"><p>Size of the data packets</p></td></tr></table></div>
</div>

<a name="s_PruIpc_iterator"></a><a name="Topic9"></a><div class="CTopic TStruct LAssembly">
 <div class="CTitle">s_PruIpc_iterator</div>
 <div class="CBody"><p>Strucutre to store the iterators for the Pru Ipc Instance</p><div class="CHeading">Size</div><p>9 bytes</p><div class="CHeading">Elements</div><table class="CDefinitionList"><tr><td class="CDLEntry">packet</td><td class="CDLDefinition"><p>To track data packet index</p></td></tr><tr><td class="CDLEntry">block</td><td class="CDLDefinition"><p>To track block index</p></td></tr><tr><td class="CDLEntry">buffer</td><td class="CDLDefinition"><p>To track buffer index</p></td></tr><tr><td class="CDLEntry">idxInBlock</td><td class="CDLDefinition"><p>To track index inside blocks</p></td></tr></table><div class="CHeading">See Also</div></div>
</div>

<a name="s_PruIpc_register"></a><a name="Topic10"></a><div class="CTopic TStruct LAssembly">
 <div class="CTitle">s_PruIpc_register</div>
 <div class="CBody"><p>Strucutre to store temporary registers for the Pru Ipc Instance</p><div class="CHeading">Size</div><p>6 bytes</p><div class="CHeading">Elements</div><table class="CDefinitionList"><tr><td class="CDLEntry">bufferBaseAddr</td><td class="CDLDefinition"><p>Stores base address for buffer buffers</p></td></tr><tr><td class="CDLEntry">bufferOffset</td><td class="CDLDefinition"><p>Stores memory offset for TMP.bufferBaseAddr</p></td></tr></table><div class="CHeading">See Also</div></div>
</div>

<a name="s_PruIpc_register.Macros"></a><a name="Topic11"></a><div class="CTopic TGroup LAssembly">
 <div class="CTitle">Macros</div>
</div>

<a name="s_PruIpc_register.m_pru_ipc_init"></a><a name="Topic213"></a><div class="CTopic TMacro LAssembly">
 <div class="CTitle">m_pru_ipc_init</div>
 <div class="CBody"><p>Initialization code when the Pru Ipc is started</p><p>PEAK cycles: 11 cycle</p><div class="CHeading">Invokes</div><p>None</p><p>Pseudo code:</p><pre>memcpy(offset(dataSize), PRU_IPC_CONFIG_MEM + DATASIZE_OFFSET, <span class="SHNumber">1</span>);<br />memcpy(offset(CFG.blockSize), PRU_IPC_CONFIG_MEM + BLOCKSIZE_OFFSET, <span class="SHNumber">4</span>);<br />ITR = <span class="SHNumber">0</span>;</pre><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">dataSize</td><td class="CDLDefinition"><p>Size of the data packets (must dataSize = bx)</p></td></tr><tr><td class="CDLEntry">baseMemAddr</td><td class="CDLDefinition"><p>register for storing BASE_MEM_ADDR in</p></td></tr><tr><td class="CDLEntry">BASE_MEM_ADDR</td><td class="CDLDefinition"><p>Base addr of config memory Returns: None</p></td></tr></table><div class="CHeading">See Also</div></div>
</div>

<a name="s_PruIpc_register.m_pru_ipc_send"></a><a name="Topic214"></a><div class="CTopic TMacro LAssembly">
 <div class="CTitle">m_pru_ipc_send</div>
 <div class="CBody"><p>Sends the data packets to the shared memory for each Buffer Creates interrupt event for r5f core to read data packets.</p><p>PEAK cycles: (15 + 10*noOfBuffers) cycle</p><div class="CHeading">Invokes</div><p>None</p><p>Pseudo code:</p><pre><span class="SHKeyword">for</span> (ITR.buffer = <span class="SHNumber">0</span>, TMP.bufferOffset = BUFFERBASE_OFFSET;<br />                            ITR.buffer &lt; CFG.noOfBuffers;<br />                             ITR.buffer++, TMP.bufferOffset+=<span class="SHNumber">4</span>) {<br />    dataReg = *dataRegBaseAddr++;<br />    memcpy(offset(TMP.bufferBaseAddr), PRU_IPC_CONFIG_MEM + TMP.bufferOffset, <span class="SHNumber">4</span>);<br />    <span class="SHKeyword">if</span> (TMP.bufferBaseAddr == <span class="SHNumber">0</span>)     <span class="SHKeyword">continue</span>;<br />    memcpy(offset(dataReg), TMP.bufferBaseAddr + ITR.packet, dataSize);<br />}<br />ITR.packet += dataSize;<br />ITR.idxInBlock++;<br /><br /><span class="SHKeyword">if</span> (ITR.idxInBlock == CFG.blockSize) {<br />    memcpy(offset(ITR.block), PRU_IPC_CONFIG_MEM + BLOCKID_OFFSET, <span class="SHNumber">1</span>);<br />    r31.b0 = INT_NUM;  <span class="SHComment">// generate interrupt</span><br />    ITR.idxInBlock = <span class="SHNumber">0</span>;<br />    ITR.block++;<br />    <span class="SHKeyword">if</span> (ITR.block == CFG.noOfBlocks) {<br />        ITR.block  = <span class="SHNumber">0</span><br />        ITR.packet = <span class="SHNumber">0</span><br />    }<br />}</pre><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">dataRegBaseAddr</td><td class="CDLDefinition"><p>(8 bits) Address of starting ADC data register (&amp;ADC_DATA_REG_1) {ADC_DATA_REG_1, ADC_DATA_REG_2, .... ADC_DATA_REG_N} =&gt; register R1.bx must be used</p></td></tr><tr><td class="CDLEntry">dataReg</td><td class="CDLDefinition"><p>Data stored in ADC_DATA_REG_X, Can pass ADC_DATA_REG_0</p></td></tr><tr><td class="CDLEntry">dataSize</td><td class="CDLDefinition"><p>Size of the data packets (must dataSize = bx)</p></td></tr><tr><td class="CDLEntry">INTR_ENABLE</td><td class="CDLDefinition"><p>Enable interrupt trigger to specified event</p></td></tr><tr><td class="CDLEntry">INTR_NUM</td><td class="CDLDefinition"><p>Interrupt value to write to R31 to trigger interrupt event</p></td></tr></table><div class="CHeading">Returns</div><p>None</p><div class="CHeading">See Also</div></div>
</div>

<a name="s_PruIpc_register.m_pru_ipc_rcv"></a><a name="Topic236"></a><div class="CTopic TMacro LAssembly last">
 <div class="CTitle">m_pru_ipc_rcv</div>
 <div class="CBody"><p>Receives the data packets from the shared memory for each Buffer Handles interrupt event from r5f core, to read data packets.</p><p>PEAK cycles: (15 + 10*noOfBuffers) cycle</p><div class="CHeading">Invokes</div><p>None</p><p>Pseudo code:</p><pre><span class="SHKeyword">for</span> (ITR.buffer = <span class="SHNumber">0</span>, TMP.bufferOffset = BUFFERBASE_OFFSET;<br />                            ITR.buffer &lt; CFG.noOfBuffers;<br />                             ITR.buffer++, TMP.bufferOffset+=<span class="SHNumber">4</span>) {<br />    dataReg = *dataRegBaseAddr++;<br />    memcpy(offset(TMP.bufferBaseAddr), PRU_IPC_CONFIG_MEM + TMP.bufferOffset, <span class="SHNumber">4</span>);<br />    <span class="SHKeyword">if</span> (TMP.bufferBaseAddr == <span class="SHNumber">0</span>)     <span class="SHKeyword">continue</span>;<br />    memcpy(TMP.bufferBaseAddr + ITR.packet, offset(dataReg), dataSize);<br />}<br />ITR.packet += dataSize;<br />ITR.idxInBlock++;<br /><br /><span class="SHKeyword">if</span> (ITR.idxInBlock == CFG.blockSize) {<br />    memcpy(offset(ITR.block), PRU_IPC_CONFIG_MEM + BLOCKID_OFFSET, <span class="SHNumber">1</span>);<br />    r31.b0 = INT_NUM;  <span class="SHComment">// generate interrupt</span><br />    ITR.idxInBlock = <span class="SHNumber">0</span>;<br />    ITR.block++;<br />    <span class="SHKeyword">if</span> (ITR.block == CFG.noOfBlocks) {<br />        ITR.block  = <span class="SHNumber">0</span><br />        ITR.packet = <span class="SHNumber">0</span><br />    }<br />}</pre><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">dataRegBaseAddr</td><td class="CDLDefinition"><p>(8 bits) Address of starting ADC data register (&amp;ADC_DATA_REG_1) {ADC_DATA_REG_1, ADC_DATA_REG_2, .... ADC_DATA_REG_N} =&gt; register R1.bx must be used</p></td></tr><tr><td class="CDLEntry">dataReg</td><td class="CDLDefinition"><p>Data stored in ADC_DATA_REG_X, Can pass ADC_DATA_REG_0</p></td></tr><tr><td class="CDLEntry">dataSize</td><td class="CDLDefinition"><p>Size of the data packets (must dataSize = bx)</p></td></tr><tr><td class="CDLEntry">INTR_ENABLE</td><td class="CDLDefinition"><p>Enable interrupt trigger to specified event</p></td></tr><tr><td class="CDLEntry">EVENT_NUM</td><td class="CDLDefinition"><p>Event number value on which interrupt will be generated</p></td></tr></table><div class="CHeading">Returns</div><p>None</p><div class="CHeading">See Also</div></div>
</div>

</body></html>
diff --git a/source/drivers/gpmc/v0/cslr_gpmc.h b/source/drivers/gpmc/v0/cslr_gpmc.h
new file mode 100644
index 0000000000..6f15578685
--- /dev/null
+++ b/source/drivers/gpmc/v0/cslr_gpmc.h
@@ -0,0 +1,1319 @@
+/********************************************************************
+ * Copyright (C) 2023 Texas Instruments Incorporated
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ *    Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the
+ *    distribution.
+ *
+ *    Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+*/
+#ifndef CSLR_GPMC_H
+#define CSLR_GPMC_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* ========================================================================== */
+/*                             Include Files                                  */
+/* ========================================================================== */
+#include <drivers/hw_include/cslr.h>
+#include <drivers/hw_include/tistdtypes.h>
+
+
+
+/**************************************************************************
+* Register Overlay Structure for BCH_RESULT
+**************************************************************************/
+typedef struct {
+    volatile Uint32 BCH_RESULT_0;
+    volatile Uint32 BCH_RESULT_1;
+    volatile Uint32 BCH_RESULT_2;
+    volatile Uint32 BCH_RESULT_3;
+} CSL_GpmcBch_resultRegs;
+
+
+/**************************************************************************
+* Register Overlay Structure for Trailer
+**************************************************************************/
+typedef struct {
+    volatile Uint32 BCH_SWDATA;
+} CSL_GpmcTrailerRegs;
+
+
+/**************************************************************************
+* Register Overlay Structure for BCH_RESULT_EXTENSION
+**************************************************************************/
+typedef struct {
+    volatile Uint32 BCH_RESULT_4;
+    volatile Uint32 BCH_RESULT_5;
+    volatile Uint32 BCH_RESULT_6;
+    volatile Uint8  RSVD0[4];
+} CSL_GpmcBch_result_extensionRegs;
+
+
+/**************************************************************************
+* Register Overlay Structure for CONFIG_BLOCK
+**************************************************************************/
+typedef struct {
+    volatile Uint32 CONFIG1;
+    volatile Uint32 CONFIG2;
+    volatile Uint32 CONFIG3;
+    volatile Uint32 CONFIG4;
+    volatile Uint32 CONFIG5;
+    volatile Uint32 CONFIG6;
+    volatile Uint32 CONFIG7;
+    volatile Uint32 NAND_COMMAND;
+    volatile Uint32 NAND_ADDRESS;
+    volatile Uint32 NAND_DATA;
+    volatile Uint8  RSVD0[8];
+} CSL_GpmcConfig_blockRegs;
+
+
+/**************************************************************************
+* Register Overlay Structure
+**************************************************************************/
+typedef struct {
+    volatile Uint32 REVISION;
+    volatile Uint8  RSVD1[12];
+    volatile Uint32 SYSCONFIG;
+    volatile Uint32 SYSSTATUS;
+    volatile Uint32 IRQSTATUS;
+    volatile Uint32 IRQENABLE;
+    volatile Uint8  RSVD2[32];
+    volatile Uint32 TIMEOUT_CONTROL;
+    volatile Uint32 ERR_ADDRESS;
+    volatile Uint32 ERR_TYPE;
+    volatile Uint8  RSVD3[4];
+    volatile Uint32 CONFIG;
+    volatile Uint32 STATUS;
+    volatile Uint8  RSVD4[8];
+    CSL_GpmcConfig_blockRegs	CONFIG_BLOCK[8];
+    volatile Uint32 PREFETCH_CONFIG1;
+    volatile Uint32 PREFETCH_CONFIG2;
+    volatile Uint8  RSVD5[4];
+    volatile Uint32 PREFETCH_CONTROL;
+    volatile Uint32 PREFETCH_STATUS;
+    volatile Uint32 ECC_CONFIG;
+    volatile Uint32 ECC_CONTROL;
+    volatile Uint32 ECC_SIZE_CONFIG;
+    volatile Uint32 ECC_RESULT[9];
+    volatile Uint8  RSVD6[12];
+    volatile Uint32 TESTMODE_CTRL;
+    volatile Uint8  RSVD7[12];
+    CSL_GpmcBch_resultRegs	BCH_RESULT[8];
+    volatile Uint8  RSVD8[16];
+    CSL_GpmcTrailerRegs	TRAILER;
+    volatile Uint8  RSVD9[44];
+    CSL_GpmcBch_result_extensionRegs	BCH_RESULT_EXTENSION[8];
+} CSL_GpmcRegs;
+
+
+
+
+/**************************************************************************
+* Register Macros
+**************************************************************************/
+
+/* This register contains the IP revision code */
+#define CSL_GPMC_REVISION                                       (0x0U)
+
+/* This register controls the various parameters of the OCP interface */
+#define CSL_GPMC_SYSCONFIG                                      (0x10U)
+
+/* This register provides status information about the module, excluding the
+ * interrupt status information */
+#define CSL_GPMC_SYSSTATUS                                      (0x14U)
+
+/* This interrupt status register regroups all the status of the module
+ * internal events that can generate an interrupt. */
+#define CSL_GPMC_IRQSTATUS                                      (0x18U)
+
+/* The interrupt enable register allows to mask/unmask the module internal
+ * sources of interrupt, on a event-by-event basis. */
+#define CSL_GPMC_IRQENABLE                                      (0x1CU)
+
+/* The GPMC_TIMEOUT_CONTROL register allows the user to set the start value of
+ * the timeout counter */
+#define CSL_GPMC_TIMEOUT_CONTROL                                (0x40U)
+
+/* The GPMC_ERR_ADDRESS register stores the address of the illegal access when
+ * an error occurs */
+#define CSL_GPMC_ERR_ADDRESS                                    (0x44U)
+
+/* The GPMC_ERR_TYPE register stores the type of error when an error occurs */
+#define CSL_GPMC_ERR_TYPE                                       (0x48U)
+
+/* The configuration register allows global configuration of the GPMC */
+#define CSL_GPMC_CONFIG                                         (0x50U)
+
+/* The status register provides global status bits of the GPMC */
+#define CSL_GPMC_STATUS                                         (0x54U)
+
+/* Prefetch engine configuration 1 */
+#define CSL_GPMC_PREFETCH_CONFIG1                               (0x1E0U)
+
+/* Prefetch engine configuration 2 */
+#define CSL_GPMC_PREFETCH_CONFIG2                               (0x1E4U)
+
+/* Prefetch engine control */
+#define CSL_GPMC_PREFETCH_CONTROL                               (0x1ECU)
+
+/* Prefetch engine status */
+#define CSL_GPMC_PREFETCH_STATUS                                (0x1F0U)
+
+/* ECC configuration */
+#define CSL_GPMC_ECC_CONFIG                                     (0x1F4U)
+
+/* ECC control */
+#define CSL_GPMC_ECC_CONTROL                                    (0x1F8U)
+
+/* ECC size */
+#define CSL_GPMC_ECC_SIZE_CONFIG                                (0x1FCU)
+
+/* ECC result register */
+#define CSL_GPMC_ECC_RESULT(i)                                  (0x200U + ((i) * (0x4U)))
+
+/* TestMode Control Register */
+#define CSL_GPMC_TESTMODE_CTRL                                  (0x230U)
+
+/* BCH ECC result, bits 0 to 31 */
+#define CSL_GPMC_BCH_RESULT_0(n)                                (0x240U + ((n) * (0x10U)))
+
+/* BCH ECC result, bits 32 to 63 */
+#define CSL_GPMC_BCH_RESULT_1(n)                                (0x244U + ((n) * (0x10U)))
+
+/* BCH ECC result, bits 64 to 95 */
+#define CSL_GPMC_BCH_RESULT_2(n)                                (0x248U + ((n) * (0x10U)))
+
+/* BCH ECC result, bits 96 to 127 */
+#define CSL_GPMC_BCH_RESULT_3(n)                                (0x24CU + ((n) * (0x10U)))
+
+/* This register is used to directly pass data to the BCH ECC calculator
+ * without accessing the actual NAND flash interface. */
+#define CSL_GPMC_BCH_SWDATA                                     (0x2D0U)
+
+/* BCH ECC result, bits 160 to 191 */
+#define CSL_GPMC_BCH_RESULT_5(n)                                (0x304U + ((n) * (0x10U)))
+
+/* BCH ECC result, bits 192 to 207 */
+#define CSL_GPMC_BCH_RESULT_6(n)                                (0x308U + ((n) * (0x10U)))
+
+/* BCH ECC result, bits 128 to 159 */
+#define CSL_GPMC_BCH_RESULT_4(n)                                (0x300U + ((n) * (0x10U)))
+
+/* The configuration 1 register sets signal control parameters per chip select */
+#define CSL_GPMC_CONFIG1(n)                                     (0x60U + ((n) * (0x30U)))
+
+/* Chip-select signal timing parameter configuration */
+#define CSL_GPMC_CONFIG2(n)                                     (0x64U + ((n) * (0x30U)))
+
+/* ADV# signal timing parameter configuration */
+#define CSL_GPMC_CONFIG3(n)                                     (0x68U + ((n) * (0x30U)))
+
+/* WE# and OE# signals timing parameter configuration */
+#define CSL_GPMC_CONFIG4(n)                                     (0x6CU + ((n) * (0x30U)))
+
+/* RdAccessTime and CycleTime timing parameters configuration */
+#define CSL_GPMC_CONFIG5(n)                                     (0x70U + ((n) * (0x30U)))
+
+/* WrAccessTime, WrDataOnADmuxBus, Cycle2Cycle and BusTurnAround parameters
+ * configuration */
+#define CSL_GPMC_CONFIG6(n)                                     (0x74U + ((n) * (0x30U)))
+
+/* Chip-select address mapping configuration Note: For CS0, the register reset
+ * is 0xf40 while for all the other instances CS1-CS7, the reset is 0xf00. */
+#define CSL_GPMC_CONFIG7(n)                                     (0x78U + ((n) * (0x30U)))
+
+/* This Register is not a true register, just a address location. */
+#define CSL_GPMC_NAND_COMMAND(n)                                (0x7CU + ((n) * (0x30U)))
+
+/* This Register is not a true register, just a address location. */
+#define CSL_GPMC_NAND_ADDRESS(n)                                (0x80U + ((n) * (0x30U)))
+
+/* This Register is not a true register, just a address location. */
+#define CSL_GPMC_NAND_DATA(n)                                   (0x84U + ((n) * (0x30U)))
+
+
+/**************************************************************************
+* Field Definition Macros
+**************************************************************************/
+
+/* REVISION */
+
+#define CSL_GPMC_REVISION_REV_MASK                              (0x000000FFU)
+#define CSL_GPMC_REVISION_REV_SHIFT                             (0U)
+#define CSL_GPMC_REVISION_REV_RESETVAL                          (0x00000000U)
+#define CSL_GPMC_REVISION_REV_MAX                               (0x000000ffU)
+
+#define CSL_GPMC_REVISION_RESETVAL                              (0x00000000U)
+
+/* SYSCONFIG */
+
+#define CSL_GPMC_SYSCONFIG_SOFTRESET_MASK                       (0x00000002U)
+#define CSL_GPMC_SYSCONFIG_SOFTRESET_SHIFT                      (1U)
+#define CSL_GPMC_SYSCONFIG_SOFTRESET_RESETVAL                   (0x00000000U)
+#define CSL_GPMC_SYSCONFIG_SOFTRESET_NORMAL                     (0x00000000U)
+#define CSL_GPMC_SYSCONFIG_SOFTRESET_RESET                      (0x00000001U)
+
+#define CSL_GPMC_SYSCONFIG_IDLEMODE_MASK                        (0x00000018U)
+#define CSL_GPMC_SYSCONFIG_IDLEMODE_SHIFT                       (3U)
+#define CSL_GPMC_SYSCONFIG_IDLEMODE_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_SYSCONFIG_IDLEMODE_FORCEIDLE                   (0x00000000U)
+#define CSL_GPMC_SYSCONFIG_IDLEMODE_NOIDLE                      (0x00000001U)
+#define CSL_GPMC_SYSCONFIG_IDLEMODE_SMARTIDLE                   (0x00000002U)
+#define CSL_GPMC_SYSCONFIG_IDLEMODE_RESERVED                    (0x00000003U)
+
+#define CSL_GPMC_SYSCONFIG_AUTOIDLE_MASK                        (0x00000001U)
+#define CSL_GPMC_SYSCONFIG_AUTOIDLE_SHIFT                       (0U)
+#define CSL_GPMC_SYSCONFIG_AUTOIDLE_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_SYSCONFIG_AUTOIDLE_FREERUN                     (0x00000000U)
+#define CSL_GPMC_SYSCONFIG_AUTOIDLE_AUTORUN                     (0x00000001U)
+
+#define CSL_GPMC_SYSCONFIG_RESETVAL                             (0x00000000U)
+
+/* SYSSTATUS */
+
+#define CSL_GPMC_SYSSTATUS_RESETDONE_MASK                       (0x00000001U)
+#define CSL_GPMC_SYSSTATUS_RESETDONE_SHIFT                      (0U)
+#define CSL_GPMC_SYSSTATUS_RESETDONE_RESETVAL                   (0x00000000U)
+#define CSL_GPMC_SYSSTATUS_RESETDONE_RSTONGOING                 (0x00000000U)
+#define CSL_GPMC_SYSSTATUS_RESETDONE_RSTDONE                    (0x00000001U)
+
+#define CSL_GPMC_SYSSTATUS_RESETVAL                             (0x00000000U)
+
+/* IRQSTATUS */
+
+#define CSL_GPMC_IRQSTATUS_WAIT2EDGEDETECTIONSTATUS_MASK        (0x00000400U)
+#define CSL_GPMC_IRQSTATUS_WAIT2EDGEDETECTIONSTATUS_SHIFT       (10U)
+#define CSL_GPMC_IRQSTATUS_WAIT2EDGEDETECTIONSTATUS_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT2EDGEDETECTIONSTATUS_W2DET0_R    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT2EDGEDETECTIONSTATUS_W2DET0_W    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT2EDGEDETECTIONSTATUS_W2DET1_R    (0x00000001U)
+#define CSL_GPMC_IRQSTATUS_WAIT2EDGEDETECTIONSTATUS_W2DET1_W    (0x00000001U)
+
+#define CSL_GPMC_IRQSTATUS_WAIT3EDGEDETECTIONSTATUS_MASK        (0x00000800U)
+#define CSL_GPMC_IRQSTATUS_WAIT3EDGEDETECTIONSTATUS_SHIFT       (11U)
+#define CSL_GPMC_IRQSTATUS_WAIT3EDGEDETECTIONSTATUS_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT3EDGEDETECTIONSTATUS_W3DET0_R    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT3EDGEDETECTIONSTATUS_W3DET0_W    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT3EDGEDETECTIONSTATUS_W3DET1_R    (0x00000001U)
+#define CSL_GPMC_IRQSTATUS_WAIT3EDGEDETECTIONSTATUS_W3DET1_W    (0x00000001U)
+
+#define CSL_GPMC_IRQSTATUS_TERMINALCOUNTSTATUS_MASK             (0x00000002U)
+#define CSL_GPMC_IRQSTATUS_TERMINALCOUNTSTATUS_SHIFT            (1U)
+#define CSL_GPMC_IRQSTATUS_TERMINALCOUNTSTATUS_RESETVAL         (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_TERMINALCOUNTSTATUS_TCSTAT0_R        (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_TERMINALCOUNTSTATUS_TCSTAT0_W        (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_TERMINALCOUNTSTATUS_TCSTAT1_R        (0x00000001U)
+#define CSL_GPMC_IRQSTATUS_TERMINALCOUNTSTATUS_TCSTAT1_W        (0x00000001U)
+
+#define CSL_GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS_MASK        (0x00000100U)
+#define CSL_GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS_SHIFT       (8U)
+#define CSL_GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS_W0DET0_R    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS_W0DET0_W    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS_W0DET1_R    (0x00000001U)
+#define CSL_GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS_W0DET1_W    (0x00000001U)
+
+#define CSL_GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS_MASK        (0x00000200U)
+#define CSL_GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS_SHIFT       (9U)
+#define CSL_GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS_W1DET0_R    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS_W1DET0_W    (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS_W1DET1_R    (0x00000001U)
+#define CSL_GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS_W1DET1_W    (0x00000001U)
+
+#define CSL_GPMC_IRQSTATUS_FIFOEVENTSTATUS_MASK                 (0x00000001U)
+#define CSL_GPMC_IRQSTATUS_FIFOEVENTSTATUS_SHIFT                (0U)
+#define CSL_GPMC_IRQSTATUS_FIFOEVENTSTATUS_RESETVAL             (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_FIFOEVENTSTATUS_FIFOSTAT0_R          (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_FIFOEVENTSTATUS_FIFOSTAT0_W          (0x00000000U)
+#define CSL_GPMC_IRQSTATUS_FIFOEVENTSTATUS_FIFOSTAT1_R          (0x00000001U)
+#define CSL_GPMC_IRQSTATUS_FIFOEVENTSTATUS_FIFOSTAT1_W          (0x00000001U)
+
+#define CSL_GPMC_IRQSTATUS_RESETVAL                             (0x00000000U)
+
+/* IRQENABLE */
+
+#define CSL_GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE_MASK        (0x00000002U)
+#define CSL_GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE_SHIFT       (1U)
+#define CSL_GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE_TCMASKED    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE_TCENABLED   (0x00000001U)
+
+#define CSL_GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE_MASK        (0x00000100U)
+#define CSL_GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE_SHIFT       (8U)
+#define CSL_GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE_W0MASKED    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE_W0ENABLED   (0x00000001U)
+
+#define CSL_GPMC_IRQENABLE_WAIT2EDGEDETECTIONENABLE_MASK        (0x00000400U)
+#define CSL_GPMC_IRQENABLE_WAIT2EDGEDETECTIONENABLE_SHIFT       (10U)
+#define CSL_GPMC_IRQENABLE_WAIT2EDGEDETECTIONENABLE_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_WAIT2EDGEDETECTIONENABLE_W2MASKED    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_WAIT2EDGEDETECTIONENABLE_W2ENABLED   (0x00000001U)
+
+#define CSL_GPMC_IRQENABLE_FIFOEVENTENABLE_MASK                 (0x00000001U)
+#define CSL_GPMC_IRQENABLE_FIFOEVENTENABLE_SHIFT                (0U)
+#define CSL_GPMC_IRQENABLE_FIFOEVENTENABLE_RESETVAL             (0x00000000U)
+#define CSL_GPMC_IRQENABLE_FIFOEVENTENABLE_FIFOMASKED           (0x00000000U)
+#define CSL_GPMC_IRQENABLE_FIFOEVENTENABLE_FIFOENABLED          (0x00000001U)
+
+#define CSL_GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE_MASK        (0x00000200U)
+#define CSL_GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE_SHIFT       (9U)
+#define CSL_GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE_W1MASKED    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE_W1ENABLED   (0x00000001U)
+
+#define CSL_GPMC_IRQENABLE_WAIT3EDGEDETECTIONENABLE_MASK        (0x00000800U)
+#define CSL_GPMC_IRQENABLE_WAIT3EDGEDETECTIONENABLE_SHIFT       (11U)
+#define CSL_GPMC_IRQENABLE_WAIT3EDGEDETECTIONENABLE_RESETVAL    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_WAIT3EDGEDETECTIONENABLE_W3MASKED    (0x00000000U)
+#define CSL_GPMC_IRQENABLE_WAIT3EDGEDETECTIONENABLE_W3ENABLED   (0x00000001U)
+
+#define CSL_GPMC_IRQENABLE_RESETVAL                             (0x00000000U)
+
+/* TIMEOUT_CONTROL */
+
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTSTARTVALUE_MASK         (0x00001FF0U)
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTSTARTVALUE_SHIFT        (4U)
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTSTARTVALUE_RESETVAL     (0x000001ffU)
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTSTARTVALUE_MAX          (0x000001ffU)
+
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTENABLE_MASK             (0x00000001U)
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTENABLE_SHIFT            (0U)
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTENABLE_RESETVAL         (0x00000000U)
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTENABLE_TODISABLED       (0x00000000U)
+#define CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTENABLE_TOENABLED        (0x00000001U)
+
+#define CSL_GPMC_TIMEOUT_CONTROL_RESETVAL                       (0x00001ff0U)
+
+/* ERR_ADDRESS */
+
+#define CSL_GPMC_ERR_ADDRESS_ILLEGALADD_MASK                    (0x7FFFFFFFU)
+#define CSL_GPMC_ERR_ADDRESS_ILLEGALADD_SHIFT                   (0U)
+#define CSL_GPMC_ERR_ADDRESS_ILLEGALADD_RESETVAL                (0x00000000U)
+#define CSL_GPMC_ERR_ADDRESS_ILLEGALADD_MAX                     (0x7fffffffU)
+
+#define CSL_GPMC_ERR_ADDRESS_RESETVAL                           (0x00000000U)
+
+/* ERR_TYPE */
+
+#define CSL_GPMC_ERR_TYPE_ILLEGALMCMD_MASK                      (0x00000700U)
+#define CSL_GPMC_ERR_TYPE_ILLEGALMCMD_SHIFT                     (8U)
+#define CSL_GPMC_ERR_TYPE_ILLEGALMCMD_RESETVAL                  (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ILLEGALMCMD_MAX                       (0x00000007U)
+
+#define CSL_GPMC_ERR_TYPE_ERRORTIMEOUT_MASK                     (0x00000004U)
+#define CSL_GPMC_ERR_TYPE_ERRORTIMEOUT_SHIFT                    (2U)
+#define CSL_GPMC_ERR_TYPE_ERRORTIMEOUT_RESETVAL                 (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ERRORTIMEOUT_NOERR                    (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ERRORTIMEOUT_ERR                      (0x00000001U)
+
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPADD_MASK                  (0x00000010U)
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPADD_SHIFT                 (4U)
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPADD_RESETVAL              (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPADD_NOERR                 (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPADD_ERR                   (0x00000001U)
+
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPMCMD_MASK                 (0x00000008U)
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPMCMD_SHIFT                (3U)
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPMCMD_RESETVAL             (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPMCMD_NOERR                (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ERRORNOTSUPPMCMD_ERR                  (0x00000001U)
+
+#define CSL_GPMC_ERR_TYPE_ERRORVALID_MASK                       (0x00000001U)
+#define CSL_GPMC_ERR_TYPE_ERRORVALID_SHIFT                      (0U)
+#define CSL_GPMC_ERR_TYPE_ERRORVALID_RESETVAL                   (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ERRORVALID_NOTVALID                   (0x00000000U)
+#define CSL_GPMC_ERR_TYPE_ERRORVALID_ERRDETECT                  (0x00000001U)
+
+#define CSL_GPMC_ERR_TYPE_RESETVAL                              (0x00000000U)
+
+/* CONFIG */
+
+#define CSL_GPMC_CONFIG_NANDFORCEPOSTEDWRITE_MASK               (0x00000001U)
+#define CSL_GPMC_CONFIG_NANDFORCEPOSTEDWRITE_SHIFT              (0U)
+#define CSL_GPMC_CONFIG_NANDFORCEPOSTEDWRITE_RESETVAL           (0x00000000U)
+#define CSL_GPMC_CONFIG_NANDFORCEPOSTEDWRITE_NOFORCEPWR         (0x00000000U)
+#define CSL_GPMC_CONFIG_NANDFORCEPOSTEDWRITE_FORCEPWR           (0x00000001U)
+
+#define CSL_GPMC_CONFIG_WAIT3PINPOLARITY_MASK                   (0x00000800U)
+#define CSL_GPMC_CONFIG_WAIT3PINPOLARITY_SHIFT                  (11U)
+#define CSL_GPMC_CONFIG_WAIT3PINPOLARITY_RESETVAL               (0x00000001U)
+#define CSL_GPMC_CONFIG_WAIT3PINPOLARITY_W3ACTIVEL              (0x00000000U)
+#define CSL_GPMC_CONFIG_WAIT3PINPOLARITY_W3ACTIVEH              (0x00000001U)
+
+#define CSL_GPMC_CONFIG_WAIT1PINPOLARITY_MASK                   (0x00000200U)
+#define CSL_GPMC_CONFIG_WAIT1PINPOLARITY_SHIFT                  (9U)
+#define CSL_GPMC_CONFIG_WAIT1PINPOLARITY_RESETVAL               (0x00000001U)
+#define CSL_GPMC_CONFIG_WAIT1PINPOLARITY_W1ACTIVEL              (0x00000000U)
+#define CSL_GPMC_CONFIG_WAIT1PINPOLARITY_W1ACTIVEH              (0x00000001U)
+
+#define CSL_GPMC_CONFIG_WRITEPROTECT_MASK                       (0x00000010U)
+#define CSL_GPMC_CONFIG_WRITEPROTECT_SHIFT                      (4U)
+#define CSL_GPMC_CONFIG_WRITEPROTECT_RESETVAL                   (0x00000000U)
+#define CSL_GPMC_CONFIG_WRITEPROTECT_WPLOW                      (0x00000000U)
+#define CSL_GPMC_CONFIG_WRITEPROTECT_WPHIGH                     (0x00000001U)
+
+#define CSL_GPMC_CONFIG_WAIT2PINPOLARITY_MASK                   (0x00000400U)
+#define CSL_GPMC_CONFIG_WAIT2PINPOLARITY_SHIFT                  (10U)
+#define CSL_GPMC_CONFIG_WAIT2PINPOLARITY_RESETVAL               (0x00000000U)
+#define CSL_GPMC_CONFIG_WAIT2PINPOLARITY_W2ACTIVEL              (0x00000000U)
+#define CSL_GPMC_CONFIG_WAIT2PINPOLARITY_W2ACTIVEH              (0x00000001U)
+
+#define CSL_GPMC_CONFIG_WAIT0PINPOLARITY_MASK                   (0x00000100U)
+#define CSL_GPMC_CONFIG_WAIT0PINPOLARITY_SHIFT                  (8U)
+#define CSL_GPMC_CONFIG_WAIT0PINPOLARITY_RESETVAL               (0x00000000U)
+#define CSL_GPMC_CONFIG_WAIT0PINPOLARITY_W0ACTIVEL              (0x00000000U)
+#define CSL_GPMC_CONFIG_WAIT0PINPOLARITY_W0ACTIVEH              (0x00000001U)
+
+#define CSL_GPMC_CONFIG_LIMITEDADDRESS_MASK                     (0x00000002U)
+#define CSL_GPMC_CONFIG_LIMITEDADDRESS_SHIFT                    (1U)
+#define CSL_GPMC_CONFIG_LIMITEDADDRESS_RESETVAL                 (0x00000000U)
+#define CSL_GPMC_CONFIG_LIMITEDADDRESS_NOLIMITED                (0x00000000U)
+#define CSL_GPMC_CONFIG_LIMITEDADDRESS_LIMITED                  (0x00000001U)
+
+#define CSL_GPMC_CONFIG_RESETVAL                                (0x00000a00U)
+
+/* STATUS */
+
+#define CSL_GPMC_STATUS_WAIT1STATUS_MASK                        (0x00000200U)
+#define CSL_GPMC_STATUS_WAIT1STATUS_SHIFT                       (9U)
+#define CSL_GPMC_STATUS_WAIT1STATUS_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_STATUS_WAIT1STATUS_W1ACTIVEL                   (0x00000000U)
+#define CSL_GPMC_STATUS_WAIT1STATUS_W1ACTIVEH                   (0x00000001U)
+
+#define CSL_GPMC_STATUS_WAIT3STATUS_MASK                        (0x00000800U)
+#define CSL_GPMC_STATUS_WAIT3STATUS_SHIFT                       (11U)
+#define CSL_GPMC_STATUS_WAIT3STATUS_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_STATUS_WAIT3STATUS_W3ACTIVEL                   (0x00000000U)
+#define CSL_GPMC_STATUS_WAIT3STATUS_W3ACTIVEH                   (0x00000001U)
+
+#define CSL_GPMC_STATUS_EMPTYWRITEBUFFERSTATUS_MASK             (0x00000001U)
+#define CSL_GPMC_STATUS_EMPTYWRITEBUFFERSTATUS_SHIFT            (0U)
+#define CSL_GPMC_STATUS_EMPTYWRITEBUFFERSTATUS_RESETVAL         (0x00000001U)
+#define CSL_GPMC_STATUS_EMPTYWRITEBUFFERSTATUS_B0               (0x00000000U)
+#define CSL_GPMC_STATUS_EMPTYWRITEBUFFERSTATUS_B1               (0x00000001U)
+
+#define CSL_GPMC_STATUS_WAIT0STATUS_MASK                        (0x00000100U)
+#define CSL_GPMC_STATUS_WAIT0STATUS_SHIFT                       (8U)
+#define CSL_GPMC_STATUS_WAIT0STATUS_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_STATUS_WAIT0STATUS_W0ACTIVEL                   (0x00000000U)
+#define CSL_GPMC_STATUS_WAIT0STATUS_W0ACTIVEH                   (0x00000001U)
+
+#define CSL_GPMC_STATUS_WAIT2STATUS_MASK                        (0x00000400U)
+#define CSL_GPMC_STATUS_WAIT2STATUS_SHIFT                       (10U)
+#define CSL_GPMC_STATUS_WAIT2STATUS_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_STATUS_WAIT2STATUS_W2ACTIVEL                   (0x00000000U)
+#define CSL_GPMC_STATUS_WAIT2STATUS_W2ACTIVEH                   (0x00000001U)
+
+#define CSL_GPMC_STATUS_RESETVAL                                (0x00000001U)
+
+/* PREFETCH_CONFIG1 */
+
+#define CSL_GPMC_PREFETCH_CONFIG1_DMAMODE_MASK                  (0x00000004U)
+#define CSL_GPMC_PREFETCH_CONFIG1_DMAMODE_SHIFT                 (2U)
+#define CSL_GPMC_PREFETCH_CONFIG1_DMAMODE_RESETVAL              (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_DMAMODE_INTERRUPTSYNC         (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_DMAMODE_DMAREQSYNC            (0x00000001U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_FIFOTHRESHOLD_MASK            (0x00007F00U)
+#define CSL_GPMC_PREFETCH_CONFIG1_FIFOTHRESHOLD_SHIFT           (8U)
+#define CSL_GPMC_PREFETCH_CONFIG1_FIFOTHRESHOLD_RESETVAL        (0x00000040U)
+#define CSL_GPMC_PREFETCH_CONFIG1_FIFOTHRESHOLD_MAX             (0x0000007fU)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEENGINE_MASK             (0x00000080U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEENGINE_SHIFT            (7U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEENGINE_RESETVAL         (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEENGINE_PPDISABLED       (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEENGINE_PPENABLED        (0x00000001U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_CYCLEOPTIMIZATION_MASK        (0x70000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_CYCLEOPTIMIZATION_SHIFT       (28U)
+#define CSL_GPMC_PREFETCH_CONFIG1_CYCLEOPTIMIZATION_RESETVAL    (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_CYCLEOPTIMIZATION_MAX         (0x00000007U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEOPTIMIZEDACCESS_MASK    (0x08000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEOPTIMIZEDACCESS_SHIFT   (27U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEOPTIMIZEDACCESS_RESETVAL  (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEOPTIMIZEDACCESS_OPTDISABLED  (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENABLEOPTIMIZEDACCESS_OPTENABLED  (0x00000001U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_SYNCHROMODE_MASK              (0x00000008U)
+#define CSL_GPMC_PREFETCH_CONFIG1_SYNCHROMODE_SHIFT             (3U)
+#define CSL_GPMC_PREFETCH_CONFIG1_SYNCHROMODE_RESETVAL          (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_SYNCHROMODE_ATSTART           (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_SYNCHROMODE_ATSTARTANDWAIT    (0x00000001U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_ACCESSMODE_MASK               (0x00000001U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ACCESSMODE_SHIFT              (0U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ACCESSMODE_RESETVAL           (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ACCESSMODE_PREFETCHREAD       (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ACCESSMODE_WRITEPOSTING       (0x00000001U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_WAITPINSELECTOR_MASK          (0x00000030U)
+#define CSL_GPMC_PREFETCH_CONFIG1_WAITPINSELECTOR_SHIFT         (4U)
+#define CSL_GPMC_PREFETCH_CONFIG1_WAITPINSELECTOR_RESETVAL      (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_WAITPINSELECTOR_W3            (0x00000003U)
+#define CSL_GPMC_PREFETCH_CONFIG1_WAITPINSELECTOR_W0            (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_WAITPINSELECTOR_W1            (0x00000001U)
+#define CSL_GPMC_PREFETCH_CONFIG1_WAITPINSELECTOR_W2            (0x00000002U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_ENGINECSSELECTOR_MASK         (0x07000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENGINECSSELECTOR_SHIFT        (24U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENGINECSSELECTOR_RESETVAL     (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_ENGINECSSELECTOR_MAX          (0x00000007U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWWEIGHTEDPRIO_MASK         (0x000F0000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWWEIGHTEDPRIO_SHIFT        (16U)
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWWEIGHTEDPRIO_RESETVAL     (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWWEIGHTEDPRIO_MAX          (0x0000000fU)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWENROUNDROBIN_MASK         (0x00800000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWENROUNDROBIN_SHIFT        (23U)
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWENROUNDROBIN_RESETVAL     (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWENROUNDROBIN_RRENABLED    (0x00000001U)
+#define CSL_GPMC_PREFETCH_CONFIG1_PFPWENROUNDROBIN_RRDISABLED   (0x00000000U)
+
+#define CSL_GPMC_PREFETCH_CONFIG1_RESETVAL                      (0x00004000U)
+
+/* PREFETCH_CONFIG2 */
+
+#define CSL_GPMC_PREFETCH_CONFIG2_TRANSFERCOUNT_MASK            (0x00003FFFU)
+#define CSL_GPMC_PREFETCH_CONFIG2_TRANSFERCOUNT_SHIFT           (0U)
+#define CSL_GPMC_PREFETCH_CONFIG2_TRANSFERCOUNT_RESETVAL        (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONFIG2_TRANSFERCOUNT_MAX             (0x00003fffU)
+
+#define CSL_GPMC_PREFETCH_CONFIG2_RESETVAL                      (0x00000000U)
+
+/* PREFETCH_CONTROL */
+
+#define CSL_GPMC_PREFETCH_CONTROL_STARTENGINE_MASK              (0x00000001U)
+#define CSL_GPMC_PREFETCH_CONTROL_STARTENGINE_SHIFT             (0U)
+#define CSL_GPMC_PREFETCH_CONTROL_STARTENGINE_RESETVAL          (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONTROL_STARTENGINE_STOP              (0x00000000U)
+#define CSL_GPMC_PREFETCH_CONTROL_STARTENGINE_START             (0x00000001U)
+
+#define CSL_GPMC_PREFETCH_CONTROL_RESETVAL                      (0x00000000U)
+
+/* PREFETCH_STATUS */
+
+#define CSL_GPMC_PREFETCH_STATUS_FIFOTHRESHOLDSTATUS_MASK       (0x00010000U)
+#define CSL_GPMC_PREFETCH_STATUS_FIFOTHRESHOLDSTATUS_SHIFT      (16U)
+#define CSL_GPMC_PREFETCH_STATUS_FIFOTHRESHOLDSTATUS_RESETVAL   (0x00000000U)
+#define CSL_GPMC_PREFETCH_STATUS_FIFOTHRESHOLDSTATUS_SMALLERTHANTHRES  (0x00000000U)
+#define CSL_GPMC_PREFETCH_STATUS_FIFOTHRESHOLDSTATUS_GREATERTHANTHRES  (0x00000001U)
+
+#define CSL_GPMC_PREFETCH_STATUS_COUNTVALUE_MASK                (0x00003FFFU)
+#define CSL_GPMC_PREFETCH_STATUS_COUNTVALUE_SHIFT               (0U)
+#define CSL_GPMC_PREFETCH_STATUS_COUNTVALUE_RESETVAL            (0x00000000U)
+#define CSL_GPMC_PREFETCH_STATUS_COUNTVALUE_MAX                 (0x00003fffU)
+
+#define CSL_GPMC_PREFETCH_STATUS_FIFOPOINTER_MASK               (0x7F000000U)
+#define CSL_GPMC_PREFETCH_STATUS_FIFOPOINTER_SHIFT              (24U)
+#define CSL_GPMC_PREFETCH_STATUS_FIFOPOINTER_RESETVAL           (0x00000000U)
+#define CSL_GPMC_PREFETCH_STATUS_FIFOPOINTER_MAX                (0x0000007fU)
+
+#define CSL_GPMC_PREFETCH_STATUS_RESETVAL                       (0x00000000U)
+
+/* ECC_CONFIG */
+
+#define CSL_GPMC_ECC_CONFIG_ECC16B_MASK                         (0x00000080U)
+#define CSL_GPMC_ECC_CONFIG_ECC16B_SHIFT                        (7U)
+#define CSL_GPMC_ECC_CONFIG_ECC16B_RESETVAL                     (0x00000000U)
+#define CSL_GPMC_ECC_CONFIG_ECC16B_EIGHTCOL                     (0x00000000U)
+#define CSL_GPMC_ECC_CONFIG_ECC16B_SIXTEENCOL                   (0x00000001U)
+
+#define CSL_GPMC_ECC_CONFIG_ECCWRAPMODE_MASK                    (0x00000F00U)
+#define CSL_GPMC_ECC_CONFIG_ECCWRAPMODE_SHIFT                   (8U)
+#define CSL_GPMC_ECC_CONFIG_ECCWRAPMODE_RESETVAL                (0x00000000U)
+#define CSL_GPMC_ECC_CONFIG_ECCWRAPMODE_MAX                     (0x0000000fU)
+
+#define CSL_GPMC_ECC_CONFIG_ECCCS_MASK                          (0x0000000EU)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_SHIFT                         (1U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_RESETVAL                      (0x00000000U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_CS0                           (0x00000000U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_CS1                           (0x00000001U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_CS2                           (0x00000002U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_CS3                           (0x00000003U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_CS4                           (0x00000004U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_CS5                           (0x00000005U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_CS6                           (0x00000006U)
+#define CSL_GPMC_ECC_CONFIG_ECCCS_CS7                           (0x00000007U)
+
+#define CSL_GPMC_ECC_CONFIG_ECCENABLE_MASK                      (0x00000001U)
+#define CSL_GPMC_ECC_CONFIG_ECCENABLE_SHIFT                     (0U)
+#define CSL_GPMC_ECC_CONFIG_ECCENABLE_RESETVAL                  (0x00000000U)
+#define CSL_GPMC_ECC_CONFIG_ECCENABLE_ECCDISABLED               (0x00000000U)
+#define CSL_GPMC_ECC_CONFIG_ECCENABLE_ECCENABLED                (0x00000001U)
+
+#define CSL_GPMC_ECC_CONFIG_ECCBCHTSEL_MASK                     (0x00003000U)
+#define CSL_GPMC_ECC_CONFIG_ECCBCHTSEL_SHIFT                    (12U)
+#define CSL_GPMC_ECC_CONFIG_ECCBCHTSEL_RESETVAL                 (0x00000001U)
+#define CSL_GPMC_ECC_CONFIG_ECCBCHTSEL_MAX                      (0x00000003U)
+
+#define CSL_GPMC_ECC_CONFIG_ECCALGORITHM_MASK                   (0x00010000U)
+#define CSL_GPMC_ECC_CONFIG_ECCALGORITHM_SHIFT                  (16U)
+#define CSL_GPMC_ECC_CONFIG_ECCALGORITHM_RESETVAL               (0x00000000U)
+#define CSL_GPMC_ECC_CONFIG_ECCALGORITHM_MAX                    (0x00000001U)
+
+#define CSL_GPMC_ECC_CONFIG_ECCTOPSECTOR_MASK                   (0x00000070U)
+#define CSL_GPMC_ECC_CONFIG_ECCTOPSECTOR_SHIFT                  (4U)
+#define CSL_GPMC_ECC_CONFIG_ECCTOPSECTOR_RESETVAL               (0x00000003U)
+#define CSL_GPMC_ECC_CONFIG_ECCTOPSECTOR_MAX                    (0x00000007U)
+
+#define CSL_GPMC_ECC_CONFIG_RESETVAL                            (0x00001030U)
+
+/* ECC_CONTROL */
+
+#define CSL_GPMC_ECC_CONTROL_ECCCLEAR_MASK                      (0x00000100U)
+#define CSL_GPMC_ECC_CONTROL_ECCCLEAR_SHIFT                     (8U)
+#define CSL_GPMC_ECC_CONTROL_ECCCLEAR_RESETVAL                  (0x00000000U)
+#define CSL_GPMC_ECC_CONTROL_ECCCLEAR_MAX                       (0x00000001U)
+
+#define CSL_GPMC_ECC_CONTROL_ECCPOINTER_MASK                    (0x0000000FU)
+#define CSL_GPMC_ECC_CONTROL_ECCPOINTER_SHIFT                   (0U)
+#define CSL_GPMC_ECC_CONTROL_ECCPOINTER_RESETVAL                (0x00000000U)
+#define CSL_GPMC_ECC_CONTROL_ECCPOINTER_MAX                     (0x0000000fU)
+
+#define CSL_GPMC_ECC_CONTROL_RESETVAL                           (0x00000000U)
+
+/* ECC_SIZE_CONFIG */
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC3RESULTSIZE_MASK            (0x00000004U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC3RESULTSIZE_SHIFT           (2U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC3RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC3RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC3RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC5RESULTSIZE_MASK            (0x00000010U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC5RESULTSIZE_SHIFT           (4U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC5RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC5RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC5RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC2RESULTSIZE_MASK            (0x00000002U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC2RESULTSIZE_SHIFT           (1U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC2RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC2RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC2RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC1RESULTSIZE_MASK            (0x00000001U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC1RESULTSIZE_SHIFT           (0U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC1RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC1RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC1RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECCSIZE0_MASK                  (0x003FF000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECCSIZE0_SHIFT                 (12U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECCSIZE0_RESETVAL              (0x000000ffU)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECCSIZE0_MAX                   (0x000000ffU)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC7RESULTSIZE_MASK            (0x00000040U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC7RESULTSIZE_SHIFT           (6U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC7RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC7RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC7RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC9RESULTSIZE_MASK            (0x00000100U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC9RESULTSIZE_SHIFT           (8U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC9RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC9RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC9RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC4RESULTSIZE_MASK            (0x00000008U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC4RESULTSIZE_SHIFT           (3U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC4RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC4RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC4RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC6RESULTSIZE_MASK            (0x00000020U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC6RESULTSIZE_SHIFT           (5U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC6RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC6RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC6RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC8RESULTSIZE_MASK            (0x00000080U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC8RESULTSIZE_SHIFT           (7U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC8RESULTSIZE_RESETVAL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC8RESULTSIZE_SIZE0SEL        (0x00000000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECC8RESULTSIZE_SIZE1SEL        (0x00000001U)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECCSIZE1_MASK                  (0xFFC00000U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECCSIZE1_SHIFT                 (22U)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECCSIZE1_RESETVAL              (0x000000ffU)
+#define CSL_GPMC_ECC_SIZE_CONFIG_ECCSIZE1_MAX                   (0x000000ffU)
+
+#define CSL_GPMC_ECC_SIZE_CONFIG_RESETVAL                       (0xfffff000U)
+
+/* ECC_RESULT */
+
+#define CSL_GPMC_ECC_RESULT_P512O_MASK                          (0x02000000U)
+#define CSL_GPMC_ECC_RESULT_P512O_SHIFT                         (25U)
+#define CSL_GPMC_ECC_RESULT_P512O_RESETVAL                      (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P512O_MAX                           (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P256O_MASK                          (0x01000000U)
+#define CSL_GPMC_ECC_RESULT_P256O_SHIFT                         (24U)
+#define CSL_GPMC_ECC_RESULT_P256O_RESETVAL                      (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P256O_MAX                           (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P128O_MASK                          (0x00800000U)
+#define CSL_GPMC_ECC_RESULT_P128O_SHIFT                         (23U)
+#define CSL_GPMC_ECC_RESULT_P128O_RESETVAL                      (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P128O_MAX                           (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P2048E_MASK                         (0x00000800U)
+#define CSL_GPMC_ECC_RESULT_P2048E_SHIFT                        (11U)
+#define CSL_GPMC_ECC_RESULT_P2048E_RESETVAL                     (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P2048E_MAX                          (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P64O_MASK                           (0x00400000U)
+#define CSL_GPMC_ECC_RESULT_P64O_SHIFT                          (22U)
+#define CSL_GPMC_ECC_RESULT_P64O_RESETVAL                       (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P64O_MAX                            (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P4E_MASK                            (0x00000004U)
+#define CSL_GPMC_ECC_RESULT_P4E_SHIFT                           (2U)
+#define CSL_GPMC_ECC_RESULT_P4E_RESETVAL                        (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P4E_MAX                             (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P1024E_MASK                         (0x00000400U)
+#define CSL_GPMC_ECC_RESULT_P1024E_SHIFT                        (10U)
+#define CSL_GPMC_ECC_RESULT_P1024E_RESETVAL                     (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P1024E_MAX                          (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P32O_MASK                           (0x00200000U)
+#define CSL_GPMC_ECC_RESULT_P32O_SHIFT                          (21U)
+#define CSL_GPMC_ECC_RESULT_P32O_RESETVAL                       (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P32O_MAX                            (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P2E_MASK                            (0x00000002U)
+#define CSL_GPMC_ECC_RESULT_P2E_SHIFT                           (1U)
+#define CSL_GPMC_ECC_RESULT_P2E_RESETVAL                        (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P2E_MAX                             (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P512E_MASK                          (0x00000200U)
+#define CSL_GPMC_ECC_RESULT_P512E_SHIFT                         (9U)
+#define CSL_GPMC_ECC_RESULT_P512E_RESETVAL                      (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P512E_MAX                           (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P16O_MASK                           (0x00100000U)
+#define CSL_GPMC_ECC_RESULT_P16O_SHIFT                          (20U)
+#define CSL_GPMC_ECC_RESULT_P16O_RESETVAL                       (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P16O_MAX                            (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P1E_MASK                            (0x00000001U)
+#define CSL_GPMC_ECC_RESULT_P1E_SHIFT                           (0U)
+#define CSL_GPMC_ECC_RESULT_P1E_RESETVAL                        (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P1E_MAX                             (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P256E_MASK                          (0x00000100U)
+#define CSL_GPMC_ECC_RESULT_P256E_SHIFT                         (8U)
+#define CSL_GPMC_ECC_RESULT_P256E_RESETVAL                      (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P256E_MAX                           (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P8O_MASK                            (0x00080000U)
+#define CSL_GPMC_ECC_RESULT_P8O_SHIFT                           (19U)
+#define CSL_GPMC_ECC_RESULT_P8O_RESETVAL                        (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P8O_MAX                             (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P2048O_MASK                         (0x08000000U)
+#define CSL_GPMC_ECC_RESULT_P2048O_SHIFT                        (27U)
+#define CSL_GPMC_ECC_RESULT_P2048O_RESETVAL                     (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P2048O_MAX                          (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P128E_MASK                          (0x00000080U)
+#define CSL_GPMC_ECC_RESULT_P128E_SHIFT                         (7U)
+#define CSL_GPMC_ECC_RESULT_P128E_RESETVAL                      (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P128E_MAX                           (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P4O_MASK                            (0x00040000U)
+#define CSL_GPMC_ECC_RESULT_P4O_SHIFT                           (18U)
+#define CSL_GPMC_ECC_RESULT_P4O_RESETVAL                        (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P4O_MAX                             (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P1024O_MASK                         (0x04000000U)
+#define CSL_GPMC_ECC_RESULT_P1024O_SHIFT                        (26U)
+#define CSL_GPMC_ECC_RESULT_P1024O_RESETVAL                     (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P1024O_MAX                          (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P64E_MASK                           (0x00000040U)
+#define CSL_GPMC_ECC_RESULT_P64E_SHIFT                          (6U)
+#define CSL_GPMC_ECC_RESULT_P64E_RESETVAL                       (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P64E_MAX                            (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P2O_MASK                            (0x00020000U)
+#define CSL_GPMC_ECC_RESULT_P2O_SHIFT                           (17U)
+#define CSL_GPMC_ECC_RESULT_P2O_RESETVAL                        (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P2O_MAX                             (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P32E_MASK                           (0x00000020U)
+#define CSL_GPMC_ECC_RESULT_P32E_SHIFT                          (5U)
+#define CSL_GPMC_ECC_RESULT_P32E_RESETVAL                       (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P32E_MAX                            (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P1O_MASK                            (0x00010000U)
+#define CSL_GPMC_ECC_RESULT_P1O_SHIFT                           (16U)
+#define CSL_GPMC_ECC_RESULT_P1O_RESETVAL                        (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P1O_MAX                             (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P16E_MASK                           (0x00000010U)
+#define CSL_GPMC_ECC_RESULT_P16E_SHIFT                          (4U)
+#define CSL_GPMC_ECC_RESULT_P16E_RESETVAL                       (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P16E_MAX                            (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_P8E_MASK                            (0x00000008U)
+#define CSL_GPMC_ECC_RESULT_P8E_SHIFT                           (3U)
+#define CSL_GPMC_ECC_RESULT_P8E_RESETVAL                        (0x00000000U)
+#define CSL_GPMC_ECC_RESULT_P8E_MAX                             (0x00000001U)
+
+#define CSL_GPMC_ECC_RESULT_RESETVAL                            (0x00000000U)
+
+/* TESTMODE_CTRL */
+
+#define CSL_GPMC_TESTMODE_CTRL_GPMCFDBKEN_MASK                  (0x00000001U)
+#define CSL_GPMC_TESTMODE_CTRL_GPMCFDBKEN_SHIFT                 (0U)
+#define CSL_GPMC_TESTMODE_CTRL_GPMCFDBKEN_RESETVAL              (0x00000000U)
+#define CSL_GPMC_TESTMODE_CTRL_GPMCFDBKEN_NOEFFECT              (0x00000000U)
+#define CSL_GPMC_TESTMODE_CTRL_GPMCFDBKEN_FBMODE                (0x00000001U)
+
+#define CSL_GPMC_TESTMODE_CTRL_RESETVAL                         (0x00000000U)
+
+/* BCH_RESULT_0 */
+
+#define CSL_GPMC_BCH_RESULT_0_BCH_RESULT_0_MASK                 (0xFFFFFFFFU)
+#define CSL_GPMC_BCH_RESULT_0_BCH_RESULT_0_SHIFT                (0U)
+#define CSL_GPMC_BCH_RESULT_0_BCH_RESULT_0_RESETVAL             (0x00000000U)
+#define CSL_GPMC_BCH_RESULT_0_BCH_RESULT_0_MAX                  (0xffffffffU)
+
+#define CSL_GPMC_BCH_RESULT_0_RESETVAL                          (0x00000000U)
+
+/* BCH_RESULT_1 */
+
+#define CSL_GPMC_BCH_RESULT_1_BCH_RESULT_1_MASK                 (0xFFFFFFFFU)
+#define CSL_GPMC_BCH_RESULT_1_BCH_RESULT_1_SHIFT                (0U)
+#define CSL_GPMC_BCH_RESULT_1_BCH_RESULT_1_RESETVAL             (0x00000000U)
+#define CSL_GPMC_BCH_RESULT_1_BCH_RESULT_1_MAX                  (0xffffffffU)
+
+#define CSL_GPMC_BCH_RESULT_1_RESETVAL                          (0x00000000U)
+
+/* BCH_RESULT_2 */
+
+#define CSL_GPMC_BCH_RESULT_2_BCH_RESULT_2_MASK                 (0xFFFFFFFFU)
+#define CSL_GPMC_BCH_RESULT_2_BCH_RESULT_2_SHIFT                (0U)
+#define CSL_GPMC_BCH_RESULT_2_BCH_RESULT_2_RESETVAL             (0x00000000U)
+#define CSL_GPMC_BCH_RESULT_2_BCH_RESULT_2_MAX                  (0xffffffffU)
+
+#define CSL_GPMC_BCH_RESULT_2_RESETVAL                          (0x00000000U)
+
+/* BCH_RESULT_3 */
+
+#define CSL_GPMC_BCH_RESULT_3_BCH_RESULT_3_MASK                 (0xFFFFFFFFU)
+#define CSL_GPMC_BCH_RESULT_3_BCH_RESULT_3_SHIFT                (0U)
+#define CSL_GPMC_BCH_RESULT_3_BCH_RESULT_3_RESETVAL             (0x00000000U)
+#define CSL_GPMC_BCH_RESULT_3_BCH_RESULT_3_MAX                  (0xffffffffU)
+
+#define CSL_GPMC_BCH_RESULT_3_RESETVAL                          (0x00000000U)
+
+/* BCH_SWDATA */
+
+#define CSL_GPMC_BCH_SWDATA_BCH_DATA_MASK                       (0x0000FFFFU)
+#define CSL_GPMC_BCH_SWDATA_BCH_DATA_SHIFT                      (0U)
+#define CSL_GPMC_BCH_SWDATA_BCH_DATA_RESETVAL                   (0x00000000U)
+#define CSL_GPMC_BCH_SWDATA_BCH_DATA_MAX                        (0x0000ffffU)
+
+#define CSL_GPMC_BCH_SWDATA_RESETVAL                            (0x00000000U)
+
+/* BCH_RESULT_5 */
+
+#define CSL_GPMC_BCH_RESULT_5_BCH_RESULT_5_MASK                 (0xFFFFFFFFU)
+#define CSL_GPMC_BCH_RESULT_5_BCH_RESULT_5_SHIFT                (0U)
+#define CSL_GPMC_BCH_RESULT_5_BCH_RESULT_5_RESETVAL             (0x00000000U)
+#define CSL_GPMC_BCH_RESULT_5_BCH_RESULT_5_MAX                  (0xffffffffU)
+
+#define CSL_GPMC_BCH_RESULT_5_RESETVAL                          (0x00000000U)
+
+/* BCH_RESULT_6 */
+
+#define CSL_GPMC_BCH_RESULT_6_BCH_RESULT_6_MASK                 (0x0000FFFFU)
+#define CSL_GPMC_BCH_RESULT_6_BCH_RESULT_6_SHIFT                (0U)
+#define CSL_GPMC_BCH_RESULT_6_BCH_RESULT_6_RESETVAL             (0x00000000U)
+#define CSL_GPMC_BCH_RESULT_6_BCH_RESULT_6_MAX                  (0x0000ffffU)
+
+#define CSL_GPMC_BCH_RESULT_6_RESETVAL                          (0x00000000U)
+
+/* BCH_RESULT_4 */
+
+#define CSL_GPMC_BCH_RESULT_4_BCH_RESULT_4_MASK                 (0xFFFFFFFFU)
+#define CSL_GPMC_BCH_RESULT_4_BCH_RESULT_4_SHIFT                (0U)
+#define CSL_GPMC_BCH_RESULT_4_BCH_RESULT_4_RESETVAL             (0x00000000U)
+#define CSL_GPMC_BCH_RESULT_4_BCH_RESULT_4_MAX                  (0xffffffffU)
+
+#define CSL_GPMC_BCH_RESULT_4_RESETVAL                          (0x00000000U)
+
+/* CONFIG1 */
+
+#define CSL_GPMC_CONFIG1_DEVICESIZE_MASK                        (0x00003000U)
+#define CSL_GPMC_CONFIG1_DEVICESIZE_SHIFT                       (12U)
+#define CSL_GPMC_CONFIG1_DEVICESIZE_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_CONFIG1_DEVICESIZE_SIXTEENBITS                 (0x00000001U)
+#define CSL_GPMC_CONFIG1_DEVICESIZE_EIGHTBITS                   (0x00000000U)
+#define CSL_GPMC_CONFIG1_DEVICESIZE_THIRTYTWOBITS               (0x00000002U)
+#define CSL_GPMC_CONFIG1_DEVICESIZE_RES                         (0x00000003U)
+
+#define CSL_GPMC_CONFIG1_WRITEMULTIPLE_MASK                     (0x10000000U)
+#define CSL_GPMC_CONFIG1_WRITEMULTIPLE_SHIFT                    (28U)
+#define CSL_GPMC_CONFIG1_WRITEMULTIPLE_RESETVAL                 (0x00000000U)
+#define CSL_GPMC_CONFIG1_WRITEMULTIPLE_WRMULTIPLE               (0x00000001U)
+#define CSL_GPMC_CONFIG1_WRITEMULTIPLE_WRSINGLE                 (0x00000000U)
+
+#define CSL_GPMC_CONFIG1_WRAPBURST_MASK                         (0x80000000U)
+#define CSL_GPMC_CONFIG1_WRAPBURST_SHIFT                        (31U)
+#define CSL_GPMC_CONFIG1_WRAPBURST_RESETVAL                     (0x00000000U)
+#define CSL_GPMC_CONFIG1_WRAPBURST_WRAPNOTSUPP                  (0x00000000U)
+#define CSL_GPMC_CONFIG1_WRAPBURST_WRAPSUPP                     (0x00000001U)
+
+#define CSL_GPMC_CONFIG1_READTYPE_MASK                          (0x20000000U)
+#define CSL_GPMC_CONFIG1_READTYPE_SHIFT                         (29U)
+#define CSL_GPMC_CONFIG1_READTYPE_RESETVAL                      (0x00000000U)
+#define CSL_GPMC_CONFIG1_READTYPE_RDASYNC                       (0x00000000U)
+#define CSL_GPMC_CONFIG1_READTYPE_RDSYNC                        (0x00000001U)
+
+#define CSL_GPMC_CONFIG1_READMULTIPLE_MASK                      (0x40000000U)
+#define CSL_GPMC_CONFIG1_READMULTIPLE_SHIFT                     (30U)
+#define CSL_GPMC_CONFIG1_READMULTIPLE_RESETVAL                  (0x00000000U)
+#define CSL_GPMC_CONFIG1_READMULTIPLE_RDSINGLE                  (0x00000000U)
+#define CSL_GPMC_CONFIG1_READMULTIPLE_RDMULTIPLE                (0x00000001U)
+
+#define CSL_GPMC_CONFIG1_TIMEPARAGRANULARITY_MASK               (0x00000010U)
+#define CSL_GPMC_CONFIG1_TIMEPARAGRANULARITY_SHIFT              (4U)
+#define CSL_GPMC_CONFIG1_TIMEPARAGRANULARITY_RESETVAL           (0x00000000U)
+#define CSL_GPMC_CONFIG1_TIMEPARAGRANULARITY_X1                 (0x00000000U)
+#define CSL_GPMC_CONFIG1_TIMEPARAGRANULARITY_X2                 (0x00000001U)
+
+#define CSL_GPMC_CONFIG1_DEVICETYPE_MASK                        (0x00000C00U)
+#define CSL_GPMC_CONFIG1_DEVICETYPE_SHIFT                       (10U)
+#define CSL_GPMC_CONFIG1_DEVICETYPE_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_CONFIG1_DEVICETYPE_RES2                        (0x00000003U)
+#define CSL_GPMC_CONFIG1_DEVICETYPE_NORLIKE                     (0x00000000U)
+#define CSL_GPMC_CONFIG1_DEVICETYPE_NANDLIKE                    (0x00000002U)
+#define CSL_GPMC_CONFIG1_DEVICETYPE_RES1                        (0x00000001U)
+
+#define CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_MASK                   (0x00000003U)
+#define CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_SHIFT                  (0U)
+#define CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_RESETVAL               (0x00000000U)
+#define CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_DIVBY4                 (0x00000003U)
+#define CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_DIVBY2                 (0x00000001U)
+#define CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_DIVBY1                 (0x00000000U)
+#define CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_DIVBY3                 (0x00000002U)
+
+#define CSL_GPMC_CONFIG1_MUXADDDATA_MASK                        (0x00000300U)
+#define CSL_GPMC_CONFIG1_MUXADDDATA_SHIFT                       (8U)
+#define CSL_GPMC_CONFIG1_MUXADDDATA_RESETVAL                    (0x00000000U)
+#define CSL_GPMC_CONFIG1_MUXADDDATA_MUX                         (0x00000002U)
+#define CSL_GPMC_CONFIG1_MUXADDDATA_NONMUX                      (0x00000000U)
+#define CSL_GPMC_CONFIG1_MUXADDDATA_AADMUX                      (0x00000001U)
+#define CSL_GPMC_CONFIG1_MUXADDDATA_RESERVED                    (0x00000003U)
+
+#define CSL_GPMC_CONFIG1_WAITMONITORINGTIME_MASK                (0x000C0000U)
+#define CSL_GPMC_CONFIG1_WAITMONITORINGTIME_SHIFT               (18U)
+#define CSL_GPMC_CONFIG1_WAITMONITORINGTIME_RESETVAL            (0x00000000U)
+#define CSL_GPMC_CONFIG1_WAITMONITORINGTIME_NOTDEFINED          (0x00000003U)
+#define CSL_GPMC_CONFIG1_WAITMONITORINGTIME_TWODEVICEB4         (0x00000002U)
+#define CSL_GPMC_CONFIG1_WAITMONITORINGTIME_ONEDEVICEB4         (0x00000001U)
+#define CSL_GPMC_CONFIG1_WAITMONITORINGTIME_ATVALID             (0x00000000U)
+
+#define CSL_GPMC_CONFIG1_WAITREADMONITORING_MASK                (0x00400000U)
+#define CSL_GPMC_CONFIG1_WAITREADMONITORING_SHIFT               (22U)
+#define CSL_GPMC_CONFIG1_WAITREADMONITORING_RESETVAL            (0x00000000U)
+#define CSL_GPMC_CONFIG1_WAITREADMONITORING_WMONIT              (0x00000001U)
+#define CSL_GPMC_CONFIG1_WAITREADMONITORING_WNOTMONIT           (0x00000000U)
+
+#define CSL_GPMC_CONFIG1_WAITPINSELECT_MASK                     (0x00030000U)
+#define CSL_GPMC_CONFIG1_WAITPINSELECT_SHIFT                    (16U)
+#define CSL_GPMC_CONFIG1_WAITPINSELECT_RESETVAL                 (0x00000000U)
+#define CSL_GPMC_CONFIG1_WAITPINSELECT_W2                       (0x00000002U)
+#define CSL_GPMC_CONFIG1_WAITPINSELECT_W1                       (0x00000001U)
+#define CSL_GPMC_CONFIG1_WAITPINSELECT_W3                       (0x00000003U)
+#define CSL_GPMC_CONFIG1_WAITPINSELECT_W0                       (0x00000000U)
+
+#define CSL_GPMC_CONFIG1_CLKACTIVATIONTIME_MASK                 (0x06000000U)
+#define CSL_GPMC_CONFIG1_CLKACTIVATIONTIME_SHIFT                (25U)
+#define CSL_GPMC_CONFIG1_CLKACTIVATIONTIME_RESETVAL             (0x00000000U)
+#define CSL_GPMC_CONFIG1_CLKACTIVATIONTIME_ATSTART              (0x00000000U)
+#define CSL_GPMC_CONFIG1_CLKACTIVATIONTIME_TWOCLKB4             (0x00000002U)
+#define CSL_GPMC_CONFIG1_CLKACTIVATIONTIME_ONECLKB4             (0x00000001U)
+#define CSL_GPMC_CONFIG1_CLKACTIVATIONTIME_NOTDEFINED           (0x00000003U)
+
+#define CSL_GPMC_CONFIG1_WAITWRITEMONITORING_MASK               (0x00200000U)
+#define CSL_GPMC_CONFIG1_WAITWRITEMONITORING_SHIFT              (21U)
+#define CSL_GPMC_CONFIG1_WAITWRITEMONITORING_RESETVAL           (0x00000000U)
+#define CSL_GPMC_CONFIG1_WAITWRITEMONITORING_WNOTMONIT          (0x00000000U)
+#define CSL_GPMC_CONFIG1_WAITWRITEMONITORING_WMONIT             (0x00000001U)
+
+#define CSL_GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_MASK          (0x01800000U)
+#define CSL_GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_SHIFT         (23U)
+#define CSL_GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_RESETVAL      (0x00000000U)
+#define CSL_GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_EIGHT         (0x00000001U)
+#define CSL_GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_SIXTEEN       (0x00000002U)
+#define CSL_GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_THIRTYTWO     (0x00000003U)
+#define CSL_GPMC_CONFIG1_ATTACHEDDEVICEPAGELENGTH_FOUR          (0x00000000U)
+
+#define CSL_GPMC_CONFIG1_WRITETYPE_MASK                         (0x08000000U)
+#define CSL_GPMC_CONFIG1_WRITETYPE_SHIFT                        (27U)
+#define CSL_GPMC_CONFIG1_WRITETYPE_RESETVAL                     (0x00000000U)
+#define CSL_GPMC_CONFIG1_WRITETYPE_WRASYNC                      (0x00000000U)
+#define CSL_GPMC_CONFIG1_WRITETYPE_WRSYNC                       (0x00000001U)
+
+#define CSL_GPMC_CONFIG1_RESETVAL                               (0x00000000U)
+
+/* CONFIG2 */
+
+#define CSL_GPMC_CONFIG2_CSONTIME_MASK                          (0x0000000FU)
+#define CSL_GPMC_CONFIG2_CSONTIME_SHIFT                         (0U)
+#define CSL_GPMC_CONFIG2_CSONTIME_RESETVAL                      (0x00000001U)
+#define CSL_GPMC_CONFIG2_CSONTIME_MAX                           (0x0000000fU)
+
+#define CSL_GPMC_CONFIG2_CSWROFFTIME_MASK                       (0x001F0000U)
+#define CSL_GPMC_CONFIG2_CSWROFFTIME_SHIFT                      (16U)
+#define CSL_GPMC_CONFIG2_CSWROFFTIME_RESETVAL                   (0x00000010U)
+#define CSL_GPMC_CONFIG2_CSWROFFTIME_MAX                        (0x0000001fU)
+
+#define CSL_GPMC_CONFIG2_CSRDOFFTIME_MASK                       (0x00001F00U)
+#define CSL_GPMC_CONFIG2_CSRDOFFTIME_SHIFT                      (8U)
+#define CSL_GPMC_CONFIG2_CSRDOFFTIME_RESETVAL                   (0x00000010U)
+#define CSL_GPMC_CONFIG2_CSRDOFFTIME_MAX                        (0x0000001fU)
+
+#define CSL_GPMC_CONFIG2_CSEXTRADELAY_MASK                      (0x00000080U)
+#define CSL_GPMC_CONFIG2_CSEXTRADELAY_SHIFT                     (7U)
+#define CSL_GPMC_CONFIG2_CSEXTRADELAY_RESETVAL                  (0x00000000U)
+#define CSL_GPMC_CONFIG2_CSEXTRADELAY_NOTDELAYED                (0x00000000U)
+#define CSL_GPMC_CONFIG2_CSEXTRADELAY_DELAYED                   (0x00000001U)
+
+#define CSL_GPMC_CONFIG2_RESETVAL                               (0x00101001U)
+
+/* CONFIG3 */
+
+#define CSL_GPMC_CONFIG3_ADVEXTRADELAY_MASK                     (0x00000080U)
+#define CSL_GPMC_CONFIG3_ADVEXTRADELAY_SHIFT                    (7U)
+#define CSL_GPMC_CONFIG3_ADVEXTRADELAY_RESETVAL                 (0x00000000U)
+#define CSL_GPMC_CONFIG3_ADVEXTRADELAY_NOTDELAYED               (0x00000000U)
+#define CSL_GPMC_CONFIG3_ADVEXTRADELAY_DELAYED                  (0x00000001U)
+
+#define CSL_GPMC_CONFIG3_ADVAADMUXONTIME_MASK                   (0x00000070U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXONTIME_SHIFT                  (4U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXONTIME_RESETVAL               (0x00000001U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXONTIME_MAX                    (0x00000007U)
+
+#define CSL_GPMC_CONFIG3_ADVONTIME_MASK                         (0x0000000FU)
+#define CSL_GPMC_CONFIG3_ADVONTIME_SHIFT                        (0U)
+#define CSL_GPMC_CONFIG3_ADVONTIME_RESETVAL                     (0x00000004U)
+#define CSL_GPMC_CONFIG3_ADVONTIME_MAX                          (0x0000000fU)
+
+#define CSL_GPMC_CONFIG3_ADVWROFFTIME_MASK                      (0x001F0000U)
+#define CSL_GPMC_CONFIG3_ADVWROFFTIME_SHIFT                     (16U)
+#define CSL_GPMC_CONFIG3_ADVWROFFTIME_RESETVAL                  (0x00000006U)
+#define CSL_GPMC_CONFIG3_ADVWROFFTIME_MAX                       (0x0000001fU)
+
+#define CSL_GPMC_CONFIG3_ADVRDOFFTIME_MASK                      (0x00001F00U)
+#define CSL_GPMC_CONFIG3_ADVRDOFFTIME_SHIFT                     (8U)
+#define CSL_GPMC_CONFIG3_ADVRDOFFTIME_RESETVAL                  (0x00000005U)
+#define CSL_GPMC_CONFIG3_ADVRDOFFTIME_MAX                       (0x0000001fU)
+
+#define CSL_GPMC_CONFIG3_ADVAADMUXRDOFFTIME_MASK                (0x07000000U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXRDOFFTIME_SHIFT               (24U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXRDOFFTIME_RESETVAL            (0x00000002U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXRDOFFTIME_MAX                 (0x00000007U)
+
+#define CSL_GPMC_CONFIG3_ADVAADMUXWROFFTIME_MASK                (0x70000000U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXWROFFTIME_SHIFT               (28U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXWROFFTIME_RESETVAL            (0x00000002U)
+#define CSL_GPMC_CONFIG3_ADVAADMUXWROFFTIME_MAX                 (0x00000007U)
+
+#define CSL_GPMC_CONFIG3_RESETVAL                               (0x22060514U)
+
+/* CONFIG4 */
+
+#define CSL_GPMC_CONFIG4_OEONTIME_MASK                          (0x0000000FU)
+#define CSL_GPMC_CONFIG4_OEONTIME_SHIFT                         (0U)
+#define CSL_GPMC_CONFIG4_OEONTIME_RESETVAL                      (0x00000006U)
+#define CSL_GPMC_CONFIG4_OEONTIME_MAX                           (0x0000000fU)
+
+#define CSL_GPMC_CONFIG4_WEONTIME_MASK                          (0x000F0000U)
+#define CSL_GPMC_CONFIG4_WEONTIME_SHIFT                         (16U)
+#define CSL_GPMC_CONFIG4_WEONTIME_RESETVAL                      (0x00000005U)
+#define CSL_GPMC_CONFIG4_WEONTIME_MAX                           (0x0000000fU)
+
+#define CSL_GPMC_CONFIG4_OEOFFTIME_MASK                         (0x00001F00U)
+#define CSL_GPMC_CONFIG4_OEOFFTIME_SHIFT                        (8U)
+#define CSL_GPMC_CONFIG4_OEOFFTIME_RESETVAL                     (0x00000010U)
+#define CSL_GPMC_CONFIG4_OEOFFTIME_MAX                          (0x0000001fU)
+
+#define CSL_GPMC_CONFIG4_WEOFFTIME_MASK                         (0x1F000000U)
+#define CSL_GPMC_CONFIG4_WEOFFTIME_SHIFT                        (24U)
+#define CSL_GPMC_CONFIG4_WEOFFTIME_RESETVAL                     (0x00000010U)
+#define CSL_GPMC_CONFIG4_WEOFFTIME_MAX                          (0x0000001fU)
+
+#define CSL_GPMC_CONFIG4_OEEXTRADELAY_MASK                      (0x00000080U)
+#define CSL_GPMC_CONFIG4_OEEXTRADELAY_SHIFT                     (7U)
+#define CSL_GPMC_CONFIG4_OEEXTRADELAY_RESETVAL                  (0x00000000U)
+#define CSL_GPMC_CONFIG4_OEEXTRADELAY_NOTDELAYED                (0x00000000U)
+#define CSL_GPMC_CONFIG4_OEEXTRADELAY_DELAYED                   (0x00000001U)
+
+#define CSL_GPMC_CONFIG4_WEEXTRADELAY_MASK                      (0x00800000U)
+#define CSL_GPMC_CONFIG4_WEEXTRADELAY_SHIFT                     (23U)
+#define CSL_GPMC_CONFIG4_WEEXTRADELAY_RESETVAL                  (0x00000000U)
+#define CSL_GPMC_CONFIG4_WEEXTRADELAY_NOTDELAYED                (0x00000000U)
+#define CSL_GPMC_CONFIG4_WEEXTRADELAY_DELAYED                   (0x00000001U)
+
+#define CSL_GPMC_CONFIG4_OEAADMUXOFFTIME_MASK                   (0x0000E000U)
+#define CSL_GPMC_CONFIG4_OEAADMUXOFFTIME_SHIFT                  (13U)
+#define CSL_GPMC_CONFIG4_OEAADMUXOFFTIME_RESETVAL               (0x00000003U)
+#define CSL_GPMC_CONFIG4_OEAADMUXOFFTIME_MAX                    (0x00000007U)
+
+#define CSL_GPMC_CONFIG4_OEAADMUXONTIME_MASK                    (0x00000070U)
+#define CSL_GPMC_CONFIG4_OEAADMUXONTIME_SHIFT                   (4U)
+#define CSL_GPMC_CONFIG4_OEAADMUXONTIME_RESETVAL                (0x00000001U)
+#define CSL_GPMC_CONFIG4_OEAADMUXONTIME_MAX                     (0x00000007U)
+
+#define CSL_GPMC_CONFIG4_RESETVAL                               (0x10057016U)
+
+/* CONFIG5 */
+
+#define CSL_GPMC_CONFIG5_WRCYCLETIME_MASK                       (0x00001F00U)
+#define CSL_GPMC_CONFIG5_WRCYCLETIME_SHIFT                      (8U)
+#define CSL_GPMC_CONFIG5_WRCYCLETIME_RESETVAL                   (0x00000011U)
+#define CSL_GPMC_CONFIG5_WRCYCLETIME_MAX                        (0x0000001fU)
+
+#define CSL_GPMC_CONFIG5_RDCYCLETIME_MASK                       (0x0000001FU)
+#define CSL_GPMC_CONFIG5_RDCYCLETIME_SHIFT                      (0U)
+#define CSL_GPMC_CONFIG5_RDCYCLETIME_RESETVAL                   (0x00000011U)
+#define CSL_GPMC_CONFIG5_RDCYCLETIME_MAX                        (0x0000001fU)
+
+#define CSL_GPMC_CONFIG5_PAGEBURSTACCESSTIME_MASK               (0x0F000000U)
+#define CSL_GPMC_CONFIG5_PAGEBURSTACCESSTIME_SHIFT              (24U)
+#define CSL_GPMC_CONFIG5_PAGEBURSTACCESSTIME_RESETVAL           (0x00000001U)
+#define CSL_GPMC_CONFIG5_PAGEBURSTACCESSTIME_MAX                (0x0000000fU)
+
+#define CSL_GPMC_CONFIG5_RDACCESSTIME_MASK                      (0x001F0000U)
+#define CSL_GPMC_CONFIG5_RDACCESSTIME_SHIFT                     (16U)
+#define CSL_GPMC_CONFIG5_RDACCESSTIME_RESETVAL                  (0x0000000fU)
+#define CSL_GPMC_CONFIG5_RDACCESSTIME_MAX                       (0x0000001fU)
+
+#define CSL_GPMC_CONFIG5_RESETVAL                               (0x010f1111U)
+
+/* CONFIG6 */
+
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_MASK               (0x00000040U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_SHIFT              (6U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_RESETVAL           (0x00000000U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_NOC2CDELAY         (0x00000000U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_C2CDELAY           (0x00000001U)
+
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDELAY_MASK                  (0x00000F00U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDELAY_SHIFT                 (8U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDELAY_RESETVAL              (0x00000000U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLEDELAY_MAX                   (0x0000000fU)
+
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_MASK               (0x00000080U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_SHIFT              (7U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_RESETVAL           (0x00000000U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_NOC2CDELAY         (0x00000000U)
+#define CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_C2CDELAY           (0x00000001U)
+
+#define CSL_GPMC_CONFIG6_BUSTURNAROUND_MASK                     (0x0000000FU)
+#define CSL_GPMC_CONFIG6_BUSTURNAROUND_SHIFT                    (0U)
+#define CSL_GPMC_CONFIG6_BUSTURNAROUND_RESETVAL                 (0x00000000U)
+#define CSL_GPMC_CONFIG6_BUSTURNAROUND_MAX                      (0x0000000fU)
+
+#define CSL_GPMC_CONFIG6_WRDATAONADMUXBUS_MASK                  (0x000F0000U)
+#define CSL_GPMC_CONFIG6_WRDATAONADMUXBUS_SHIFT                 (16U)
+#define CSL_GPMC_CONFIG6_WRDATAONADMUXBUS_RESETVAL              (0x00000007U)
+#define CSL_GPMC_CONFIG6_WRDATAONADMUXBUS_MAX                   (0x0000000fU)
+
+#define CSL_GPMC_CONFIG6_WRACCESSTIME_MASK                      (0x1F000000U)
+#define CSL_GPMC_CONFIG6_WRACCESSTIME_SHIFT                     (24U)
+#define CSL_GPMC_CONFIG6_WRACCESSTIME_RESETVAL                  (0x0000000fU)
+#define CSL_GPMC_CONFIG6_WRACCESSTIME_MAX                       (0x0000001fU)
+
+#define CSL_GPMC_CONFIG6_RESETVAL                               (0x8f070000U)
+
+/* CONFIG7 */
+
+#define CSL_GPMC_CONFIG7_BASEADDRESS_MASK                       (0x0000003FU)
+#define CSL_GPMC_CONFIG7_BASEADDRESS_SHIFT                      (0U)
+#define CSL_GPMC_CONFIG7_BASEADDRESS_RESETVAL                   (0x00000000U)
+#define CSL_GPMC_CONFIG7_BASEADDRESS_MAX                        (0x0000003fU)
+
+#define CSL_GPMC_CONFIG7_MASKADDRESS_MASK                       (0x00000F00U)
+#define CSL_GPMC_CONFIG7_MASKADDRESS_SHIFT                      (8U)
+#define CSL_GPMC_CONFIG7_MASKADDRESS_RESETVAL                   (0x0000000fU)
+#define CSL_GPMC_CONFIG7_MASKADDRESS_MAX                        (0x0000000fU)
+
+#define CSL_GPMC_CONFIG7_CSVALID_MASK                           (0x00000040U)
+#define CSL_GPMC_CONFIG7_CSVALID_SHIFT                          (6U)
+#define CSL_GPMC_CONFIG7_CSVALID_RESETVAL                       (0x00000001U)
+#define CSL_GPMC_CONFIG7_CSVALID_CSDISABLED                     (0x00000000U)
+#define CSL_GPMC_CONFIG7_CSVALID_CSENABLED                      (0x00000001U)
+
+#define CSL_GPMC_CONFIG7_RESETVAL                               (0x00000f40U)
+
+/* NAND_COMMAND */
+
+#define CSL_GPMC_NAND_COMMAND_GPMC_NAND_COMMAND_0_MASK          (0xFFFFFFFFU)
+#define CSL_GPMC_NAND_COMMAND_GPMC_NAND_COMMAND_0_SHIFT         (0U)
+#define CSL_GPMC_NAND_COMMAND_GPMC_NAND_COMMAND_0_RESETVAL      (0x00000000U)
+#define CSL_GPMC_NAND_COMMAND_GPMC_NAND_COMMAND_0_MAX           (0xffffffffU)
+
+#define CSL_GPMC_NAND_COMMAND_RESETVAL                          (0x00000000U)
+
+/* NAND_ADDRESS */
+
+#define CSL_GPMC_NAND_ADDRESS_GPMC_NAND_ADDRESS_0_MASK          (0xFFFFFFFFU)
+#define CSL_GPMC_NAND_ADDRESS_GPMC_NAND_ADDRESS_0_SHIFT         (0U)
+#define CSL_GPMC_NAND_ADDRESS_GPMC_NAND_ADDRESS_0_RESETVAL      (0x00000000U)
+#define CSL_GPMC_NAND_ADDRESS_GPMC_NAND_ADDRESS_0_MAX           (0xffffffffU)
+
+#define CSL_GPMC_NAND_ADDRESS_RESETVAL                          (0x00000000U)
+
+/* NAND_DATA */
+
+#define CSL_GPMC_NAND_DATA_GPMC_NAND_DATA_0_MASK                (0xFFFFFFFFU)
+#define CSL_GPMC_NAND_DATA_GPMC_NAND_DATA_0_SHIFT               (0U)
+#define CSL_GPMC_NAND_DATA_GPMC_NAND_DATA_0_RESETVAL            (0x00000000U)
+#define CSL_GPMC_NAND_DATA_GPMC_NAND_DATA_0_MAX                 (0xffffffffU)
+
+#define CSL_GPMC_NAND_DATA_RESETVAL                             (0x00000000U)
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/source/drivers/gpmc/v0/dma/gpmc_dma.c b/source/drivers/gpmc/v0/dma/gpmc_dma.c
new file mode 100644
index 0000000000..6ab3aee9eb
--- /dev/null
+++ b/source/drivers/gpmc/v0/dma/gpmc_dma.c
@@ -0,0 +1,125 @@
+/*
+ *  Copyright (C) 2023 Texas Instruments Incorporated
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ *    Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the
+ *    distribution.
+ *
+ *    Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *  \file gpmc_dma.c
+ *
+ *  \brief GPMC DMA source file.
+ */
+
+/* ========================================================================== */
+/*                             Include Files                                  */
+/* ========================================================================== */
+
+#include <kernel/dpl/SystemP.h>
+#include <string.h>
+#include <drivers/gpmc/v0/dma/gpmc_dma.h>
+
+/* ========================================================================== */
+/*                           Macros & Typedefs                                */
+/* ========================================================================== */
+
+
+/* ========================================================================== */
+/*                             Global Variables                               */
+/* ========================================================================== */
+
+extern GPMC_DmaConfig gGpmcDmaConfig[];
+extern uint32_t gGpmcDmaConfigNum;
+
+/* ========================================================================== */
+/*                             Function Definitions                           */
+/* ========================================================================== */
+
+GPMC_DmaHandle GPMC_dmaOpen(int32_t index)
+{
+	GPMC_DmaConfig *config = NULL;
+
+	if((gGpmcDmaConfigNum > 0) && (index >= 0))
+	{
+		config = &gGpmcDmaConfig[index];
+		if((config->fxns) && (config->fxns->dmaOpenFxn) && (config->gpmcDmaArgs))
+		{
+			int32_t status;
+
+			status = config->fxns->dmaOpenFxn(config->gpmcDmaArgs);
+			if(status != SystemP_SUCCESS)
+			{
+				config = NULL;
+			}
+		}
+	}
+
+	return (GPMC_DmaHandle)config;
+}
+
+int32_t GPMC_dmaClose(GPMC_DmaHandle handle)
+{
+	int32_t status = SystemP_SUCCESS;
+
+	if(handle != NULL)
+	{
+		GPMC_DmaConfig *config = (GPMC_DmaConfig *)handle;
+
+		if((config->fxns) && (config->fxns->dmaCloseFxn))
+		{
+			status = config->fxns->dmaCloseFxn(handle, config->gpmcDmaArgs);
+		}
+	}
+	else
+	{
+		status = SystemP_FAILURE;
+	}
+
+	return status;
+}
+
+int32_t GPMC_dmaCopy(GPMC_DmaHandle handle, void* dst, void* src, uint32_t length, uint8_t fifoDrain)
+{
+	int32_t status = SystemP_SUCCESS;
+
+	if(handle != NULL)
+	{
+		GPMC_DmaConfig *config = (GPMC_DmaConfig *)handle;
+
+		if((config->fxns) && (config->fxns->dmaCopyFxn))
+		{
+			status = config->fxns->dmaCopyFxn(config->gpmcDmaArgs, dst, src, length, fifoDrain);
+		}
+	}
+	else
+	{
+		status = SystemP_FAILURE;
+	}
+
+	return status;
+}
\ No newline at end of file
diff --git a/source/drivers/gpmc/v0/dma/gpmc_dma.h b/source/drivers/gpmc/v0/dma/gpmc_dma.h
new file mode 100644
index 0000000000..ed89f2cad9
--- /dev/null
+++ b/source/drivers/gpmc/v0/dma/gpmc_dma.h
@@ -0,0 +1,174 @@
+/*
+ *  Copyright (C) 2023 Texas Instruments Incorporated
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ *    Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the
+ *    distribution.
+ *
+ *    Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *  \file gpmc_dma.h
+ *
+ *  \brief GPMC DMA header file.
+ */
+
+#ifndef GPMC_DMA_H_
+#define GPMC_DMA_H_
+
+#include <stdint.h>
+#include <kernel/dpl/SystemP.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/**
+ *  \defgroup GPMC_DMA APIs for GPMC DMA mode
+ *  \ingroup DRV_GPMC_MODULE
+ *
+ *  This module contains APIs to program and use DMA drivers available in the SoC with GPMC.
+ *
+ *  @{
+ */
+
+/**
+ * \brief Handle to the GPMC DMA Config Object returned by \ref GPMC_dmaOpen
+ */
+typedef void* GPMC_DmaHandle;
+
+/**
+ * \brief Driver implementation to open a specific DMA driver channel - UDMA, EDMA etc
+ *
+ * Typically this callback is hidden from the end application and is implemented
+ * when a new DMA driver needs to be supported.
+ *
+ * \param gpmcDmaArgs   [in] DMA specific arguments, obtained from the config
+ *
+ * \return SystemP_SUCCESS on success, else failure
+ */
+typedef int32_t (*GPMC_dmaOpenFxn)(void *gpmcDmaArgs);
+
+/**
+ * \brief Driver implementation to close a specific DMA driver channel - UDMA, EDMA etc
+ *
+ * Typically this callback is hidden from the end application and is implemented
+ * when a new DMA driver needs to be supported.
+ *
+ * \param GPMC_DmaHandle   [in] GPMC DMA Object handle returned from \ref GPMC_dmaOpen
+ * \param gpmcDmaArgs      [in] DMA specific arguments, obtained from the config
+ *
+ * \return SystemP_SUCCESS on success, else failure
+ */
+typedef int32_t (*GPMC_dmaCloseFxn)(GPMC_DmaHandle, void *gpmcDmaArgs);
+
+/**
+ * \brief Driver implementation to do a DMA copy using a specific DMA driver - UDMA, EDMA etc
+ *
+ * Typically this callback is hidden from the end application and is implemented
+ * when a new DMA driver needs to be supported.
+ *
+ * \param gpmcDmaArgs   [in] DMA specific arguments, obtained from the config
+ * \param dst           [in] Destination address to which the data is to be copied
+ * \param src           [in] Source address from which the data is to be copied
+ * \param length        [in] Data length
+ * \param fifoDrain     [in] Drain GPMC FIFO
+ *
+ * \return SystemP_SUCCESS on success, else failure
+ */
+typedef int32_t (*GPMC_dmaCopyFxn)(void *gpmcDmaArgs, void *dst, void *src, uint32_t length, uint8_t fifoDrain);
+
+/**
+ * \brief Driver implementation callbacks
+ */
+typedef struct GPMC_DmaFxns_s
+{
+	GPMC_dmaOpenFxn    dmaOpenFxn;
+	GPMC_dmaCloseFxn   dmaCloseFxn;
+	GPMC_dmaCopyFxn    dmaCopyFxn;
+
+} GPMC_DmaFxns;
+
+/**
+ * \brief GPMC DMA Configuration, these are filled by SysCfg based on the DMA driver that is selected
+ */
+typedef struct GPMC_DmaConfig_s
+{
+	GPMC_DmaFxns *fxns;
+	/* Registered callbacks for a particular DMA driver. This will be set by Sysconfig depending on the DMA driver selected*/
+	void *gpmcDmaArgs;
+	/* Arguments specific to a DMA driver. This will be typecasted to the specific DMA driver args struct
+	 * when used by the appropriate callback. This struct will be defined in the specific DMA driver header file.
+	 * Allocation of this struct will be done statically using Sysconfig code generation in the example code
+	 */
+
+} GPMC_DmaConfig;
+
+/**
+ * \brief API to open an GPMC DMA channel
+ *
+ * This API will open a DMA Channel using the appropriate DMA driver callbacks and the registered via Sysconfig
+ *
+ * \param index [in] Index of the DMA Config selected for this particular GPMC driver instance
+ *
+ * \return Handle to the GPMC DMA Config Object
+ */
+GPMC_DmaHandle GPMC_dmaOpen(int32_t index);
+
+/**
+ * \brief API to close an GPMC DMA channel
+ *
+ * This API will open a DMA Channel using the appropriate DMA driver callbacks registered via Sysconfig
+ *
+ * \param index [in] Handle to the GPMC DMA Config Object returned from \ref GPMC_dmaOpen
+ *
+ * \return SystemP_SUCCESS on success, else failure
+ */
+int32_t GPMC_dmaClose(GPMC_DmaHandle handle);
+
+/**
+ * \brief API to do a DMA Copy using appropriate DMA Channel opened
+ *
+ * This API will open a DMA Channel using the appropriate DMA driver callbacks registered via Sysconfig
+ *
+ * \param handle        [in] Handle to the GPMC DMA Config Object returned from \ref GPMC_dmaOpen
+ * \param dst           [in] Destination address to which the data is to be copied
+ * \param src           [in] Source address from which the data is to be copied
+ * \param length        [in] Data length
+ * \param fifoDrain     [in] Flag to enable fifo drain for NAND devices
+ *
+ * \return SystemP_SUCCESS on success, else failure
+ */
+int32_t GPMC_dmaCopy(GPMC_DmaHandle handle, void* dst, void* src, uint32_t length, uint8_t fifoDrain);
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GPMC_DMA_H_ */
\ No newline at end of file
diff --git a/source/drivers/gpmc/v0/dma/udma/gpmc_dma_udma.c b/source/drivers/gpmc/v0/dma/udma/gpmc_dma_udma.c
new file mode 100644
index 0000000000..f64559ebab
--- /dev/null
+++ b/source/drivers/gpmc/v0/dma/udma/gpmc_dma_udma.c
@@ -0,0 +1,336 @@
+/*
+ *  Copyright (C) 2023 Texas Instruments Incorporated
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ *    Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the
+ *    distribution.
+ *
+ *    Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <drivers/gpmc/v0/dma/gpmc_dma.h>
+#include <drivers/gpmc/v0/dma/udma/gpmc_dma_udma.h>
+#include <drivers/udma.h>
+#include <drivers/udma/hw_include/csl_intaggr.h>
+#include <kernel/dpl/CacheP.h>
+#include <drivers/gpmc.h>
+
+static int32_t GpmcDma_udmaOpen(void* gpmcDmaArgs);
+static int32_t GpmcDma_udmaClose(GPMC_DmaHandle handle, void* gpmcDmaArgs);
+static int32_t GpmcDma_udmaCopy(void* gpmcDmaArgs, void* dst, void* src, uint32_t length, uint8_t fifoDrain);
+
+GPMC_DmaFxns gGpmcDmaUdmaFxns =
+{
+    .dmaOpenFxn = GpmcDma_udmaOpen,
+    .dmaCloseFxn = GpmcDma_udmaClose,
+    .dmaCopyFxn = GpmcDma_udmaCopy,
+};
+
+static int32_t GpmcDma_udmaOpen(void* gpmcDmaArgs)
+{
+    int32_t status = SystemP_SUCCESS;
+    int32_t udmaStatus = UDMA_SOK;
+    uint32_t            chType;
+    Udma_ChHandle       chHandle;
+    Udma_ChPrms         chPrms;
+    Udma_ChTxPrms       txPrms;
+    Udma_ChRxPrms       rxPrms;
+    Udma_DrvHandle      drvHandle;
+    uint8_t*            trpdMem;
+    uint32_t            trpdMemSize;
+
+    GpmcDma_UdmaArgs *udmaArgs = (GpmcDma_UdmaArgs *)gpmcDmaArgs;
+
+    drvHandle   = udmaArgs->drvHandle;
+    chHandle    = udmaArgs->chHandle;
+    trpdMem     = (uint8_t *) udmaArgs->trpdMem;
+    trpdMemSize = udmaArgs->trpdMemSize;
+
+    /* Init channel parameters */
+    chType = UDMA_CH_TYPE_TR_BLK_COPY;
+    UdmaChPrms_init(&chPrms, chType);
+    chPrms.fqRingPrms.ringMem       = udmaArgs->ringMem;
+    chPrms.fqRingPrms.ringMemSize   = udmaArgs->ringMemSize;
+    chPrms.fqRingPrms.elemCnt       = udmaArgs->ringElemCount;
+
+    /* Open channel for block copy */
+    udmaStatus = Udma_chOpen(drvHandle, chHandle, chType, &chPrms);
+    DebugP_assert(UDMA_SOK == udmaStatus);
+
+    /* Config TX channel */
+    UdmaChTxPrms_init(&txPrms, chType);
+    udmaStatus = Udma_chConfigTx(chHandle, &txPrms);
+    DebugP_assert(UDMA_SOK == udmaStatus);
+
+    /* Config RX channel - which is implicitly paired to TX channel in
+     * block copy mode */
+    UdmaChRxPrms_init(&rxPrms, chType);
+    udmaStatus = Udma_chConfigRx(chHandle, &rxPrms);
+    DebugP_assert(UDMA_SOK == udmaStatus);
+
+    /* Enable channel */
+    udmaStatus = Udma_chEnable(chHandle);
+    DebugP_assert(UDMA_SOK == udmaStatus);
+
+    /* Check if TRPD memory was allocated, assert if NULL */
+    DebugP_assert(trpdMem != NULL);
+
+    /* Do TRPD Init with NULL src dst and 0 length. Fill this later in dmaCopy */
+    CSL_UdmapTR15  *pTr;
+    uint32_t        cqRingNum = Udma_chGetCqRingNum(chHandle);
+
+    /* Make TRPD with TR15 TR type */
+    UdmaUtils_makeTrpdTr15(trpdMem, 1U, cqRingNum);
+
+    /* Setup TR */
+    pTr = UdmaUtils_getTrpdTr15Pointer(trpdMem, 0U);
+    pTr->flags    = CSL_FMK(UDMAP_TR_FLAGS_TYPE, CSL_UDMAP_TR_FLAGS_TYPE_4D_BLOCK_MOVE_REPACKING_INDIRECTION);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_STATIC, 0U);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_EOL, CSL_UDMAP_TR_FLAGS_EOL_MATCH_SOL_EOL);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_EVENT_SIZE, CSL_UDMAP_TR_FLAGS_EVENT_SIZE_COMPLETION);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_TRIGGER0, CSL_UDMAP_TR_FLAGS_TRIGGER_NONE);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_TRIGGER0_TYPE, CSL_UDMAP_TR_FLAGS_TRIGGER_TYPE_ALL);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_TRIGGER1, CSL_UDMAP_TR_FLAGS_TRIGGER_NONE);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_TRIGGER1_TYPE, CSL_UDMAP_TR_FLAGS_TRIGGER_TYPE_ALL);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_CMD_ID, 0x25U);  /* This will come back in TR response */
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_SA_INDIRECT, 0U);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_DA_INDIRECT, 0U);
+    pTr->flags   |= CSL_FMK(UDMAP_TR_FLAGS_EOP, 1U);
+    pTr->icnt0    = 0U;
+    pTr->icnt1    = 1U;
+    pTr->icnt2    = 1U;
+    pTr->icnt3    = 1U;
+    pTr->dim1     = pTr->icnt0;
+    pTr->dim2     = (pTr->icnt0 * pTr->icnt1);
+    pTr->dim3     = (pTr->icnt0 * pTr->icnt1 * pTr->icnt2);
+    pTr->addr     = 0U;
+    pTr->fmtflags = 0x00000000U;    /* Linear addressing, 1 byte per elem */
+    pTr->dicnt0   = 0U;
+    pTr->dicnt1   = 1U;
+    pTr->dicnt2   = 1U;
+    pTr->dicnt3   = 1U;
+    pTr->ddim1    = pTr->dicnt0;
+    pTr->ddim2    = (pTr->dicnt0 * pTr->dicnt1);
+    pTr->ddim3    = (pTr->dicnt0 * pTr->dicnt1 * pTr->dicnt2);
+    pTr->daddr    = 0U;
+
+    /* Perform cache writeback */
+    CacheP_wb(trpdMem, trpdMemSize, CacheP_TYPE_ALLD);
+
+    /* Mapping GPMC local DMA event to Global event for BCDMA trigger*/
+    UdmaUtils_mapLocaltoGlobalEvent(drvHandle,chHandle,
+                                    udmaArgs->localEventID,CSL_INTAGGR_EVT_DETECT_MODE_RISING_EDGE);
+
+    if (UDMA_SOK == udmaStatus)
+    {
+        status = SystemP_SUCCESS;
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+static int32_t GpmcDma_udmaClose(GPMC_DmaHandle handle, void* gpmcDmaArgs)
+{
+    int32_t status = SystemP_SUCCESS;
+    int32_t udmaStatus = UDMA_SOK;
+
+    GpmcDma_UdmaArgs *udmaArgs = (GpmcDma_UdmaArgs *)gpmcDmaArgs;
+
+    Udma_ChHandle chHandle = udmaArgs->chHandle;
+
+    /* Flush any pending request from the free queue */
+    while(1)
+    {
+        uint64_t        pDesc;
+        int32_t tempRetVal = Udma_ringFlushRaw(
+                         Udma_chGetFqRingHandle(chHandle), &pDesc);
+        if(UDMA_ETIMEOUT == tempRetVal)
+        {
+            break;
+        }
+    }
+
+    /* Disable Channel */
+    udmaStatus = Udma_chDisable(chHandle, UDMA_DEFAULT_CH_DISABLE_TIMEOUT);
+    DebugP_assert(UDMA_SOK == udmaStatus);
+
+    /* Close channel */
+    udmaStatus = Udma_chClose(chHandle);
+    DebugP_assert(UDMA_SOK == udmaStatus);
+
+    return status;
+
+}
+
+static int32_t GpmcDma_udmaUpdateSubmitTR(void* gpmcDmaArgs, void* dst, void* src,
+                                            uint16_t icnt[4], int32_t dim[3], uint8_t fifodrain)
+{
+    int32_t status = UDMA_SOK;
+    GpmcDma_UdmaArgs *udmaArgs = (GpmcDma_UdmaArgs *)gpmcDmaArgs;
+    Udma_ChHandle chHandle = udmaArgs->chHandle;
+    uint8_t *trpdMem     = (uint8_t *) udmaArgs->trpdMem;
+    uint32_t trpdMemSize = udmaArgs->trpdMemSize;
+    uint64_t pDesc;
+    uint32_t trRespStatus;
+    uint64_t trpdMemPhy = (uint64_t) Udma_defaultVirtToPhyFxn(trpdMem, 0U, NULL);
+
+    /* Update TRPD */
+    CSL_UdmapTR15  *pTr;
+    pTr = UdmaUtils_getTrpdTr15Pointer(trpdMem, 0U);
+
+    if(fifodrain)
+    {
+        CSL_FINS(pTr->flags,UDMAP_TR_FLAGS_TRIGGER0, CSL_UDMAP_TR_FLAGS_TRIGGER_GLOBAL0);
+        CSL_FINS(pTr->flags,UDMAP_TR_FLAGS_TRIGGER0_TYPE, CSL_UDMAP_TR_FLAGS_TRIGGER_TYPE_ICNT1_DEC);
+    }
+
+    pTr->icnt0 = icnt[0];
+    pTr->icnt1 = icnt[1];
+    pTr->icnt2 = icnt[2];
+    pTr->icnt3 = icnt[3];
+
+    pTr->dim1  = dim[0];
+    pTr->dim2  = dim[1];
+    pTr->dim3  = dim[2];
+
+    pTr->dicnt0 = pTr->icnt0;
+    pTr->dicnt1 = pTr->icnt1;
+    pTr->dicnt2 = pTr->icnt2;
+    pTr->dicnt3 = pTr->icnt3;
+
+    pTr->ddim1    = (int32_t)pTr->dicnt0;
+    pTr->ddim2    = (int32_t)pTr->dicnt0 * (int32_t)pTr->dicnt1;
+    pTr->ddim3    = (int32_t)pTr->dicnt0 * (int32_t)pTr->dicnt1 * (int32_t)pTr->dicnt2;
+
+    pTr->addr     = (uint64_t) Udma_defaultVirtToPhyFxn(src, 0U, NULL);
+    pTr->daddr    = (uint64_t) Udma_defaultVirtToPhyFxn(dst, 0U, NULL);
+
+    uint32_t length = pTr->icnt0 * pTr->icnt1 * pTr->icnt2 * pTr->icnt3;
+
+    /* Perform cache writeback */
+    CacheP_wb(trpdMem, trpdMemSize, CacheP_TYPE_ALLD);
+    CacheP_wbInv(dst, length, CacheP_TYPE_ALLD);
+
+    /* Submit TRPD to channel */
+    status = Udma_ringQueueRaw(Udma_chGetFqRingHandle(chHandle), trpdMemPhy);
+
+    /* Wait for return descriptor in completion ring - this marks transfer completion */
+    while(1)
+    {
+        status = Udma_ringDequeueRaw(Udma_chGetCqRingHandle(chHandle), &pDesc);
+        if(UDMA_SOK == status)
+        {
+            /* Check TR response status */
+            CacheP_inv(trpdMem, trpdMemSize, CacheP_TYPE_ALLD);
+            trRespStatus = UdmaUtils_getTrpdTr15Response(trpdMem, 1U, 0U);
+            if(trRespStatus != CSL_UDMAP_TR_RESPONSE_STATUS_COMPLETE)
+            {
+                DebugP_log("TR Response failed for transfer : SRC = 0x%X, DST = 0x%X, SIZE = %u\r\n", (uint32_t)src, (uint32_t)dst, length);
+                DebugP_assert(FALSE);
+            }
+            break;
+        }
+    }
+
+    return status;
+}
+
+static int32_t GpmcDma_udmaCopy(void* gpmcDmaArgs, void* dst, void* src, uint32_t length, uint8_t fifoDrain)
+{
+    int32_t status = SystemP_SUCCESS;
+    int32_t udmaStatus = UDMA_SOK;
+    uint32_t quotient = 0U;
+    uint32_t rmainder = 0U;
+    uint16_t icnt[4] = { 0U, 0U, 0U, 0U };
+    int32_t dim[3] = {0};
+
+    if (length < GPMC_DMA_UDMA_MAX_L0_XFER_SIZE)
+    {
+        if(fifoDrain == TRUE)
+        {
+            icnt[0] = (uint16_t)64;
+            icnt[1] = (uint16_t)length/64;
+
+        }
+        else
+        {
+            icnt[0] = (uint16_t)length;
+            icnt[1] = (uint16_t)1U;
+        }
+
+    }
+    else
+    {
+        icnt[0] = (uint16_t)GPMC_DMA_UDMA_XFER_SIZE;
+        quotient = length / GPMC_DMA_UDMA_XFER_SIZE;
+        rmainder = length % GPMC_DMA_UDMA_XFER_SIZE;
+        icnt[1] = (uint16_t)(quotient);
+    }
+
+    icnt[2] = (uint16_t)1U;
+    icnt[3] = (uint16_t)1U;
+
+    if(fifoDrain == TRUE)
+    {
+        dim[0]     = (int32_t)0;
+        dim[1]     = (int32_t)icnt[0] * (int32_t)icnt[1];
+        dim[2]     = (int32_t)icnt[0] * (int32_t)icnt[1] * (int32_t)icnt[2];
+    }
+    else
+    {
+        dim[0]     = (int32_t)icnt[0];
+        dim[1]     = (int32_t)icnt[0] * (int32_t)icnt[1];
+        dim[2]     = (int32_t)icnt[0] * (int32_t)icnt[1] * (int32_t)icnt[2];
+    }
+
+    udmaStatus = GpmcDma_udmaUpdateSubmitTR(gpmcDmaArgs, dst, src, icnt, dim, fifoDrain);
+
+    if(rmainder != 0)
+    {
+        /* residual data */
+        icnt[0] = (uint16_t)rmainder;
+        icnt[1] = (uint16_t)1U;
+        icnt[2] = (uint16_t)1U;
+        icnt[3] = (uint16_t)1U;
+
+        udmaStatus = GpmcDma_udmaUpdateSubmitTR(gpmcDmaArgs,
+                    ((uint8_t *)dst+(length-rmainder)), ((uint8_t *)src+(length-rmainder)), icnt, dim, fifoDrain);
+    }
+
+    if(udmaStatus == UDMA_SOK)
+    {
+        status = SystemP_SUCCESS;
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/source/drivers/gpmc/v0/dma/udma/gpmc_dma_udma.h b/source/drivers/gpmc/v0/dma/udma/gpmc_dma_udma.h
new file mode 100644
index 0000000000..e90f6df8e1
--- /dev/null
+++ b/source/drivers/gpmc/v0/dma/udma/gpmc_dma_udma.h
@@ -0,0 +1,73 @@
+/*
+ *  Copyright (C) 2023 Texas Instruments Incorporated
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ *    Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the
+ *    distribution.
+ *
+ *    Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef GPMC_UDMA_H_
+#define GPMC_UDMA_H_
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define GPMC_DMA_UDMA_MAX_L0_XFER_SIZE (65536U)
+#define GPMC_DMA_UDMA_XFER_SIZE        (64512U)
+
+typedef struct GpmcDma_UdmaArgs_s
+{
+    void            *drvHandle;
+    /**< UDMA driver handle */
+    void            *chHandle;
+    /**< UDMA channel handle */
+    void            *trpdMem;
+    /**< UDMA TR PD memory pointers */
+    uint32_t        trpdMemSize;
+    /**< Size of TR PD memory */
+    void            *ringMem;
+    /**< UDMA Ring memory pointers */
+    uint32_t        ringMemSize;
+    /**< Size of Ring Memory */
+    uint32_t        ringElemCount;
+    /**< Ring Element Count */
+    uint32_t        localEventID;
+    /**< local Event ID for BCDMA trigger */
+
+} GpmcDma_UdmaArgs;
+
+extern GPMC_DmaFxns gGpmcDmaUdmaFxns;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GPMC_UDMA_H_ */
\ No newline at end of file
diff --git a/source/drivers/gpmc/v0/gpmc.h b/source/drivers/gpmc/v0/gpmc.h
new file mode 100644
index 0000000000..14ba864dad
--- /dev/null
+++ b/source/drivers/gpmc/v0/gpmc.h
@@ -0,0 +1,1227 @@
+/*
+ *  Copyright (C) 2023 Texas Instruments Incorporated
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ *    Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the
+ *    distribution.
+ *
+ *    Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *  \file v0/gpmc.h
+ *
+ *  \brief GPMC Driver API/interface file.
+ */
+
+/**
+ *  \defgroup DRV_GPMC_MODULE APIs for GPMC
+ *  \ingroup DRV_MODULE
+ *
+ *  This file containing the GPMC API.
+ *
+ *  The GPMC header file should be included in an application as follows:
+ *  \code
+ *  #include <drivers/gpmc.h>
+ *  \endcode
+ *
+ *  @{
+ */
+
+#ifndef _GPMC__H_
+#define _GPMC__H_
+
+
+/* ========================================================================== */
+/*                             Include Files                                  */
+/* ========================================================================== */
+
+#include <stdint.h>
+#include <kernel/dpl/SystemP.h>
+#include <kernel/dpl/SemaphoreP.h>
+#include <kernel/dpl/HwiP.h>
+#include <drivers/hw_include/csl_types.h>
+#include <drivers/hw_include/cslr_gpmc.h>
+#include <kernel/dpl/CacheP.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ========================================================================== */
+/*                           Macros & Typedefs                                */
+/* ========================================================================== */
+/**
+*   GPMC CHIP select
+*
+*   Macros which can be used as to select CHIP select instance for GPMC.
+*
+* @{
+*/
+#define GPMC_CHIP_SELECT_CS0                            (0U)
+#define GPMC_CHIP_SELECT_CS1                            (1U)
+#define GPMC_CHIP_SELECT_CS2                            (2U)
+#define GPMC_CHIP_SELECT_CS3                            (3U)
+/** @} */
+
+/**
+*   GPMC Interupt status flags
+*
+*   Macros which can be used as 'interupt' parameter to GPMC_interuptStatusGet,
+*   GPMC_interuptStatusClear APIs.
+*
+* @{
+*/
+#define GPMC_FIFOEVENT_STATUS                         (0U)
+#define GPMC_TERMINALCOUNT_STATUS                     (1U)
+#define GPMC_WAIT0EDGEDETECTION_STATUS                (2U)
+#define GPMC_WAIT1EDGEDETECTION_STATUS                (3U)
+/** @} */
+
+/**
+*   GPMC Interupt Flags
+*
+*  Macros which can be used as 'interupt' parameter to GPMC_enableInterupt,
+*  GPMC_disableInterupt APIs.
+*
+* @{
+*/
+#define GPMC_FIFOEVENT_INT                            (0U)
+#define GPMC_TERMINALCOUNT_INT                        (1U)
+#define GPMC_WAIT0EDGEDETECTION_INT                   (2U)
+#define GPMC_WAIT1EDGEDETECTION_INT                   (3U)
+/** @} */
+
+
+/**
+*   GPMC Interupt Flags
+*
+* Macros which can be used as 'mode' parameter to GPMC_prefetchPostWriteConfigEnable API.
+*
+* @{
+*/
+#define GPMC_PREFETCH_ACCESSMODE_READ                 (0U)
+#define GPMC_PREFETCH_ACCESSMODE_WRITE                (1U)
+/** @} */
+
+
+/**
+*   GPMC ECC algorithm
+*
+* Macros which can be used to set GPMC ECC engine algorithm.
+*
+* @{
+*/
+#define GPMC_ECC_ALGORITHM_HAMMINGCODE                (0U)
+#define GPMC_ECC_ALGORITHM_BCH                        (1U)
+/** @} */
+
+/**
+*   GPMC ECC error correvel level.
+*
+* Macros which can be used to set GPMC ECC engine error correction level.
+*
+* @{
+*/
+#define GPMC_ECC_BCH_ERRCORRCAP_UPTO_4BITS            (0U)
+#define GPMC_ECC_BCH_ERRCORRCAP_UPTO_8BITS            (1U)
+#define GPMC_ECC_BCH_ERRCORRCAP_UPTO_16BITS           (2U)
+/** @} */
+
+
+/**
+*   GPMC ECC Result Register
+*
+* Macros which can be used to select ECC result register for GPMC ECC engine.
+*
+* @{
+*/
+#define GPMC_ECCPOINTER_RESULT_1                      (1U)
+#define GPMC_ECCPOINTER_RESULT_2                      (2U)
+#define GPMC_ECCPOINTER_RESULT_3                      (3U)
+#define GPMC_ECCPOINTER_RESULT_4                      (4U)
+#define GPMC_ECCPOINTER_RESULT_5                      (5U)
+#define GPMC_ECCPOINTER_RESULT_6                      (6U)
+#define GPMC_ECCPOINTER_RESULT_7                      (7U)
+#define GPMC_ECCPOINTER_RESULT_8                      (8U)
+#define GPMC_ECCPOINTER_RESULT_9                      (9U)
+/** @} */
+
+/**
+*   GPMC ECC Size Config
+*
+* Macros which can be used to set length of used and unsued bytes in the ECC value.
+* @{
+*/
+#define GPMC_ECC_SIZE_0                               (0U)
+#define GPMC_ECC_SIZE_1                               (1U)
+/** @} */
+
+/**
+*   GPMC ECC Result Register Size
+*
+* Macros which can be used to set ECC size for ECC result register.
+* @{
+*/
+#define GPMC_ECC_RESULT_1                             (1U)
+#define GPMC_ECC_RESULT_2                             (2U)
+#define GPMC_ECC_RESULT_3                             (3U)
+#define GPMC_ECC_RESULT_4                             (4U)
+#define GPMC_ECC_RESULT_5                             (5U)
+#define GPMC_ECC_RESULT_6                             (6U)
+#define GPMC_ECC_RESULT_7                             (7U)
+#define GPMC_ECC_RESULT_8                             (8U)
+#define GPMC_ECC_RESULT_9                             (9U)
+/** @} */
+
+/**
+*   GPMC BCH RESULT
+*
+* Macros which can be used to get BCH syndrome polynomial in GPMC_eccBchResultGet API.
+* @{
+*/
+#define GPMC_BCH_RESULT0                             (0U)
+#define GPMC_BCH_RESULT1                             (1U)
+#define GPMC_BCH_RESULT2                             (2U)
+#define GPMC_BCH_RESULT3                             (3U)
+#define GPMC_BCH_RESULT4                             (4U)
+#define GPMC_BCH_RESULT5                             (5U)
+#define GPMC_BCH_RESULT6                             (6U)
+/** @} */
+
+/**
+*   GPMC CHIP Select SIZE
+*
+* Macros which can be used to set chip select address size.
+* @{
+*/
+#define GPMC_CS_MASK_ADDR_SIZE_256MB                            (0x00U)
+#define GPMC_CS_MASK_ADDR_SIZE_128MB                            (0x08U)
+#define GPMC_CS_MASK_ADDR_SIZE_64MB                             (0x0cU)
+#define GPMC_CS_MASK_ADDR_SIZE_32MB                             (0x0eU)
+#define GPMC_CS_MASK_ADDR_SIZE_16MB                             (0x0fU)
+/** @} */
+
+/**
+ * \brief  This macro used to make the conf value which is used to configure the
+ *         CS signal timing configuration.
+ *
+ * \param  CSWrOffTime    CS# de-assertion time from start cycle time for write
+ *                        accesses in GPMC_FCLK cycles.
+ *
+ * \param  CSRdOffTime    CS# de-assertion time from start cycle time for read
+ *                        accesses in GPMC_FCLK cycles
+ *
+ * \param  CSExtDelayFlag Flag to indicate whether to add half GPMC_FCLK delay
+ *                        to CS or not.
+ *                        This can take one of the following values :
+ *                        CSL_GPMC_CONFIG2_CSEXTRADELAY_DELAYED : CS# Timing control
+ *                                                                 signal is delayed of
+ *                                                                 half GPMC_FCLK cycle.
+ *                        CSL_GPMC_CONFIG2_CSEXTRADELAY_NOTDELAYED : CS# Timing control
+ *                                                                    signal is not delayed.
+ *
+ * \param  CSOnTime       CS# assertion time from start cycle time in GPMC_FCLK
+ *                        cycles.
+ *
+ */
+#define GPMC_CS_TIMING_CONFIG(CSWrOffTime, CSRdOffTime, CSExtDelayFlag, \
+                              CSOnTime)                                 \
+    ((uint32_t) (((CSWrOffTime) << CSL_GPMC_CONFIG2_CSWROFFTIME_SHIFT)    \
+                 & CSL_GPMC_CONFIG2_CSWROFFTIME_MASK) |                   \
+     (((CSRdOffTime) << CSL_GPMC_CONFIG2_CSRDOFFTIME_SHIFT)               \
+      & CSL_GPMC_CONFIG2_CSRDOFFTIME_MASK) |                              \
+     (((CSExtDelayFlag) << CSL_GPMC_CONFIG2_CSEXTRADELAY_SHIFT)           \
+      & CSL_GPMC_CONFIG2_CSEXTRADELAY_MASK) |                             \
+     (((CSOnTime) << CSL_GPMC_CONFIG2_CSONTIME_SHIFT)                     \
+      & CSL_GPMC_CONFIG2_CSONTIME_MASK))
+
+
+/**
+ * \brief  This macro used to make the conf value which is used to configure the
+ *         ADV# signal timing configuration.
+ *
+ * \param  ADVAADMuxWrOffTime    ADV# de-assertion time in GPMC_FCLK cycles for
+ *                               first address phase when using the AAD-Mux
+ *                               prorocol.
+ *
+ * \param  ADVAADMuxRdOffTime    ADV# de-assertion time in GPMC_FCLK cycles for
+ *                               first address phase when using the AAD-Mux
+ *                               prorocol.
+ *
+ * \param  ADVWrOffTime          ADV# de-assertion time in GPMC_FCLK cycles from
+ *                               start cycle time for write accesses
+ *
+ * \param  ADVRdOffTime          ADV# de-assertion time in GPMC_FCLK cycles from
+ *                               start cycle time for write accesses
+ *
+ * \param  ADVExtDelayFlag       Flag to indicate whether to add half GPMC_FCLK
+ *                               delay to ADV or not.
+ *                               This can take one of the following values :
+ *                               CSL_GPMC_CONFIG3_ADVEXTRADELAY_DELAYED : ADV# Timing control
+ *                                                                        signal is delayed of
+ *                                                                        half GPMC_FCLK cycle.
+ *                               CSL_GPMC_CONFIG3_ADVEXTRADELAY_NOTDELAYED : ADV# Timing control
+ *                                                                          signal is not delayed.
+ *
+ * \param  ADVAADMuxOnTime       ADV# assertion time in GPMC_FCLK cycles for
+ *                               first address phase when using the
+ *                               AAD-Multiplexed protocol.
+ *
+ * \param  ADVOnTime             ADV# assertion time from start cycle time in
+ *                               GPMC_FCLK cycles.
+ *
+ */
+#define GPMC_ADV_TIMING_CONFIG(ADVAADMuxWrOffTime, ADVAADMuxRdOffTime,      \
+                               ADVWrOffTime, ADVRdOffTime, ADVExtDelayFlag, \
+                               ADVAADMuxOnTime,                             \
+                               ADVOnTime)                                   \
+    ((uint32_t) (((ADVAADMuxWrOffTime) <<                                   \
+                  CSL_GPMC_CONFIG3_ADVAADMUXWROFFTIME_SHIFT) &                \
+                 CSL_GPMC_CONFIG3_ADVAADMUXWROFFTIME_MASK) |                  \
+     (((ADVAADMuxRdOffTime) << CSL_GPMC_CONFIG3_ADVAADMUXRDOFFTIME_SHIFT) &   \
+      CSL_GPMC_CONFIG3_ADVAADMUXRDOFFTIME_MASK) |                             \
+     (((ADVWrOffTime) << CSL_GPMC_CONFIG3_ADVWROFFTIME_SHIFT) &               \
+      CSL_GPMC_CONFIG3_ADVWROFFTIME_MASK) |                                   \
+     (((ADVRdOffTime) << CSL_GPMC_CONFIG3_ADVRDOFFTIME_SHIFT) &               \
+      CSL_GPMC_CONFIG3_ADVRDOFFTIME_MASK) |                                   \
+     (((ADVExtDelayFlag) << CSL_GPMC_CONFIG3_ADVEXTRADELAY_SHIFT) &           \
+      CSL_GPMC_CONFIG3_ADVEXTRADELAY_MASK) |                                  \
+     (((ADVAADMuxOnTime) << CSL_GPMC_CONFIG3_ADVAADMUXONTIME_SHIFT) &         \
+      CSL_GPMC_CONFIG3_ADVAADMUXONTIME_MASK) |                                \
+     (((ADVOnTime) << CSL_GPMC_CONFIG3_ADVONTIME_SHIFT) &                     \
+      CSL_GPMC_CONFIG3_ADVONTIME_MASK))
+
+
+/**
+ * \brief  This macro used to make the conf value which is used to configure the
+ *         WE# and OE# signal timing configuration.
+ *
+ * \param  WEOffTime             WE# de-assertion time in GPMC_FCLK cycles from
+ *                               start cycle time.
+ *
+ * \param  WEExtDelayFlag        Flag to indicate whether to add half GPMC_FCLK
+ *                               delay to WE or not.
+ *                               This can take one of the following values :
+ *                               CSL_GPMC_CONFIG4_WEEXTRADELAY_DELAYED : WE# Timing control
+ *                                                                       signal is delayed of
+ *                                                                       half GPMC_FCLK cycle.
+ *                               CSL_GPMC_CONFIG4_WEEXTRADELAY_NOTDELAYED : WE# Timing control
+ *                                                                          signal is not delayed.
+ * \param  WEOnTime              WE# assertion time in GPMC_FCLK cycles from
+ *                               start cycle time.
+ *
+ * \param  OEAADMuxOffTime       OE# de-assertion time in GPMC_FCLK cycles for
+ *                               first address phase when using the AAD-Mux
+ *                               prorocol.
+ *
+ * \param  OEOffTime             OE# de-assertion time in GPMC_FCLK cycles from
+ *                               start cycle time.
+ *
+ * \param  OEExtDelayFlag        Flag to indicate whether to add half GPMC_FCLK
+ *                               delay to OE or not.
+ *                               This can take one of the following values :
+ *                               CSL_GPMC_CONFIG4_OEEXTRADELAY_DELAYED : OE# Timing control
+ *                                                                      signal is delayed of
+ *                                                                      half GPMC_FCLK cycle.
+ *                               CSL_GPMC_CONFIG4_OEEXTRADELAY_NOTDELAYED : OE# Timing control
+ *                                                                          signal is not delayed.
+ *
+ * \param  OEAADMuxOnTime        OE# assertion time in GPMC_FCLK cycles for
+ *                               first address phase when using the AAD-Mux
+ *                               prorocol.
+ *
+ * \param  OEOnTime              OE# assertion time in GPMC_FCLK cycles from
+ *                               start cycle time.
+ *
+ *
+ */
+#define GPMC_WE_OE_TIMING_CONFIG(WEOffTime, WEExtDelayFlag, WEOnTime,           \
+                                 OEAADMuxOffTime, OEOffTime, OEExtDelayFlag,    \
+                                 OEAADMuxOnTime, OEOnTime)                      \
+    ((uint32_t) (((WEOffTime) <<                                                \
+                  CSL_GPMC_CONFIG4_WEOFFTIME_SHIFT) &                             \
+                 CSL_GPMC_CONFIG4_WEOFFTIME_MASK) |                               \
+     (((WEExtDelayFlag) <<                                                      \
+       CSL_GPMC_CONFIG4_WEEXTRADELAY_SHIFT) & CSL_GPMC_CONFIG4_WEEXTRADELAY_MASK) | \
+     (((WEOnTime) <<                                                            \
+       CSL_GPMC_CONFIG4_WEONTIME_SHIFT) & CSL_GPMC_CONFIG4_WEONTIME_MASK) |         \
+     (((OEAADMuxOffTime) <<                                                     \
+       CSL_GPMC_CONFIG4_OEAADMUXOFFTIME_SHIFT) &                                  \
+      CSL_GPMC_CONFIG4_OEAADMUXOFFTIME_MASK) |                                    \
+     (((OEOffTime) <<                                                           \
+       CSL_GPMC_CONFIG4_OEOFFTIME_SHIFT) & CSL_GPMC_CONFIG4_OEOFFTIME_MASK) |       \
+     (((OEExtDelayFlag) <<                                                      \
+       CSL_GPMC_CONFIG4_OEEXTRADELAY_SHIFT) & CSL_GPMC_CONFIG4_OEEXTRADELAY_MASK) | \
+     (((OEAADMuxOnTime) <<                                                      \
+       CSL_GPMC_CONFIG4_OEAADMUXONTIME_SHIFT) &                                   \
+      CSL_GPMC_CONFIG4_OEAADMUXONTIME_MASK) |                                     \
+     (((OEOnTime) <<                                                            \
+       CSL_GPMC_CONFIG4_OEONTIME_SHIFT) & CSL_GPMC_CONFIG4_OEONTIME_MASK))
+
+
+
+/**
+ * \brief  This macro used to make the conf value which is used to configure the
+ *         read access and cycle time timing configuration.
+ *
+ * \param  rdCycleTime           Total read cycle time in GPMC_FCLK cycles.
+ *
+ * \param  wrCycleTime           Total write cycle time in GPMC_FCLK cycles.
+ *
+ * \param  rdAccessTime          Read access time (Delay between start cycle
+ *                               time and first data valid) in GPMC_FCLK cycles.
+ *
+ * \param  pageBurstAccessTime   Page burest access time (Delay between
+ *                               successive words in a multiple access)in
+ *                               GPMC_FCLK cycles.
+ *
+ */
+#define GPMC_RDACCESS_CYCLETIME_TIMING_CONFIG(rdCycleTime, wrCycleTime,         \
+                                              rdAccessTime,                     \
+                                              pageBurstAccessTime)              \
+    ((uint32_t) (((rdCycleTime) <<                                              \
+                  CSL_GPMC_CONFIG5_RDCYCLETIME_SHIFT) &                           \
+                 CSL_GPMC_CONFIG5_RDCYCLETIME_MASK) |                             \
+     (((wrCycleTime) <<                                                         \
+       CSL_GPMC_CONFIG5_WRCYCLETIME_SHIFT) & CSL_GPMC_CONFIG5_WRCYCLETIME_MASK) |   \
+     (((rdAccessTime) <<                                                        \
+       CSL_GPMC_CONFIG5_RDACCESSTIME_SHIFT) & CSL_GPMC_CONFIG5_RDACCESSTIME_MASK) | \
+     (((pageBurstAccessTime) <<                                                 \
+       CSL_GPMC_CONFIG5_PAGEBURSTACCESSTIME_SHIFT) &                              \
+      CSL_GPMC_CONFIG5_PAGEBURSTACCESSTIME_MASK))
+
+
+
+/**
+ * \brief  This macro used to make the conf value which is used to configure the
+ *         cycle to cycle and bus turn around time timing configuration.
+ *
+ * \param  cycle2CycleDelay       Cycle to cycle delay (Chip select high pulse
+ *                                delay between two successive accesses)in
+ *                                GPMC_FCLK cycles.
+ *
+ * \param  cycle2CycleDelaySameCSCfg Specified whether to add the cycle to cycle
+ *                                delay between two successive accesses or not
+ *                                (to the same chip-select).
+ *                                This can take one of the following values :
+ *                                CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_C2CDELAY : To add the delay.
+ *                                CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_NOC2CDELAY : Don't add the delay.
+ *
+ * \param  cycle2CycleDelayDiffCSCfg Specified whether to add the cycle to cycle
+ *                                delay between two successive accesses or not
+ *                                (to the diffrent chip-select).
+ *                                This can take one of the following values :
+ *                                CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_C2CDELAY : To add the delay.
+ *                                CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_NOC2CDELAY : Don't add the delay.
+ *
+ * \param  busTAtime             Bus turn aroung time between two successive
+ *                               accesses to the same chip-select
+ *                               (read to write) or to a diff chip-select in
+ *                               GPMC_FCLK cycles.
+ *
+ *
+ */
+#define GPMC_CYCLE2CYCLE_BUSTURNAROUND_TIMING_CONFIG(cycle2CycleDelay,          \
+                                                     cycle2CycleDelaySameCSCfg, \
+                                                     cycle2CycleDelayDiffCSCfg, \
+                                                     busTAtime)                 \
+    ((uint32_t) (((cycle2CycleDelay) <<                                         \
+                  CSL_GPMC_CONFIG6_CYCLE2CYCLEDELAY_SHIFT) &                      \
+                 CSL_GPMC_CONFIG6_CYCLE2CYCLEDELAY_MASK) |                        \
+     (((cycle2CycleDelaySameCSCfg) <<                                           \
+       CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_SHIFT) &                              \
+      CSL_GPMC_CONFIG6_CYCLE2CYCLESAMECSEN_MASK) |                                \
+     (((cycle2CycleDelayDiffCSCfg) <<                                           \
+       CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_SHIFT) &                              \
+      CSL_GPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN_MASK) |                                \
+     (((busTAtime) <<                                                           \
+       CSL_GPMC_CONFIG6_BUSTURNAROUND_SHIFT) & CSL_GPMC_CONFIG6_BUSTURNAROUND_MASK))
+
+
+
+/**
+*   GPMC NAND Specific Timing Parameters
+*
+* Nand flash specific GPMC timing parameters. These are used to
+* GPMC CONFIG registers.
+*
+* @{
+*/
+/** \brief Chip select on time  (FCLK periods) */
+#define GPMC_NAND_CS_ON_TIME                0U
+/** \brief Write enable on time (FCLK periods) */
+#define GPMC_NAND_WE_ON_TIME                0U
+/** \brief Address valid on time (FCLK periods) */
+#define GPMC_NAND_ADV_ON_TIME               0U
+/** \brief Chip select off time for write (FCLK periods) */
+#define GPMC_NAND_CS_WR_OFF_TIME            6U
+/** \brief Write cycle time (FCLK periods) */
+#define GPMC_NAND_WR_CYCLE_TIME             6U
+/** \brief Address valid off time for write (FCLK periods) */
+#define GPMC_NAND_ADV_WR_OFF_TIME           4U
+/** \brief Chip select off time for read (FCLK periods) */
+#define GPMC_NAND_CS_RD_OFF_TIME            6U
+/** \brief Read cycle time (FCLK periods) */
+#define GPMC_NAND_RD_CYCLE_TIME             6U
+/** \brief Address valid on time when using AAD- Muxed protocol. (FCLK periods) */
+#define GPMC_NAND_ADV_AADMUX_ON_TIME        0U
+/** \brief Address valid on time for read when using AAD- Muxed protocol. (FCLK periods) */
+#define GPMC_NAND_ADV_AADMUX_RD_OFF_TIME    0U
+/** \brief Address valid on time for write when using AAD- Muxed protocol. (FCLK periods) */
+#define GPMC_NAND_ADV_AADMUX_WR_OFF_TIME    0U
+/** \brief Delay between successive words in a multiple access. (FCLK periods) */
+#define GPMC_NAND_PAGEBURST_ACCESS_TIME     0U
+/** \brief Output enable on time (FCLK periods) */
+#define GPMC_NAND_OE_ON_TIME                1U
+/** \brief Output enable off time (FCLK periods) */
+#define GPMC_NAND_OE_OFF_TIME               4U
+/** \brief Output enable assertion time for the first address phase in an AAD-muxed protocol. (FCLK periods) */
+#define GPMC_NAND_OE_AADMUX_ON_TIME         0U
+/** \brief Output enable deassertion time for the first address phase in an AAD-muxed protocol. (FCLK periods) */
+#define GPMC_NAND_OE_AADMUX_OFF_TIME        0U
+/** \brief Address valid off time for read (FCLK periods) */
+#define GPMC_NAND_ADV_RD_OFF_TIME           4U
+/** \brief Write enable off time (FCLK periods) */
+#define GPMC_NAND_WE_OFF_TIME               3U
+/** \brief Read access time (FCLK periods) */
+#define GPMC_NAND_RD_ACCESS_TIME            4U
+/** \brief CS high pulse delay (FCLK periods) */
+#define GPMC_NAND_C2C_DELAY                 0U
+/** \brief First data write cycle (FCLK) */
+#define GPMC_NAND_ADMUX_DATA_VALID          0U
+/** \brief Write access time (FCLK periods) */
+#define GPMC_NAND_WR_ACCESS_TIME            6U
+/** \brief Burst turnaround latency (FCLK periods) */
+#define GPMC_NAND_BRST_TAROUND_TIME         0U
+/** @} */
+
+/** \brief size in bytes*/
+#define GPMC_DMA_COPY_LOWER_LIMIT                   (512U)
+/** \brief GPMC CHIP select base address shift value. */
+#define GPMC_CS_BASE_ADDR_SHIFT                      (24U)
+/** \brief GPMC ECC Wrap mode for ECC value computation. */
+#define GPMC_ECC_WRAP_MODE1                          (1)
+/** \brief Invalid value for params initialisation. */
+#define GPMC_CMD_INVALID                             (0xFFFFFFFFU)
+
+/** \brief A handle that is returned from a #GPMC_open() call */
+typedef void* GPMC_Handle;
+
+/* ========================================================================== */
+/*                         Structure Declarations                             */
+/* ========================================================================== */
+/**
+ *  \brief GPMC ECC engine algoritms.
+ *
+ *
+ */
+typedef enum GPMC_v1_nandEccAlgo_s
+{
+    GPMC_NAND_ECC_ALGO_NONE  = 0x00U,
+    GPMC_NAND_ECC_ALGO_HAMMING_1BIT,
+    GPMC_NAND_ECC_ALGO_BCH_4BIT,
+    GPMC_NAND_ECC_ALGO_BCH_8BIT,
+    GPMC_NAND_ECC_ALGO_BCH_16BIT
+
+} GPMC_nandEccAlgo;
+
+/**
+ *  \brief GPMC driver operating modes.
+ *
+ *
+ */
+typedef enum GPMC_OperatingMode_s {
+
+    GPMC_OPERATING_MODE_BLOCKING = 0,
+    /**< Interupt based blocking mode */
+    GPMC_OPERATING_MODE_CALLBACK,
+    /**< Interupt based callback mode*/
+    GPMC_OPERATING_MODE_POLLING
+    /**< Non interupt base blocking mode*/
+
+} GPMC_OperatingMode;
+
+/**
+ *  \brief GPMC data transfer modes.
+ *
+ *
+ */
+typedef enum GPMC_TransferMode_s {
+
+    GPMC_TRANSFER_MODE_BLOCKING = 0,
+    /**<
+    *  GPMC driver transaction blocks execution. This mode can only be used
+    *  when called within a Task context and is interrupt based.
+    */
+    GPMC_TRANSFER_MODE_CALLBACK,
+    /**<
+    *  GPMC driver transaction does not block code execution and will call a
+    *  callback function. This mode can be used in a Task, Swi, or Hwi context.
+    */
+} GPMC_TransferMode;
+
+/**
+ * \brief Type of the GPMC transaction for read and write.
+ *
+ */
+typedef enum GPMC_TransactionType_e {
+    GPMC_TRANSACTION_TYPE_READ = 0,
+    /**< Read transaction */
+    GPMC_TRANSACTION_TYPE_WRITE,
+    /**< Write transaction */
+    GPMC_TRANSACTION_TYPE_READ_CMDREG,
+    /**< Read transaction with command register */
+    GPMC_TRANSACTION_TYPE_WRITE_CMDREG
+    /**< Write transaction with command register */
+} GPMC_TransactionType;
+
+/**
+ * \brief  Transaction status codes that are set by the GPMC driver.
+ *
+ */
+typedef enum GPMC_TransactionStatus_s {
+    GPMC_TRANSFER_COMPLETED = 0,
+    GPMC_TRANSFER_STARTED,
+    GPMC_TRANSFER_CANCELED,
+    GPMC_TRANSFER_FAILED,
+    GPMC_TRANSFER_CSN_DEASSERT,
+    GPMC_TRANSFER_TIMEOUT,
+} GPMC_TransactionStatus;
+
+
+/**
+ *  \brief Data structure to set NAND command parameters.
+ *
+ */
+typedef struct
+{
+    uint32_t cmdCycle1;
+    /**< NAND command cycle 1. */
+    uint32_t cmdCycle2;
+    /**< NAND command cycle 2. */
+    uint32_t rowAddress;
+    /**< NAND row address */
+    uint32_t numRowAddrCycles;
+    /**< Number of row address cycles.  */
+    uint32_t colAddress;
+    /**< NAND column address. */
+    uint32_t numColAddrCycles;
+    /**< Number of column address cycles. */
+    uint32_t waitTimeout;
+    /**< Wait timeout for the command. */
+    uint32_t checkReadypin;
+    /**< Check WAIT PIN status or WAIT PIN interupt status. */
+} GPMC_nandCmdParams;
+
+
+/**
+ *  \brief Data structure to set transaction type parameters.
+ *
+ */
+typedef struct GPMC_Transaction_s {
+
+	GPMC_TransactionType    transType;
+    /**< Transaction type : GPMC_TransactionType */
+    uint32_t                count;
+    /**< Number of bytes for this transaction */
+    void                    *Buf;
+    /**< void * to a buffer to receive/send data */
+    void                    *arg;
+    /**< Argument to be passed to the callback function */
+    uint32_t                transferTimeout;
+    /**< Timeout of the specific transfer */
+    GPMC_TransactionStatus status;
+    /**< Status code set by GPMC read or write transaction */
+} GPMC_Transaction;
+
+/**
+ *  \brief      The definition of a callback function used by the GPMC driver
+ *              when used in GPMC_OPERATING_MODE_CALLBACK mode.
+ *
+ *  \param      GPMC_Handle          GPMC_Handle
+ *  \param      GPMC_Transaction*    GPMC_Transaction*
+ */
+typedef void (*GPMC_CallbackFxn)(GPMC_Handle handle,
+                                 GPMC_Transaction * transaction);
+
+
+/**
+ *  \brief  GPMC driver instance parameters.
+ *
+ *  GPMC Parameters are used to with the GPMC_open() call. Default values for
+ *  these parameters are set using GPMC_Params_init().
+ *
+ *  If NULL is passed for the parameters, GPMC_open() uses default parameters.
+ *
+ */
+typedef struct GPMC_Params_s
+{
+    /** Index of Channel used by GPMC DMA Driver. This index will be set by SysCfg according to the DMA driver chosen.
+     * The GPMC driver uses this index to do an GPMC_dmaOpen() inside the GPMC_open() if the DMA mode is enabled.
+     */
+    int32_t                 gpmcDmaChIndex;
+    /**< device type, NAND or NOR like */
+    uint32_t                devType;
+    /**< device size, 8-bit, 16-bit or 32-bit bus width */
+    uint32_t                devSize;
+    /**< Signals timing latencies scalar factor */
+    uint32_t                chipSel;
+    /**< Enable GPMC interrupt. */
+    uint32_t                intrEnable;
+
+    uint32_t                dmaEnable;
+    /**< Enable GPMC DMA mode. */
+    GPMC_TransferMode       transferMode;
+    /**< Polling, blocking or callback mode . Refer \ref GPMC_TransferMode */
+    GPMC_CallbackFxn        transferCallBckFunc;
+    /**< External Callback function pointer*/
+} GPMC_Params;
+
+/**
+ *  \brief GPMC Address Region
+ *
+ *  GPMC Address Region will be a part of the attributes. It is used while using DMA Copy
+ *  to check if the destination address is a region not accessible to DMA. This data is usually SOC
+ *  specific and is filled by SysConfig.
+ *
+ */
+typedef struct
+{
+    uint32_t regionStartAddr;
+    /**< Start address of the region */
+    uint32_t regionSize;
+    /**< Size of the region */
+
+} GPMC_AddrRegion;
+
+/**
+ *  \brief GPMC driver object
+ *
+ */
+typedef struct GPMC_Object_s {
+
+    GPMC_Handle                     handle;
+    /**< Instance handle */
+    GPMC_CallbackFxn                transferCallbackFxn;
+    /**< Callback function pointer */
+    GPMC_Params                     params;
+    /**< Driver user configurable params structure */
+    GPMC_OperatingMode              operMode;
+    /**< GPMC Driver operating mode */
+    /*
+     * State variables
+     */
+    uint32_t                        isOpen;
+    /**< Flag to indicate if the instance is already open */
+    HwiP_Object                     hwi;
+    /**< Interrupt object */
+    SemaphoreP_Object               mutex;
+    /**< Driver lock object */
+    SemaphoreP_Object               transferComplete;
+    /**< Transfer Sync Semaphore object */
+    GPMC_Transaction                *transaction;
+    /**< Pointer to current transaction struct */
+    void* gpmcDmaHandle;
+    /**< DMA configuration handle */
+} GPMC_Object;
+
+/**
+ *  \brief  GPMC timing parameters
+ */
+typedef struct GPMC_timingParams_s
+{
+    uint32_t    csOnTime;
+    /* Chip Select assertion time. */
+    uint32_t    csRdOffTime;
+    /**< Chip Select Read de-assertion time. */
+    uint32_t    csWrOffTime;
+    /**< Chip Select Write de-assertion time. */
+    uint32_t    advOnTime;
+    /**< ADV Assertion time. */
+    uint32_t    advRdOffTime;
+    /**< ADV Read de-assertion time. */
+    uint32_t    advWrOffTime;
+    /**< ADV Write de-assertion time. */
+    uint32_t    advAadMuxOnTime;
+    /**< ADV Assertion time in an AADMultiplexed access. */
+    uint32_t    advAadMuxRdOffTime;
+    /**< ADV Read de-assertion time in an AADMultiplexed access. */
+    uint32_t    advAadMuxWrOffTime;
+    /**< ADV Write de-assertion time in an AADMultiplexed access. */
+    uint32_t    weOnTtime;
+    /**< WE assertion time. */
+    uint32_t    weOffTime;
+    /**< WE de-assertion time. */
+    uint32_t    oeOnTime;
+    /**< OE assertion time. */
+    uint32_t    oeOffTime;
+    /**< OE de-assertion time. */
+    uint32_t    oeAadMuxOnTime;
+    /**< OE assertion time in an AADMultiplexed access. */
+    uint32_t    oeAadMuxOffTime;
+    /**< OE de-assertion time in an AADMultiplexed access. */
+    uint32_t    pageBurstAccess;
+    /**< Multiple access word delay. */
+    uint32_t    rdAccessTime;
+    /**< Start-cycle to first valid delay. */
+    uint32_t    wrAcessTime;
+    /**< Delay from StartAccessTime to the CLK rising edge. */
+    uint32_t    rdCycleTime;
+    /**< Total read cycle time. */
+    uint32_t    wrCycleTime;
+    /**< Total write cycle time. */
+    uint32_t    wrDataOnMuxBusTime;
+    /**< Write Data on Mux Bus Time. */
+    uint32_t    cycle2CycleDelay;
+    /**< Chip Select high pulse delay between two successive accesses. */
+    uint32_t    cycleDelaySameChipSel;
+    /**< Value to control adding of cycle2cycle delay between two successive
+         accesses to the same chip select. */
+    uint32_t    cycleDelayDiffChipSel;
+    /**< Value to control adding of cycle2cycle delay between two successive
+         accesses to the different chip select. */
+    uint32_t    busTurnAroundTime;
+    /**< Bus turn around time between two successive
+         accesses to the same chip-select (read to write)
+         or to a different chip-select(read to read and read to write)
+         in GPMC_FCLK cycles. */
+} GPMC_timingParams;
+
+/**
+ *  \brief  GPMC instance attributes
+ */
+typedef struct GPMC_HwAttrs_s
+{
+
+    uint32_t                gpmcBaseAddr;
+    /**< GPMC Peripheral base address. */
+    uint32_t                dataBaseAddr;
+    /**< GPMC flash base address. */
+    uint32_t                elmBaseAddr;
+    /**< Error Location Module base address for ECC computation. */
+    uint32_t                inputClkFreq;
+    /**< GPMC module input clock frequency. */
+    uint32_t                intrNum;
+    /**< GPMC Peripheral interupt number. */
+    uint32_t                intrPriority;
+    /**< Interupt priority*/
+    uint32_t                clkDivider;
+    /**< GPMC FCLK divider*/
+    uint32_t                addrDataMux;
+    /**< Address and data multiplexed protocol */
+    uint32_t                timeLatency;
+    /**< Current Active chip select in use by the memory controller */
+    uint32_t                chipSelBaseAddr;
+    /**< Chip select base address (A29 - A24) */
+    uint32_t                chipSelAddrSize;
+    /**< Chip select address mask size */
+    uint32_t                waitPinNum;
+    /**< Wait pin number */
+    uint32_t                waitPinPol;
+    /**< Wait pin polarity  */
+    GPMC_timingParams       timingParams;
+    /**< Structure holding the timing parameters for the GPMC instance. */
+    GPMC_nandEccAlgo        eccAlgo;
+    /**< ECC algorithm supported by the controller. */
+    uint32_t                readType;
+    /**< Read operation mode */
+    uint32_t                writeType;
+    /**< Write operation mode */
+    uint32_t                csExDelay;
+    /**< Chip Select Extra Delay flag. */
+    uint32_t                accessType;
+    /**< Memory access type */
+    const GPMC_AddrRegion   *dmaRestrictedRegions;
+    /**< Pointer to array of GPMC_AddrRegion data structures filled by SysConfig. The
+    array should be terminated by a { 0xFFFFFFFFU, 0U } entry. It is used while
+    using DMA copy to check if the destination address is a region not accessible to DMA
+    and switch to CPU copy */
+
+} GPMC_HwAttrs;
+
+/**
+ *  \brief  GPMC Driver configuration structure
+ */
+typedef struct GPMC_Config_s {
+
+    const GPMC_HwAttrs * attrs;
+    /**< Pointer to driver instance specific attributes */
+    GPMC_Object *object;
+    /**< Pointer to driver specific data object */
+
+} GPMC_Config;
+
+
+/** \brief Externally defined driver configuration array */
+extern GPMC_Config gGpmcConfig[];
+/** \brief Externally defined driver configuration array size */
+extern uint32_t gGpmcConfigNum;
+
+/* ========================================================================== */
+/*                       Function Declarations                                */
+/* ========================================================================== */
+/**
+ *  \brief  Function to initialize the \ref GPMC_Params struct to its defaults
+ *
+ *  \param  params Pointer to \ref GPMC_Params structure for initialization
+ */
+static inline void GPMC_Params_init(GPMC_Params *params);
+
+/**
+ *  \brief  This function initializes the GPMC module
+ */
+void GPMC_init(void);
+/**
+ *  \brief  This function de-initializes the GPMC module
+ */
+void GPMC_deinit(void);
+
+/**
+ *  \brief  This function opens a given GPMC peripheral
+ *
+ *  \pre    GPMC controller has been initialized using #GPMC_init()
+ *
+ *  \param  index       Index of config to use in the #GPMC_Config array
+ *  \param  prms  Pointer to parameters #GPMC_Params to open the driver instance.
+ *
+ *  \return A #GPMC_Handle on success or a NULL on an error or if it has been
+ *          opened already
+ *
+ *  \sa     #GPMC_init()
+ *  \sa     #GPMC_close()
+ */
+GPMC_Handle GPMC_open(uint32_t index, const GPMC_Params *prms);
+
+/**
+ *  \brief  Function to close a GPMC peripheral specified by the GPMC handle
+ *
+ *  \pre    #GPMC_open() has to be called first
+ *
+ *  \param  handle      #GPMC_Handle returned from #GPMC_open()
+ *
+ *  \sa     #GPMC_open()
+ */
+void GPMC_close(GPMC_Handle handle);
+
+/**
+ *  \brief  This function returns the input clk frequency GPMC was programmed at
+ *
+ *  \pre    GPMC controller has been opened using #GPMC_open()
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \return GPMC RCLK in Hertz
+ */
+uint32_t GPMC_getInputClk(GPMC_Handle handle);
+
+/**
+ *  \brief  This function returns the handle of an open GPMC Instance from the instance index
+ *
+ *  \pre    GPMC controller has been opened using #GPMC_open()
+ *
+ *  \param  driverInstanceIndex Index of config to use in the #OSPI_Config array
+ *
+ *  \return An #GPMC_Handle if it has been opened already or NULL otherwise
+ *
+ *  \sa     #GPMC_init()
+ *  \sa     #GPMC_open()
+ */
+GPMC_Handle GPMC_getHandle(uint32_t driverInstanceIndex);
+
+/**
+ *  \brief  Function to initialise #GPMC_nandCmdParams structure to default values.
+ *
+ *
+ *  \param  cmdParams Pointer to #GPMC_nandCmdParams structure
+ *
+ */
+void GPMC_writeNandCommandParamsInit(GPMC_nandCmdParams *cmdParams);
+
+/**
+ *  \brief  Function to write NAND command parameters.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  cmdParams Pointer to #GPMC_nandCmdParams structure
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ *
+ */
+int32_t GPMC_writeNandCommand(GPMC_Handle handle, GPMC_nandCmdParams *cmdParams);
+
+/**
+ *  \brief  Function to initialise #GPMC_Transaction structure to default values.
+ *
+ *
+ *  \param  trans Pointer to #GPMC_Transaction structure
+ *
+ */
+void GPMC_transactionInit(GPMC_Transaction *trans);
+
+/**
+ *  \brief  Function to read data from NAND flash using DMA or CPU
+ *          prefetch/post write engine.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  trans Pointer to #GPMC_Transaction structure
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_nandReadData(GPMC_Handle handle, GPMC_Transaction *trans);
+
+/**
+ *  \brief  Function to write data to NANDflash using CPU prefetch/post write engine.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  trans Pointer to #GPMC_Transaction structure
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_nandWriteData(GPMC_Handle handle, GPMC_Transaction *trans);
+
+/**
+ *  \brief  Function to set device width for GPMC instance connected to external
+ *          device.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_setDeviceSize(GPMC_Handle handle);
+
+/**
+ *  \brief  Function to set device type (NANDLIKE OR NORLIKE) for GPMC instance connected
+ *          to external device.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_setDeviceType(GPMC_Handle handle);
+
+/**
+ *  \brief  Function to configure GPMC timing parameters.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_configureTimingParameters(GPMC_Handle handle);
+
+/**
+ *  \brief  Function to set ECC used and unused bytes size in nibbles.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  eccSize Param to set #GPMC_ECC_SIZE_0 (used bytes) or #GPMC_ECC_SIZE_1 unused bytes
+ *
+ *  \param  eccSizeVal  ECC used or ununsed bytes value in nibbles.
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccValueSizeSet(GPMC_Handle handle, uint32_t eccSize, uint32_t eccSizeVal);
+
+/**
+ *  \brief  Function to configure ELM module for error correction.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  numSectors Number of 512 bytes sector in a NAND page.
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccBchConfigureElm(GPMC_Handle handle, uint8_t numSectors);
+
+/**
+ *  \brief  Function to configure GPMC ECC engine for BCH algorithm
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  eccSteps Number of 512 bytes sectors to process BCH syndrome polynomial computation.
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccEngineBCHConfig (GPMC_Handle handle, uint32_t eccSteps);
+
+/**
+ *  \brief  Function to enable GPMC ECC engine.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccEngineEnable(GPMC_Handle handle);
+
+/**
+ *  \brief  Function to clear GPMC ECC result register.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ */
+void GPMC_eccResultRegisterClear(GPMC_Handle handle);
+
+/**
+ *  \brief  Function to fill BCH syndrome value per sector to ELM module.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  sector  Sector number
+ *
+ *  \param  bchData Pointer to syndrome polynomial value.
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccBchFillSyndromeValue(GPMC_Handle handle, uint32_t sector, uint32_t *bchData);
+
+/**
+ *  \brief  Function to start error processing for a sector by ELM module.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  sector  Sector number
+ *
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccBchStartErrorProcessing(GPMC_Handle handle, uint8_t sector);
+
+/**
+ *  \brief  Function to get error processing status for a sector by ELM module.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  sector  Sector number
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccBchCheckErrorProcessingStatus(GPMC_Handle handle, uint32_t sector);
+
+/**
+ *  \brief  Function to get number of errors per sector by ELM module.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  sector  Sector number
+ *
+ *  \param  errCount  Pointer to store number of errors in a sector
+ *
+ *  \param  errLoc  Pointer to store error locations in a sector
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccBchSectorGetError(GPMC_Handle handle, uint32_t sector, uint32_t *errCount, uint32_t *errLoc);
+
+/**
+ *  \brief  Function to compute BCH syndrome polynomial for NAND write operation.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  sector  Sector number
+ *
+ *  \param  pEccdata  Pointer to store BCH syndrome polynomial.
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccCalculateBchSyndromePolynomial(GPMC_Handle handle, uint8_t *pEccdata, uint32_t sector);
+
+/**
+ *  \brief  Function to get BCH syndrome polynomial per sector NAND read operation.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *  \param  sector  Sector number
+ *
+ *  \param  bchData  Pointer to store BCH syndrome polynomial.
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_eccGetBchSyndromePolynomial(GPMC_Handle handle, uint32_t sector, uint32_t *bchData);
+
+/**
+ *  \brief  Function to configure GPMC PREFETCH read and POST write engine.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_configurePrefetchPostWriteEngine(GPMC_Handle handle);
+
+/**
+ *  \brief  Function to disable WRITE protect line.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_disableFlashWriteProtect(GPMC_Handle handle);
+
+/**
+ *  \brief  Function to disable WRITE protect line.
+ *
+ *  \param  handle  An #GPMC_Handle returned from an #GPMC_open()
+ *
+ *
+ *  \return SystemP_SUCCESS or SystemP_FAILURE
+ */
+int32_t GPMC_enableFlashWriteProtect(GPMC_Handle handle);
+/* ========================================================================== */
+/*                       Static Function Definitions                          */
+/* ========================================================================== */
+static inline void GPMC_Params_init(GPMC_Params *params)
+{
+    if (params != NULL)
+    {
+        params->dmaEnable = FALSE;
+        params->intrEnable = FALSE;
+        params->chipSel = 0;
+        params->devType = CSL_GPMC_CONFIG1_DEVICETYPE_NANDLIKE;
+        params->devType = CSL_GPMC_CONFIG1_DEVICESIZE_EIGHTBITS;
+        params->gpmcDmaChIndex = -1;
+        params->transferMode = GPMC_TRANSFER_MODE_BLOCKING;
+        params->transferCallBckFunc = NULL;
+    }
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _GPMC__H_ */
+
+/** @} */
+
diff --git a/source/drivers/gpmc/v0/gpmc_v0.c b/source/drivers/gpmc/v0/gpmc_v0.c
new file mode 100644
index 0000000000..2afc4b223a
--- /dev/null
+++ b/source/drivers/gpmc/v0/gpmc_v0.c
@@ -0,0 +1,1846 @@
+/*
+ *  Copyright (C) 2023 Texas Instruments Incorporated
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *    Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ *    Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the
+ *    distribution.
+ *
+ *    Neither the name of Texas Instruments Incorporated nor the names of
+ *    its contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ *  \file gpmc_v0.c
+ *
+ *  \brief File containing GPMC Driver APIs implementation for version V1.
+ *
+ */
+
+/* ========================================================================== */
+/*                             Include Files                                  */
+/* ========================================================================== */
+#include <string.h>
+#include <kernel/dpl/SemaphoreP.h>
+#include <kernel/dpl/HwiP.h>
+#include <kernel/dpl/CacheP.h>
+#include <kernel/dpl/ClockP.h>
+#include <drivers/hw_include/cslr.h>
+#include <drivers/gpmc.h>
+#include <drivers/elm.h>
+#include <drivers/gpmc/v0/dma/gpmc_dma.h>
+
+
+/* ========================================================================== */
+/*                           Macros & Typedefs                                */
+/* ========================================================================== */
+/* GPMC Module wait time*/
+#define GPMC_MODULE_RESET_WAIT_TIME_MAX              (10 * 1000)   /*10ms*/
+#define GPMC_WAIT_PIN_STATUS_WAIT_TIME_MAX           (10 * 1000U)  /*1ms*/
+#define GPMC_WAIT_PIN_STATUS_WAIT_TIME_MIN           (0U)          /*1ms*/
+#define GPMC_ELM_ERR_STATUS_TIMEOUT_MAX              (10 * 1000U)  /*1ms*/
+/* ========================================================================== */
+/*                         Structure Declarations                             */
+/* ========================================================================== */
+
+typedef struct
+{
+    void *openLock;
+    /**<  Lock to protect GPMC open*/
+    SemaphoreP_Object lockObj;
+    /**< Lock object */
+} GPMC_DrvObj;
+
+/* ========================================================================== */
+/*                          Function Declarations                             */
+/* ========================================================================== */
+
+/* Internal functions */
+static void GPMC_isr(void *arg);
+static uint32_t GPMC_eccBchResultGet(GPMC_Handle handle, uint32_t resIndex, uint32_t sector);
+static void GPMC_eccResultSizeSelect(GPMC_Handle handle, uint32_t eccResReg,
+                             uint32_t eccSize);
+
+static void GPMC_nandAddressWrite(GPMC_Handle handle, uint32_t address);
+static void GPMC_nandCommandWrite(GPMC_Handle handle, uint32_t cmd);
+static void GPMC_transferCallback(GPMC_Handle handle, GPMC_Transaction *msg);
+static int32_t GPMC_programInstance(GPMC_Config *config);
+static void GPMC_disableInterupt(uint32_t baseAddr, uint32_t interupt);
+static void GPMC_enableInterupt(uint32_t baseAddr, uint32_t interupt);
+static void GPMC_interuptStatusClear(uint32_t baseAddr, uint32_t interupt);
+static uint32_t  GPMC_interuptStatusGet(uint32_t baseAddr, uint32_t interupt);
+static void GPMC_waitPinPolaritySelect(GPMC_Handle handle, uint32_t pin,
+                                uint32_t polarity);
+static int32_t GPMC_waitPinInteruptStatusReadyWaitTimeout(GPMC_Handle handle,
+                                uint32_t timeOut);
+static int32_t GPMC_waitPinStatusReadyWaitTimeout(GPMC_Handle handle,
+                                uint32_t timeOut);
+static uint32_t GPMC_waitPinStatusGet(uint32_t baseAddr, uint32_t pin);
+static int32_t GPMC_moduleResetStatusWaitTimeout(GPMC_Config *config,
+                                uint32_t timeOut);
+static int32_t GPMC_isDmaRestrictedRegion(GPMC_Handle handle, uint32_t addr);
+static int32_t GPMC_prefetchPostWriteConfigEnable(GPMC_Handle handle, uint8_t mode,
+                                    uint32_t transferCount, uint8_t modeDMA);
+static int32_t GPMC_prefetchPostWriteConfigDisable(GPMC_Handle handle);
+
+/* ========================================================================== */
+/*                            Global Variables                                */
+/* ========================================================================== */
+
+/** \brief Driver object */
+static GPMC_DrvObj gGpmcDrvObj =
+{
+    .openLock      = NULL,
+};
+
+/* ========================================================================== */
+/*                          Function Definitions                              */
+/* ========================================================================== */
+
+void GPMC_init(void)
+{
+    int32_t status = SystemP_SUCCESS;
+    GPMC_Object *obj;
+
+    for(uint8_t count =0; count < gGpmcConfigNum; count++)
+    {
+        /* Init object variables */
+        obj = gGpmcConfig[count].object;
+        DebugP_assert(NULL != obj);
+        memset(obj, 0, sizeof(GPMC_Object));
+    }
+
+    /* Create the driver lock */
+    status = SemaphoreP_constructMutex(&gGpmcDrvObj.lockObj);
+    if(SystemP_SUCCESS == status)
+    {
+        gGpmcDrvObj.openLock = &gGpmcDrvObj.lockObj;
+    }
+
+    return;
+}
+
+void GPMC_deinit(void)
+{
+    if(gGpmcDrvObj.openLock != NULL)
+    {
+        /* Delete Semaphore. */
+        SemaphoreP_destruct(&gGpmcDrvObj.lockObj);
+        gGpmcDrvObj.openLock = NULL;
+    }
+
+    return;
+}
+
+int32_t GPMC_configureTimingParameters(GPMC_Handle handle)
+{
+    int32_t status = SystemP_SUCCESS;
+    uint32_t timeConfig = 0;
+
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+        GPMC_Object *object  = ((GPMC_Config*)handle)->object;
+
+
+        /* CONFIG2 reister timing config, no extra delay */
+        timeConfig = GPMC_CS_TIMING_CONFIG(hwAttrs->timingParams.csWrOffTime,
+                                            hwAttrs->timingParams.csRdOffTime,
+                                            hwAttrs->csExDelay,
+                                            hwAttrs->timingParams.csOnTime);
+
+        CSL_REG32_WR(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG2(object->params.chipSel), timeConfig);
+
+
+        /* CONFIG3 reister timing config, no extra delay */
+        timeConfig = GPMC_ADV_TIMING_CONFIG(hwAttrs->timingParams.advAadMuxWrOffTime,
+                                            hwAttrs->timingParams.advAadMuxRdOffTime,
+                                            hwAttrs->timingParams.advWrOffTime,
+                                            hwAttrs->timingParams.advRdOffTime,
+                                            CSL_GPMC_CONFIG3_ADVEXTRADELAY_NOTDELAYED,
+                                            hwAttrs->timingParams.advAadMuxOnTime,
+                                            hwAttrs->timingParams.advOnTime);
+        CSL_REG32_WR(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG3(object->params.chipSel), timeConfig);
+
+       /* CONFIG4 reister timing config, no xtra delay */
+        timeConfig = GPMC_WE_OE_TIMING_CONFIG(hwAttrs->timingParams.weOffTime,
+                                                CSL_GPMC_CONFIG4_WEEXTRADELAY_NOTDELAYED,
+                                                hwAttrs->timingParams.weOnTtime,
+                                                hwAttrs->timingParams.oeAadMuxOffTime,
+                                                hwAttrs->timingParams.oeOffTime,
+                                                CSL_GPMC_CONFIG4_OEEXTRADELAY_NOTDELAYED,
+                                                hwAttrs->timingParams.oeAadMuxOnTime,
+                                                hwAttrs->timingParams.oeOnTime);
+
+        CSL_REG32_WR(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG4(object->params.chipSel), timeConfig);
+
+        /* CONFIG5 reister timing config */
+        timeConfig = GPMC_RDACCESS_CYCLETIME_TIMING_CONFIG(hwAttrs->timingParams.rdCycleTime,
+                                                            hwAttrs->timingParams.wrCycleTime,
+                                                            hwAttrs->timingParams.rdAccessTime,
+                                                            hwAttrs->timingParams.pageBurstAccess);
+        CSL_REG32_WR(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG5(object->params.chipSel), timeConfig);
+
+
+        /* CONFIG6 reister timing config */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG6(object->params.chipSel),
+                    GPMC_CONFIG6_WRACCESSTIME, hwAttrs->timingParams.wrAcessTime);
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG6(object->params.chipSel),
+                    GPMC_CONFIG6_WRDATAONADMUXBUS, hwAttrs->timingParams.wrDataOnMuxBusTime);
+
+
+        timeConfig = GPMC_CYCLE2CYCLE_BUSTURNAROUND_TIMING_CONFIG(hwAttrs->timingParams.cycle2CycleDelay,
+                                                                    hwAttrs->timingParams.cycleDelaySameChipSel,
+                                                                    hwAttrs->timingParams.cycleDelayDiffChipSel,
+                                                                    hwAttrs->timingParams.busTurnAroundTime);
+
+        CSL_REG32_WR(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG6(object->params.chipSel), \
+        (CSL_REG32_RD(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG6(object->params.chipSel)) | timeConfig));
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_setDeviceType(GPMC_Handle handle)
+{
+    int32_t status = SystemP_SUCCESS;
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        GPMC_Config *config = (GPMC_Config*)handle;
+        const GPMC_HwAttrs *attrs = config->attrs;
+        GPMC_Object *object = config->object;
+        /* Set Device type interfaced with GPMC. */
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                  GPMC_CONFIG1_DEVICETYPE, object->params.devType);
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_setDeviceSize(GPMC_Handle handle)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        GPMC_Config *config = (GPMC_Config*)handle;
+        const GPMC_HwAttrs *attrs = config->attrs;
+        GPMC_Object *object = config->object;
+        /* Set device width interfaced with GPMC. */
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                  GPMC_CONFIG1_DEVICESIZE, object->params.devSize);
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+GPMC_Handle GPMC_open(uint32_t index, const GPMC_Params *prms)
+{
+    int32_t status = SystemP_SUCCESS;
+    GPMC_Handle         handle = NULL;
+    GPMC_Config         *config = NULL;
+    GPMC_Object         *object = NULL;
+    const GPMC_HwAttrs  *hwAttrs = NULL;
+    HwiP_Params         hwiParams;
+
+
+    /* Check for valid index */
+    if(index >= gGpmcConfigNum)
+    {
+        status = SystemP_FAILURE;
+    }
+    else
+    {
+        config = &gGpmcConfig[index];
+    }
+
+    /* Protect this region from a concurrent GPMC_Open */
+    DebugP_assert(NULL != gGpmcDrvObj.openLock);
+    SemaphoreP_pend(&gGpmcDrvObj.lockObj, SystemP_WAIT_FOREVER);
+
+    if(status == SystemP_SUCCESS)
+    {
+        object = config->object;
+        DebugP_assert(object != NULL);
+        DebugP_assert(config->attrs != NULL);
+        hwAttrs = config->attrs;
+        if(object->isOpen == TRUE)
+        {
+            status = SystemP_FAILURE;
+        }
+    }
+
+    if(status == SystemP_SUCCESS)
+    {
+        object->handle = (GPMC_Handle)config;
+
+        if(prms != NULL)
+        {
+            memcpy((void*)&object->params, (void*)prms, sizeof(GPMC_Params));
+        }
+        else
+        {
+            /* Init with default if NULL is passed */
+            GPMC_Params_init(&object->params);
+        }
+
+        /* If DMA is enabled, program UDMA block copy channel */
+        if(object->params.dmaEnable == TRUE)
+        {
+            object->gpmcDmaHandle = GPMC_dmaOpen(object->params.gpmcDmaChIndex);
+        }
+        else
+        {
+            object->gpmcDmaHandle = NULL;
+        }
+
+        if(object->params.transferMode == GPMC_TRANSFER_MODE_BLOCKING)
+        {
+            if(object->params.intrEnable == TRUE)
+            {
+                object->operMode = GPMC_OPERATING_MODE_BLOCKING;
+            }
+            else
+            {
+                object->operMode = GPMC_OPERATING_MODE_POLLING;
+            }
+        }
+        else
+        {
+            object->operMode = GPMC_OPERATING_MODE_CALLBACK;
+        }
+
+        if(object->params.intrEnable == TRUE)
+        {
+            HwiP_Params_init(&hwiParams);
+            hwiParams.intNum = hwAttrs->intrNum;
+            hwiParams.callback = GPMC_isr;
+            hwiParams.args     = (void*)config;
+            hwiParams.priority = hwAttrs->intrPriority;
+            status += HwiP_construct(&object->hwi, &hwiParams);
+
+        }
+
+    }
+
+    if(status == SystemP_SUCCESS)
+    {
+        status += GPMC_programInstance(config);
+
+        status += SemaphoreP_constructMutex(&object->mutex);
+
+        if (object->operMode == GPMC_OPERATING_MODE_BLOCKING)
+        {
+            /*
+            * Semaphore to cause the waiting task to block for the GPMC to finish.
+            */
+            status += SemaphoreP_constructBinary(&object->transferComplete, 0);
+
+            /* Store internal callback function */
+            object->params.transferCallBckFunc = &GPMC_transferCallback;
+        }
+
+        if(object->operMode == GPMC_OPERATING_MODE_CALLBACK)
+        {
+            /* Currently not supported. */
+        }
+
+    }
+
+    if(status == SystemP_SUCCESS)
+    {
+        object->isOpen = 1;
+        handle = (GPMC_Handle)config;
+    }
+
+    SemaphoreP_post(&gGpmcDrvObj.lockObj);
+
+    /* Free up resources in case of error. */
+    if(SystemP_SUCCESS != status)
+    {
+        if(NULL != config)
+        {
+            GPMC_close((GPMC_Handle) config);
+        }
+    }
+
+    return(handle);
+}
+
+void GPMC_close(GPMC_Handle handle)
+{
+    /* Input parameter validation */
+    if (handle != NULL)
+    {
+        GPMC_Object        *object = NULL;
+        const GPMC_HwAttrs *hwAttrs = NULL;
+        /* Get the pointer to the object and hwAttrs */
+        object = ((GPMC_Config*)handle)->object;
+        hwAttrs = ((GPMC_Config*)handle)->attrs;
+
+        /* Disable all interupts associated to GPMC. */
+        GPMC_disableInterupt(hwAttrs->gpmcBaseAddr,GPMC_FIFOEVENT_INT);
+        GPMC_disableInterupt(hwAttrs->gpmcBaseAddr,GPMC_TERMINALCOUNT_INT);
+        GPMC_disableInterupt(hwAttrs->gpmcBaseAddr,GPMC_WAIT0EDGEDETECTION_INT);
+        GPMC_disableInterupt(hwAttrs->gpmcBaseAddr,GPMC_WAIT1EDGEDETECTION_INT);
+
+        /* If DMA block copy channel was opened, close it. */
+        if(object->params.dmaEnable == TRUE)
+        {
+            GPMC_dmaClose(object->gpmcDmaHandle);
+        }
+
+        /* Destruct the Hwi. */
+        if(object->operMode != GPMC_OPERATING_MODE_POLLING)
+        {
+            HwiP_destruct(&object->hwi);
+        }
+
+        /* Destruct the instance lock. */
+        SemaphoreP_destruct(&object->mutex);
+
+        /* Destruct the transfer completion lock. */
+        if(object->operMode == GPMC_OPERATING_MODE_BLOCKING)
+        {
+            SemaphoreP_destruct(&object->transferComplete);
+        }
+
+        /* Open flag is set false. */
+        object->isOpen = 0;
+    }
+
+    return;
+}
+
+void GPMC_transactionInit(GPMC_Transaction *trans)
+{
+    trans->Buf = NULL;
+    trans->count = 0;
+    trans->status = GPMC_TRANSFER_STARTED;
+    trans->transType = GPMC_TRANSACTION_TYPE_READ;
+    trans->arg = NULL;
+    trans->transferTimeout = SystemP_WAIT_FOREVER;
+}
+
+int32_t GPMC_configurePrefetchPostWriteEngine(GPMC_Handle handle)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+        GPMC_Object *object = ((GPMC_Config*)handle)->object;
+
+        /*Disable and stop the prefetch engine*/
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONTROL, GPMC_PREFETCH_CONTROL_STARTENGINE, \
+        CSL_GPMC_PREFETCH_CONTROL_STARTENGINE_STOP);
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_ENABLEENGINE, \
+        CSL_GPMC_PREFETCH_CONFIG1_ENABLEENGINE_PPDISABLED);
+
+        /*Select the chip select associated with the external device*/
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_ENGINECSSELECTOR, \
+        object->params.chipSel);
+
+        /*Set FIFOTHRESHOLD value. */
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_FIFOTHRESHOLD, \
+        CSL_GPMC_PREFETCH_CONFIG1_FIFOTHRESHOLD_RESETVAL);
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_nandReadData(GPMC_Handle handle, GPMC_Transaction *trans)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation */
+    if(handle != NULL && trans != NULL)
+    {
+        GPMC_Object *object = ((GPMC_Config*)handle)->object;
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+        uint32_t byteCount = trans->count;
+        uint32_t threshold = 0;
+
+        if(object->operMode == GPMC_OPERATING_MODE_POLLING)
+        {
+            if(trans->transType == GPMC_TRANSACTION_TYPE_READ)
+            {
+                /* Check for read data length more thand DMA copy lower limit (512 bytes -> 1 sector).
+                 * Check if destination address is not a restricted dma region.
+                 */
+                if(object->params.dmaEnable && (trans->count >= GPMC_DMA_COPY_LOWER_LIMIT)
+                    && (GPMC_isDmaRestrictedRegion(handle, (uint32_t)trans->Buf) == FALSE))
+                {
+                    /* Enable prefetch read engine.  */
+                    status += GPMC_prefetchPostWriteConfigEnable(handle, GPMC_PREFETCH_ACCESSMODE_READ, byteCount, TRUE);
+
+                    if(status == SystemP_SUCCESS)
+                    {
+                        /* Perform DMA copy. */
+                        GPMC_dmaCopy(object->gpmcDmaHandle, trans->Buf, (void*)attrs->chipSelBaseAddr, trans->count, TRUE);
+                    }
+                    /* Disable prefetch read engine. */
+                    status += GPMC_prefetchPostWriteConfigDisable(handle);
+                }
+                else
+                {
+                    /* Perform CPU read with prefetch read engine. */
+
+                    /* Enable prefetch read engine. */
+                    status += GPMC_prefetchPostWriteConfigEnable(handle, GPMC_PREFETCH_ACCESSMODE_READ, byteCount, FALSE);
+
+                    if(status == SystemP_SUCCESS)
+                    {
+                        uint32_t *ptr = (uint32_t *)trans->Buf;
+
+                        while(byteCount)
+                        {
+                            /* Get GPMC FIFO counter value. */
+                            threshold = CSL_REG32_FEXT(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_STATUS, GPMC_PREFETCH_STATUS_FIFOPOINTER);
+
+                            for(uint32_t i =0; i< threshold/4;i++)
+                            {
+                                *ptr++ = *(volatile uint32_t*)attrs->chipSelBaseAddr;
+                                byteCount -=4;
+                            }
+                        }
+
+
+                    }
+
+                    /* Disable prefetch read engine. */
+                    status += GPMC_prefetchPostWriteConfigDisable(handle);
+                }
+            }
+            else if(trans->transType == GPMC_TRANSACTION_TYPE_READ_CMDREG)
+            {
+                /* Read data from GPMC command register. */
+                uint32_t *bufPtr = (uint32_t*)trans->Buf;
+
+                *bufPtr = CSL_REG32_RD(attrs->gpmcBaseAddr + CSL_GPMC_NAND_DATA(object->params.chipSel));
+            }
+            else
+            {
+                status = SystemP_FAILURE;
+            }
+        }
+        else
+        {
+            /* Interupt mode not supported. */
+            status = SystemP_FAILURE;
+        }
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_nandWriteData(GPMC_Handle handle, GPMC_Transaction *trans)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation */
+    if(handle != NULL && trans != NULL)
+    {
+        GPMC_Object *object = ((GPMC_Config*)handle)->object;
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+        uint32_t byteCount = trans->count;
+        uint32_t threshold = 0;
+        uint32_t remainBytes = 0;
+
+        if(object->operMode == GPMC_OPERATING_MODE_POLLING)
+        {
+            /* Check for write buffer empty status.*/
+            while(CSL_REG32_FEXT(attrs->gpmcBaseAddr + CSL_GPMC_STATUS,
+                  GPMC_STATUS_EMPTYWRITEBUFFERSTATUS) == CSL_GPMC_STATUS_EMPTYWRITEBUFFERSTATUS_B0);
+
+            if(trans->transType == GPMC_TRANSACTION_TYPE_WRITE)
+            {
+                /* Perform write using post write engine with CPU. */
+                uint32_t *bufPtr = (uint32_t*)trans->Buf;
+                /* Enable post write engine. */
+                status += GPMC_prefetchPostWriteConfigEnable(handle, GPMC_PREFETCH_ACCESSMODE_WRITE, byteCount, FALSE);
+                /* Enable FIFO event interupt. */
+                GPMC_enableInterupt(attrs->gpmcBaseAddr, GPMC_FIFOEVENT_INT);
+
+                if(status == SystemP_SUCCESS)
+                {
+                    while(byteCount)
+                    {
+                        /* Wait until FIFO is empty or full 64 bytes FIFO is available to fill. */
+                        while (GPMC_interuptStatusGet(attrs->gpmcBaseAddr, GPMC_FIFOEVENT_STATUS) == 0);
+
+                        /* Get FIFO pointer and remaining bytes to write value.*/
+                        threshold = CSL_REG32_FEXT(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_STATUS, GPMC_PREFETCH_STATUS_FIFOPOINTER);
+                        remainBytes = CSL_REG32_FEXT(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_STATUS, GPMC_PREFETCH_STATUS_COUNTVALUE);
+
+                        if(remainBytes < threshold)
+                        {
+                            threshold = remainBytes;
+                        }
+                        for(uint32_t i =0; i< threshold/4;i++)
+                        {
+                            *(volatile uint32_t*)attrs->chipSelBaseAddr = *bufPtr++;
+                            byteCount -=4;
+                        }
+
+                        /* Clear FIFO event interupt status . */
+                        GPMC_interuptStatusClear(attrs->gpmcBaseAddr, GPMC_FIFOEVENT_STATUS);
+                    }
+
+                }
+
+                /* Disable FIFO event interupt and post write engine. */
+                GPMC_disableInterupt(attrs->gpmcBaseAddr, GPMC_FIFOEVENT_INT);
+                status += GPMC_prefetchPostWriteConfigDisable(handle);
+
+            }
+            else if(trans->transType == GPMC_TRANSACTION_TYPE_WRITE_CMDREG)
+            {
+                /* Write data using GPMC command register. */
+                uint32_t *bufPtr = (uint32_t*)trans->Buf;
+
+                CSL_REG32_WR(attrs->gpmcBaseAddr + CSL_GPMC_NAND_DATA(object->params.chipSel), *bufPtr);
+            }
+            else
+            {
+                status = SystemP_FAILURE;
+            }
+        }
+        else
+        {
+            /* Interupt mode not supported. */
+            status = SystemP_FAILURE;
+        }
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+void GPMC_writeNandCommandParamsInit(GPMC_nandCmdParams *cmdParams)
+{
+    cmdParams->cmdCycle1 = GPMC_CMD_INVALID;
+    cmdParams->cmdCycle2 = GPMC_CMD_INVALID;
+    cmdParams->colAddress = GPMC_CMD_INVALID;
+    cmdParams->rowAddress = GPMC_CMD_INVALID;
+    cmdParams->numColAddrCycles = GPMC_CMD_INVALID;
+    cmdParams->numRowAddrCycles = GPMC_CMD_INVALID;
+    cmdParams->waitTimeout = 0;
+    cmdParams->checkReadypin = TRUE;
+}
+
+int32_t GPMC_writeNandCommand(GPMC_Handle handle, GPMC_nandCmdParams *cmdParams)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation */
+    if(handle != NULL &&  cmdParams != NULL)
+    {
+        uint32_t waitPinInterupt = 0;
+        uint32_t colAddress = 0;
+        uint32_t rowAddress = 0;
+
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+
+        if(hwAttrs->waitPinNum == CSL_GPMC_CONFIG1_WAITPINSELECT_W0)
+        {
+            waitPinInterupt = GPMC_WAIT0EDGEDETECTION_STATUS;
+        }
+        else if(hwAttrs->waitPinNum == CSL_GPMC_CONFIG1_WAITPINSELECT_W1)
+        {
+            waitPinInterupt = GPMC_WAIT1EDGEDETECTION_STATUS;
+        }
+
+        /* Clear WAIT PIN interupt status. */
+        GPMC_interuptStatusClear(hwAttrs->gpmcBaseAddr, waitPinInterupt);
+
+        /* Write valid nand command cycle 1. */
+        if(cmdParams->cmdCycle1 != GPMC_CMD_INVALID)
+        {
+            GPMC_nandCommandWrite(handle,cmdParams->cmdCycle1);
+        }
+
+        /* Write valid nand column address. */
+        if(cmdParams->colAddress != GPMC_CMD_INVALID)
+        {
+            colAddress = cmdParams->colAddress;
+            for (uint8_t count = 0; count < cmdParams->numColAddrCycles; count++)
+            {
+                GPMC_nandAddressWrite(handle, (colAddress & 0xFF));
+                colAddress = colAddress >> 0x8;
+            }
+        }
+
+        /* Write valid nand row address. */
+        if(cmdParams->rowAddress != GPMC_CMD_INVALID)
+        {
+            rowAddress = cmdParams->rowAddress;
+            for (uint8_t count = 0; count < cmdParams->numRowAddrCycles; count++)
+            {
+                GPMC_nandAddressWrite(handle, (rowAddress & 0xFF));
+                rowAddress = rowAddress >> 0x8;
+            }
+        }
+
+        /* Write valid nand command cycle 2. */
+        if(cmdParams->cmdCycle2 != GPMC_CMD_INVALID)
+        {
+            GPMC_nandCommandWrite(handle,cmdParams->cmdCycle2);
+        }
+
+        /* Check WAIT PIN (mapped to R/B signal of nand flash) interupt status with
+         * or without timeout.
+         */
+        if(cmdParams->checkReadypin != GPMC_CMD_INVALID)
+        {
+            if(!cmdParams->checkReadypin)
+            {
+                status += GPMC_waitPinStatusReadyWaitTimeout(handle, cmdParams->waitTimeout);
+            }
+            else
+            {
+                status += GPMC_waitPinInteruptStatusReadyWaitTimeout(handle,cmdParams->waitTimeout);
+                status += GPMC_waitPinStatusReadyWaitTimeout(handle, GPMC_WAIT_PIN_STATUS_WAIT_TIME_MIN);
+            }
+        }
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+
+}
+
+int32_t GPMC_eccValueSizeSet(GPMC_Handle handle, uint32_t eccSize,
+                       uint32_t eccSizeVal)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        /* Set ECC used and unused bytes size in nibbles. */
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+
+        if (eccSize == GPMC_ECC_SIZE_0)
+        {
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECCSIZE0,
+                          eccSizeVal);
+        }
+        else if (eccSize == GPMC_ECC_SIZE_1)
+        {
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECCSIZE1,
+                          eccSizeVal);
+        }
+        else
+        {
+            /*
+            * Do nothing. Error will be generated by the hardware
+            */
+        }
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+
+}
+
+int32_t GPMC_eccBchConfigureElm(GPMC_Handle handle, uint8_t numSectors)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+        /* Configure ELM module.*/
+        ELM_moduleReset(hwAttrs->elmBaseAddr);
+
+        /* Set max bytes per sector for ECC corrrection. */
+        ELM_setECCSize(hwAttrs->elmBaseAddr, CSL_ELM_LOCATION_CONFIG_ECC_SIZE_MAX);
+
+        /* Set error correction level. */
+        ELM_errorCorrectionLevelSet(hwAttrs->elmBaseAddr, ELM_ECC_BCH_LEVEL_8BITS);
+
+        /* Set all sectors for ELM in CONTINUOUS mode*/
+        for(uint8_t count = 0; count < numSectors; count++)
+        {
+            ELM_interuptConfig(hwAttrs->elmBaseAddr, count, ELM_INT_ENALBLE);
+            ELM_setSectorMode(hwAttrs->elmBaseAddr,ELM_MODE_CONTINUOUS,count);
+        }
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_eccEngineBCHConfig (GPMC_Handle handle , uint32_t eccSteps)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+        GPMC_Object *object = ((GPMC_Config*)handle)->object;
+
+        /* Select ECC result register */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONTROL, GPMC_ECC_CONTROL_ECCPOINTER, GPMC_ECCPOINTER_RESULT_1);
+
+        /* Configure chip select for ECC engine. */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONFIG, GPMC_ECC_CONFIG_ECCCS, object->params.chipSel);
+
+        /* Set number of sectors to process with the BCH algorithm. */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONFIG, GPMC_ECC_CONFIG_ECCTOPSECTOR, eccSteps);
+
+        /* Set error correction capability used for BCH. */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONFIG, GPMC_ECC_CONFIG_ECC16B, CSL_GPMC_ECC_CONFIG_ECC16B_EIGHTCOL);
+
+        /* Spare area organization definition for the BCH algorithm. */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONFIG, GPMC_ECC_CONFIG_ECCWRAPMODE, GPMC_ECC_WRAP_MODE1);
+
+        /* Set error correction level. 8 bit or 16 bit. */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONFIG, GPMC_ECC_CONFIG_ECCBCHTSEL, GPMC_ECC_BCH_ERRCORRCAP_UPTO_8BITS);
+
+        /* Set ECC algo for ECC engine. */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONFIG, GPMC_ECC_CONFIG_ECCALGORITHM, GPMC_ECC_ALGORITHM_BCH);
+
+        /* Set ECC size for ECC result register. */
+        GPMC_eccResultSizeSelect(handle, GPMC_ECC_RESULT_1, CSL_GPMC_ECC_SIZE_CONFIG_ECC1RESULTSIZE_SIZE0SEL);
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_eccEngineEnable(GPMC_Handle handle)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+        /* Enable ECC engine. */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONTROL, GPMC_ECC_CONTROL_ECCPOINTER,
+                        GPMC_ECCPOINTER_RESULT_1);
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_CONFIG, GPMC_ECC_CONFIG_ECCENABLE,
+                  CSL_GPMC_ECC_CONFIG_ECCENABLE_ECCENABLED);
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+void GPMC_eccResultRegisterClear(GPMC_Handle handle)
+{
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+        /* Clear all the ECC result registers. */
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_ECC_CONTROL, GPMC_ECC_CONTROL_ECCCLEAR,
+                    CSL_GPMC_ECC_CONTROL_ECCCLEAR_MAX);
+    }
+}
+
+GPMC_Handle GPMC_getHandle(uint32_t driverInstanceIndex)
+{
+    GPMC_Handle         handle = NULL;
+    /* Check index */
+    if(driverInstanceIndex < gGpmcConfigNum)
+    {
+        GPMC_Object *obj;
+        obj = gGpmcConfig[driverInstanceIndex].object;
+
+        if(obj && (TRUE == obj->isOpen))
+        {
+            /* valid handle */
+            handle = obj->handle;
+        }
+    }
+    return handle;
+}
+
+int32_t GPMC_eccGetBchSyndromePolynomial(GPMC_Handle handle, uint32_t sector, uint32_t *bchData)
+{
+        int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        bchData[0] = GPMC_eccBchResultGet(handle, GPMC_BCH_RESULT0, sector);
+        bchData[1] = GPMC_eccBchResultGet(handle, GPMC_BCH_RESULT1, sector);
+        bchData[2] = GPMC_eccBchResultGet(handle, GPMC_BCH_RESULT2, sector);
+        bchData[3] = GPMC_eccBchResultGet(handle, GPMC_BCH_RESULT3, sector);
+
+    }
+    else
+    {
+        status =  SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_eccBchFillSyndromeValue(GPMC_Handle handle, uint32_t sector, uint32_t *bchData)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+
+        /* Fill BCH syndrome polynomial to ELM module per sector. */
+        ELM_setSyndromeFragment(attrs->elmBaseAddr, ELM_SYNDROME_FRGMT_0, bchData[0], sector);
+        ELM_setSyndromeFragment(attrs->elmBaseAddr, ELM_SYNDROME_FRGMT_1, bchData[1], sector);
+        ELM_setSyndromeFragment(attrs->elmBaseAddr, ELM_SYNDROME_FRGMT_2, bchData[2], sector);
+        ELM_setSyndromeFragment(attrs->elmBaseAddr, ELM_SYNDROME_FRGMT_3, bchData[3], sector);
+
+    }
+    else
+    {
+        status =  SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_eccBchStartErrorProcessing(GPMC_Handle handle, uint8_t sector)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+
+        /* Start ELM error processing. */
+        ELM_errorLocationProcessingStart(attrs->elmBaseAddr, sector);
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_eccBchCheckErrorProcessingStatus(GPMC_Handle handle, uint32_t sector)
+{
+    int32_t status = SystemP_SUCCESS;
+    uint64_t curTime;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+
+        curTime = ClockP_getTimeUsec();
+
+        /* Check ELM error processing status with timeout. */
+        while((ELM_interuptStatusGet(attrs->elmBaseAddr, sector) == ELM_BIT_SET_LOW) &&
+        ((ClockP_getTimeUsec() - curTime) < GPMC_ELM_ERR_STATUS_TIMEOUT_MAX))
+        {
+            /* Do nothing. */
+        }
+
+        if(ELM_interuptStatusGet(attrs->elmBaseAddr, sector) == ELM_BIT_SET_LOW)
+        {
+            status = SystemP_FAILURE;
+        }
+        else
+        {
+            ELM_interuptStatusClear(attrs->elmBaseAddr, sector);
+        }
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_eccBchSectorGetError(GPMC_Handle handle, uint32_t sector, uint32_t *errCount, uint32_t *errLoc)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        /* Get number of errors located by ELM per sector. */
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+
+        if(status == SystemP_SUCCESS)
+        {
+            if (ELM_errorLocationProcessingStatusGet(attrs->elmBaseAddr, sector) > 0U)
+            {
+                uint32_t count;
+
+                *errCount = ELM_getNumError(attrs->elmBaseAddr, sector);
+                for (count = 0; count < *errCount; count++)
+                {
+                    errLoc[count] = ELM_errorLocationBitAddrGet(attrs->elmBaseAddr, count, sector);
+                }
+            }
+            else
+            {
+                status = SystemP_FAILURE;
+            }
+        }
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_eccCalculateBchSyndromePolynomial(GPMC_Handle handle, uint8_t *pEccdata, uint32_t sector)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        uint32_t eccRes;
+        /* Get BCH syndrome polynomial per sector. */
+        eccRes = GPMC_eccBchResultGet(handle, GPMC_BCH_RESULT3, sector);
+        pEccdata[0] = (eccRes & 0xFF);
+
+        eccRes = GPMC_eccBchResultGet(handle, GPMC_BCH_RESULT2, sector);
+        pEccdata[1] = ((eccRes >> 24) & 0xFF);
+        pEccdata[2] = ((eccRes >> 16) & 0xFF);
+        pEccdata[3] = ((eccRes >> 8) & 0xFF);
+        pEccdata[4] = (eccRes & 0xFF);
+
+        eccRes = GPMC_eccBchResultGet(handle, GPMC_BCH_RESULT1, sector);
+        pEccdata[5] = ((eccRes >> 24) & 0xFF);
+        pEccdata[6] = ((eccRes >> 16) & 0xFF);
+        pEccdata[7] = ((eccRes >> 8) & 0xFF);
+        pEccdata[8] = (eccRes & 0xFF);
+
+        eccRes = GPMC_eccBchResultGet(handle, GPMC_BCH_RESULT0, sector);
+        pEccdata[9] = ((eccRes >> 24) & 0xFF);
+        pEccdata[10] = ((eccRes >> 16) & 0xFF);
+        pEccdata[11] = ((eccRes >> 8) & 0xFF);
+        pEccdata[12] = (eccRes & 0xFF);
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_disableFlashWriteProtect(GPMC_Handle handle)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+        /* Disable write protect. */
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_CONFIG, GPMC_CONFIG_WRITEPROTECT, \
+                        CSL_GPMC_CONFIG_WRITEPROTECT_WPHIGH);
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+int32_t GPMC_enableFlashWriteProtect(GPMC_Handle handle)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+
+        /* Enable Write protect. */
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_CONFIG, GPMC_CONFIG_WRITEPROTECT, \
+                        CSL_GPMC_CONFIG_WRITEPROTECT_WPHIGH);
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+uint32_t GPMC_getInputClk(GPMC_Handle handle)
+{
+    uint32_t retVal = 0U;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        /* Get GPMC interface clock. */
+        const GPMC_HwAttrs* attrs = ((GPMC_Config *)handle)->attrs;
+        retVal = attrs->inputClkFreq;
+    }
+    return retVal;
+}
+
+/* ========================================================================== */
+/*                     Internal function definitions                          */
+/* ========================================================================== */
+
+static void GPMC_isr(void *arg)
+{
+    /* Currently interupt mode not supported.*/
+}
+
+static int32_t GPMC_moduleResetStatusWaitTimeout(GPMC_Config *config, uint32_t timeOut)
+{
+    int32_t status  =   SystemP_SUCCESS;
+    const GPMC_HwAttrs *hwAttrs = config->attrs;
+    uint64_t curTime = 0;
+
+    if(timeOut != 0)
+    {
+        curTime = ClockP_getTimeUsec();
+        /* Check for GPMC module reset status with timeout. */
+        while((CSL_REG32_FEXT(hwAttrs->gpmcBaseAddr + CSL_GPMC_SYSSTATUS, GPMC_SYSSTATUS_RESETDONE) != CSL_GPMC_SYSSTATUS_RESETDONE_RSTDONE) &&
+            ((ClockP_getTimeUsec() - curTime) < timeOut))
+        {
+
+        }
+
+        if(CSL_REG32_FEXT(hwAttrs->gpmcBaseAddr + CSL_GPMC_SYSSTATUS, GPMC_SYSSTATUS_RESETDONE) != CSL_GPMC_SYSSTATUS_RESETDONE_RSTDONE)
+        {
+            return SystemP_FAILURE;
+        }
+
+    }
+    else
+    {
+        if(CSL_REG32_FEXT(hwAttrs->gpmcBaseAddr + CSL_GPMC_SYSSTATUS, GPMC_SYSSTATUS_RESETDONE) != CSL_GPMC_SYSSTATUS_RESETDONE_RSTDONE)
+        {
+            return SystemP_FAILURE;
+        }
+    }
+
+    return status;
+
+ }
+
+static uint32_t GPMC_waitPinStatusGet(uint32_t baseAddr, uint32_t pin)
+{
+    uint32_t pinStatus;
+
+    pinStatus = 0;
+    /* Check WAIT PIN status. */
+    if (pin == CSL_GPMC_CONFIG1_WAITPINSELECT_W0)
+    {
+        pinStatus = CSL_REG32_FEXT(baseAddr + CSL_GPMC_STATUS,
+                                  GPMC_STATUS_WAIT0STATUS);
+    }
+    else if (pin == CSL_GPMC_CONFIG1_WAITPINSELECT_W1)
+    {
+        pinStatus = CSL_REG32_FEXT(baseAddr + CSL_GPMC_STATUS,
+                                  GPMC_STATUS_WAIT1STATUS);
+    }
+    else
+    {
+        /*
+         * Do nothing. Error will be generated by the hardware
+         */
+    }
+
+    return (pinStatus);
+}
+
+static int32_t GPMC_waitPinStatusReadyWaitTimeout(GPMC_Handle handle, uint32_t timeOut)
+{
+
+    int32_t status  =   SystemP_SUCCESS;
+    const GPMC_HwAttrs *hwAttrs = NULL;
+    uint64_t curTime= 0;
+
+    if(handle != NULL)
+    {
+        hwAttrs = ((GPMC_Config*)handle)->attrs;
+        
+        if(timeOut != 0)
+        {
+            curTime = ClockP_getTimeUsec();
+            /* Check WAIT PIN status with timeout. */
+            while((GPMC_waitPinStatusGet(hwAttrs->gpmcBaseAddr,hwAttrs->waitPinNum) == \
+            CSL_GPMC_STATUS_WAIT0STATUS_W0ACTIVEL) && ((ClockP_getTimeUsec() - curTime) < timeOut))
+            {
+                /* Do nothing. */
+            }
+
+            if((GPMC_waitPinStatusGet(hwAttrs->gpmcBaseAddr,hwAttrs->waitPinNum) == \
+            CSL_GPMC_STATUS_WAIT0STATUS_W0ACTIVEH))
+            {
+                status = SystemP_SUCCESS;
+            }
+            else
+            {
+                status = SystemP_FAILURE;
+            }
+        }
+        else
+        {
+            if((GPMC_waitPinStatusGet(hwAttrs->gpmcBaseAddr,hwAttrs->waitPinNum) == \
+            CSL_GPMC_STATUS_WAIT0STATUS_W0ACTIVEH))
+            {
+                status = SystemP_SUCCESS;
+            }
+            else
+            {
+                status = SystemP_FAILURE;
+            }
+        }
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+
+ }
+
+static int32_t GPMC_waitPinInteruptStatusReadyWaitTimeout(GPMC_Handle handle, uint32_t timeOut)
+{
+    int32_t status  =   SystemP_SUCCESS;
+    uint32_t waitPinInterupt = 0;
+    uint64_t curTime = 0;
+
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+
+        if(hwAttrs->waitPinNum == CSL_GPMC_CONFIG1_WAITPINSELECT_W0)
+        {
+            waitPinInterupt = GPMC_WAIT0EDGEDETECTION_STATUS;
+        }
+        else if(hwAttrs->waitPinNum == CSL_GPMC_CONFIG1_WAITPINSELECT_W1)
+        {
+            waitPinInterupt = GPMC_WAIT1EDGEDETECTION_STATUS;
+        }
+
+        if(timeOut != 0)
+        {
+
+            curTime = ClockP_getTimeUsec();
+            /* Check WAIT PIN interupt status with timeout.*/
+            while((GPMC_interuptStatusGet(hwAttrs->gpmcBaseAddr,waitPinInterupt) == 0) \
+            && ((ClockP_getTimeUsec() - curTime) < timeOut))
+            {
+                /* Do nothing.*/
+            }
+
+
+            if(GPMC_interuptStatusGet(hwAttrs->gpmcBaseAddr,waitPinInterupt) == 1)
+            {
+                status = SystemP_SUCCESS;
+            }
+            else
+            {
+                status = SystemP_FAILURE;
+            }
+
+        }
+        else
+        {
+            if(GPMC_interuptStatusGet(hwAttrs->gpmcBaseAddr,hwAttrs->waitPinNum) == 1)
+            {
+                status = SystemP_SUCCESS;
+            }
+            else
+            {
+                status = SystemP_FAILURE;
+            }
+        }
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+
+ }
+
+static void GPMC_waitPinPolaritySelect(GPMC_Handle handle, uint32_t pin,
+                                uint32_t polarity)
+{
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+        /* Select WAIT PIN polarity. */
+        if (pin == CSL_GPMC_CONFIG1_WAITPINSELECT_W0)
+        {
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG, GPMC_CONFIG_WAIT0PINPOLARITY,
+                        polarity);
+        }
+        else if (pin == CSL_GPMC_CONFIG1_WAITPINSELECT_W1)
+        {
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG, GPMC_CONFIG_WAIT1PINPOLARITY,
+                        polarity);
+        }
+        else
+        {
+            /*
+            * Do nothing. Error will be generated by the hardware
+            */
+        }
+    }
+}
+
+
+static uint32_t  GPMC_interuptStatusGet(uint32_t baseAddr, uint32_t interupt)
+{
+    uint32_t retVal;
+
+    retVal = 0;
+    /* Get GPMC interupt status. */
+    switch (interupt)
+    {
+        case GPMC_FIFOEVENT_STATUS:
+            retVal = CSL_REG32_FEXT(baseAddr + CSL_GPMC_IRQSTATUS,
+                                   GPMC_IRQSTATUS_FIFOEVENTSTATUS);
+            break;
+        case GPMC_TERMINALCOUNT_STATUS:
+            retVal = CSL_REG32_FEXT(baseAddr + CSL_GPMC_IRQSTATUS,
+                                   GPMC_IRQSTATUS_TERMINALCOUNTSTATUS);
+            break;
+        case GPMC_WAIT0EDGEDETECTION_STATUS:
+            retVal = CSL_REG32_FEXT(baseAddr + CSL_GPMC_IRQSTATUS,
+                                   GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS);
+            break;
+        case GPMC_WAIT1EDGEDETECTION_STATUS:
+            retVal = CSL_REG32_FEXT(baseAddr + CSL_GPMC_IRQSTATUS,
+                                   GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS);
+            break;
+
+        default:
+            break;
+    }
+
+    return (retVal);
+}
+
+static void GPMC_interuptStatusClear(uint32_t baseAddr, uint32_t interupt)
+{
+    /* Clear GPMC interupt status. */
+    switch (interupt)
+    {
+        case GPMC_FIFOEVENT_STATUS:
+            CSL_REG32_FINS(baseAddr + CSL_GPMC_IRQSTATUS,
+                          GPMC_IRQSTATUS_FIFOEVENTSTATUS,
+                          CSL_GPMC_IRQSTATUS_FIFOEVENTSTATUS_FIFOSTAT1_W);
+            break;
+        case GPMC_TERMINALCOUNT_STATUS:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQSTATUS, GPMC_IRQSTATUS_TERMINALCOUNTSTATUS,
+                CSL_GPMC_IRQSTATUS_TERMINALCOUNTSTATUS_TCSTAT1_W);
+            break;
+        case GPMC_WAIT0EDGEDETECTION_STATUS:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQSTATUS,
+                GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS,
+                CSL_GPMC_IRQSTATUS_WAIT0EDGEDETECTIONSTATUS_W0DET1_W);
+            break;
+        case GPMC_WAIT1EDGEDETECTION_STATUS:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQSTATUS,
+                GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS,
+                CSL_GPMC_IRQSTATUS_WAIT1EDGEDETECTIONSTATUS_W1DET1_W);
+            break;
+
+        default:
+            break;
+    }
+}
+
+static void GPMC_enableInterupt(uint32_t baseAddr, uint32_t interupt)
+{
+    /* Enable GPMC interupt. */
+    switch (interupt)
+    {
+        case GPMC_FIFOEVENT_INT:
+            CSL_REG32_FINS(baseAddr + CSL_GPMC_IRQENABLE,
+                          GPMC_IRQENABLE_FIFOEVENTENABLE,
+                          CSL_GPMC_IRQENABLE_FIFOEVENTENABLE_FIFOENABLED);
+            break;
+        case GPMC_TERMINALCOUNT_INT:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQENABLE,
+                GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE,
+                CSL_GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE_TCENABLED);
+            break;
+        case GPMC_WAIT0EDGEDETECTION_INT:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQENABLE,
+                GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE,
+                CSL_GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE_W0ENABLED);
+            break;
+        case GPMC_WAIT1EDGEDETECTION_INT:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQENABLE,
+                GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE,
+                CSL_GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE_W1ENABLED);
+            break;
+
+        default:
+            break;
+    }
+}
+
+static void GPMC_disableInterupt(uint32_t baseAddr, uint32_t interupt)
+{
+    /* Disable GPMC interupt. */
+    switch (interupt)
+    {
+        case GPMC_FIFOEVENT_INT:
+            CSL_REG32_FINS(baseAddr + CSL_GPMC_IRQENABLE,
+                          GPMC_IRQENABLE_FIFOEVENTENABLE,
+                          CSL_GPMC_IRQENABLE_FIFOEVENTENABLE_FIFOMASKED);
+            break;
+        case GPMC_TERMINALCOUNT_INT:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQENABLE,
+                GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE,
+                CSL_GPMC_IRQENABLE_TERMINALCOUNTEVENTENABLE_TCMASKED);
+            break;
+        case GPMC_WAIT0EDGEDETECTION_INT:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQENABLE,
+                GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE,
+                CSL_GPMC_IRQENABLE_WAIT0EDGEDETECTIONENABLE_W0MASKED);
+            break;
+        case GPMC_WAIT1EDGEDETECTION_INT:
+            CSL_REG32_FINS(
+                baseAddr + CSL_GPMC_IRQENABLE,
+                GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE,
+                CSL_GPMC_IRQENABLE_WAIT1EDGEDETECTIONENABLE_W1MASKED);
+            break;
+
+        default:
+            break;
+    }
+}
+
+static int32_t GPMC_programInstance(GPMC_Config *config)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    if(config != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = config->attrs;
+        GPMC_Object *object  = config->object;
+
+        /* Reset GPMC */
+        CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_SYSCONFIG, GPMC_SYSCONFIG_SOFTRESET,CSL_GPMC_SYSCONFIG_SOFTRESET_RESET);
+
+        status += GPMC_moduleResetStatusWaitTimeout(config,GPMC_MODULE_RESET_WAIT_TIME_MAX);
+
+        if(status == SystemP_SUCCESS)
+        {
+            /*set GPMC in NORMAL mode*/
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_SYSCONFIG, GPMC_SYSCONFIG_SOFTRESET,CSL_GPMC_SYSCONFIG_SOFTRESET_NORMAL);
+
+            /* Disable all interrupts */
+            GPMC_disableInterupt(hwAttrs->gpmcBaseAddr,GPMC_FIFOEVENT_INT);
+            GPMC_disableInterupt(hwAttrs->gpmcBaseAddr,GPMC_TERMINALCOUNT_INT);
+            GPMC_disableInterupt(hwAttrs->gpmcBaseAddr,GPMC_WAIT0EDGEDETECTION_INT);
+            GPMC_disableInterupt(hwAttrs->gpmcBaseAddr,GPMC_WAIT1EDGEDETECTION_INT);
+
+            /* Disable Chip select*/
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG7(object->params.chipSel), GPMC_CONFIG7_CSVALID, CSL_GPMC_CONFIG7_CSVALID_CSDISABLED);
+
+            /* Timeout control disable */
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_TIMEOUT_CONTROL,
+                        GPMC_TIMEOUT_CONTROL_TIMEOUTENABLE,
+                        CSL_GPMC_TIMEOUT_CONTROL_TIMEOUTENABLE_TODISABLED);
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_TIMEOUT_CONTROL,
+                        GPMC_TIMEOUT_CONTROL_TIMEOUTSTARTVALUE, 0);
+            /* Set CONFIG 1 Parameters*/
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                        GPMC_CONFIG1_GPMCFCLKDIVIDER, hwAttrs->clkDivider );
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                        GPMC_CONFIG1_MUXADDDATA,  hwAttrs->addrDataMux);
+
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                        GPMC_CONFIG1_WAITMONITORINGTIME, CSL_GPMC_CONFIG1_WAITMONITORINGTIME_ATVALID);
+
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                        GPMC_CONFIG1_WAITREADMONITORING, CSL_GPMC_CONFIG1_WAITREADMONITORING_WNOTMONIT);
+
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                        GPMC_CONFIG1_READTYPE, hwAttrs->readType);
+
+            /* Set the wait pin polarity */
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                        GPMC_CONFIG1_WAITPINSELECT,  hwAttrs->waitPinNum);
+            /* Set the Time granularity */
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                        GPMC_CONFIG1_TIMEPARAGRANULARITY, hwAttrs->timeLatency);
+
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG1(object->params.chipSel),
+                        GPMC_CONFIG1_READMULTIPLE,  hwAttrs->accessType);
+
+            /* Set chip select address*/
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG7(object->params.chipSel),
+                        GPMC_CONFIG7_BASEADDRESS, (hwAttrs->chipSelBaseAddr >> GPMC_CS_BASE_ADDR_SHIFT) & 0x3fU);
+
+            /* Set chip select address */
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG7(object->params.chipSel),
+                        GPMC_CONFIG7_MASKADDRESS,  hwAttrs->chipSelAddrSize);
+
+            /* Set Wait pin polarity*/
+            GPMC_waitPinPolaritySelect((GPMC_Handle*)config, hwAttrs->waitPinNum, hwAttrs->waitPinPol);
+
+            GPMC_interuptStatusClear(hwAttrs->gpmcBaseAddr,GPMC_WAIT0EDGEDETECTION_STATUS);
+            /* Enable interupt for the WAIT PIN*/
+            GPMC_enableInterupt(hwAttrs->gpmcBaseAddr,GPMC_WAIT0EDGEDETECTION_INT);
+            /* Enable CHIP SELECT*/
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_CONFIG7(object->params.chipSel), \
+                            GPMC_CONFIG7_CSVALID, CSL_GPMC_CONFIG7_CSVALID_CSENABLED);
+
+            status += GPMC_waitPinStatusReadyWaitTimeout((GPMC_Handle)config, GPMC_WAIT_PIN_STATUS_WAIT_TIME_MAX);
+        }
+
+    }
+
+    return status;
+}
+
+
+static void GPMC_transferCallback(GPMC_Handle handle, GPMC_Transaction *msg)
+{
+    GPMC_Object   *object; /* GPMC object */
+
+    /* Input parameter validation */
+    if (handle != NULL)
+    {
+        /* Get the pointer to the object. */
+        object = ((GPMC_Config*)handle)->object;
+
+        /* Indicate transfer complete. */
+        SemaphoreP_post(&object->transferComplete);
+    }
+}
+
+static int32_t GPMC_prefetchPostWriteConfigEnable(GPMC_Handle handle, uint8_t mode,
+                                                uint32_t transferCount, uint8_t modeDMA)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+
+        if(mode == GPMC_PREFETCH_ACCESSMODE_READ)
+        {
+            /* Set PREFETCH/POST write engine to read mode. */
+            CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_ACCESSMODE, \
+            CSL_GPMC_PREFETCH_CONFIG1_ACCESSMODE_PREFETCHREAD);
+
+            if(modeDMA)
+            {
+                /* Enable DMA sync bit for READ operation. */
+                CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_DMAMODE, \
+                CSL_GPMC_PREFETCH_CONFIG1_DMAMODE_DMAREQSYNC);
+            }
+
+        }
+        else
+        {
+            /* Set PREFETCH/POST write engine to write mode. */
+            CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_ACCESSMODE, \
+            CSL_GPMC_PREFETCH_CONFIG1_ACCESSMODE_WRITEPOSTING);
+        }
+
+        /*Set transfer count*/
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG2, GPMC_PREFETCH_CONFIG2_TRANSFERCOUNT, \
+        transferCount);
+
+        /*Enable the engine */
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_ENABLEENGINE, \
+        CSL_GPMC_PREFETCH_CONFIG1_ENABLEENGINE_PPENABLED);
+
+        /*Start the prefetch engine*/
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONTROL, GPMC_PREFETCH_CONTROL_STARTENGINE, \
+        CSL_GPMC_PREFETCH_CONTROL_STARTENGINE_START);
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+static int32_t GPMC_prefetchPostWriteConfigDisable(GPMC_Handle handle)
+{
+    int32_t status = SystemP_SUCCESS;
+
+    /* Input parameter validation */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+
+        /*Disable and stop the prefetch engine*/
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONTROL, GPMC_PREFETCH_CONTROL_STARTENGINE, \
+        CSL_GPMC_PREFETCH_CONTROL_STARTENGINE_STOP);
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_ENABLEENGINE, \
+        CSL_GPMC_PREFETCH_CONFIG1_ENABLEENGINE_PPDISABLED);
+        /* Disable DMA sync bit. */
+        CSL_REG32_FINS(attrs->gpmcBaseAddr + CSL_GPMC_PREFETCH_CONFIG1, GPMC_PREFETCH_CONFIG1_DMAMODE, \
+                CSL_GPMC_PREFETCH_CONFIG1_DMAMODE_RESETVAL);
+
+    }
+    else
+    {
+        status = SystemP_FAILURE;
+    }
+
+    return status;
+}
+
+static int32_t GPMC_isDmaRestrictedRegion(GPMC_Handle handle, uint32_t addr)
+{
+    int32_t isRestricted = FALSE;
+    const GPMC_HwAttrs *attrs = ((GPMC_Config *)handle)->attrs;
+
+    if(NULL != attrs->dmaRestrictedRegions)
+    {
+        const GPMC_AddrRegion *addrRegions = attrs->dmaRestrictedRegions;
+        uint32_t i = 0;
+        uint32_t start;
+        uint32_t size;
+
+        /* Check for DMA restricted regions. */
+        while(addrRegions[i].regionStartAddr != 0xFFFFFFFF)
+        {
+            start = addrRegions[i].regionStartAddr;
+            size = addrRegions[i].regionSize;
+
+            if((addr >= start) && (addr < (start + size)))
+            {
+                isRestricted = TRUE;
+                break;
+            }
+            i++;
+        }
+    }
+
+    return isRestricted;
+}
+
+static void GPMC_nandCommandWrite(GPMC_Handle handle, uint32_t cmd)
+{
+    /* Input parameter validation */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+        GPMC_Object *object = ((GPMC_Config*)handle)->object;
+        /* Set NAND command. */
+        CSL_REG8_WR(hwAttrs->gpmcBaseAddr + CSL_GPMC_NAND_COMMAND(object->params.chipSel),
+                    cmd);
+    }
+}
+
+static void GPMC_nandAddressWrite(GPMC_Handle handle, uint32_t address)
+{
+    /* Input parameter validation */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+        GPMC_Object *object = ((GPMC_Config*)handle)->object;
+        /* Set NAND address. */
+        CSL_REG8_WR(hwAttrs->gpmcBaseAddr + CSL_GPMC_NAND_ADDRESS(object->params.chipSel),
+                    address);
+    }
+}
+
+static void GPMC_eccResultSizeSelect(GPMC_Handle handle, uint32_t eccResReg,
+                             uint32_t eccSize)
+{
+    const GPMC_HwAttrs *hwAttrs = ((GPMC_Config*)handle)->attrs;
+
+    /* Set ECC size for ECC result register. */
+    switch (eccResReg)
+    {
+        case GPMC_ECC_RESULT_1:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC1RESULTSIZE,
+                          eccSize);
+            break;
+        case GPMC_ECC_RESULT_2:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC2RESULTSIZE,
+                          eccSize);
+            break;
+        case GPMC_ECC_RESULT_3:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC3RESULTSIZE,
+                          eccSize);
+            break;
+        case GPMC_ECC_RESULT_4:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC4RESULTSIZE,
+                          eccSize);
+            break;
+        case GPMC_ECC_RESULT_5:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC5RESULTSIZE,
+                          eccSize);
+            break;
+        case GPMC_ECC_RESULT_6:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC6RESULTSIZE,
+                          eccSize);
+            break;
+        case GPMC_ECC_RESULT_7:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC7RESULTSIZE,
+                          eccSize);
+            break;
+        case GPMC_ECC_RESULT_8:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC8RESULTSIZE,
+                          eccSize);
+            break;
+        case GPMC_ECC_RESULT_9:
+            CSL_REG32_FINS(hwAttrs->gpmcBaseAddr + CSL_GPMC_ECC_SIZE_CONFIG,
+                          GPMC_ECC_SIZE_CONFIG_ECC9RESULTSIZE,
+                          eccSize);
+            break;
+
+        default:
+            break;
+    }
+}
+
+static uint32_t GPMC_eccBchResultGet(GPMC_Handle handle, uint32_t resIndex , uint32_t sector)
+{
+    uint32_t result = 0;
+
+    /* Input parameter validation. */
+    if(handle != NULL)
+    {
+        const GPMC_HwAttrs *attrs = ((GPMC_Config*)handle)->attrs;
+
+        /* Get BCH syndrome polynomial per sector. */
+        switch (resIndex)
+        {
+            case GPMC_BCH_RESULT0:
+                result = CSL_REG32_RD(attrs->gpmcBaseAddr + CSL_GPMC_BCH_RESULT_0(sector));
+                break;
+            case GPMC_BCH_RESULT1:
+                result = CSL_REG32_RD(attrs->gpmcBaseAddr + CSL_GPMC_BCH_RESULT_1(sector));
+                break;
+            case GPMC_BCH_RESULT2:
+                result = CSL_REG32_RD(attrs->gpmcBaseAddr + CSL_GPMC_BCH_RESULT_2(sector));
+                break;
+            case GPMC_BCH_RESULT3:
+                result = CSL_REG32_RD(attrs->gpmcBaseAddr + CSL_GPMC_BCH_RESULT_3(sector));
+                break;
+            case GPMC_BCH_RESULT4:
+                result = CSL_REG32_RD(attrs->gpmcBaseAddr + CSL_GPMC_BCH_RESULT_4(sector));
+                break;
+            case GPMC_BCH_RESULT5:
+                result = CSL_REG32_RD(attrs->gpmcBaseAddr + CSL_GPMC_BCH_RESULT_5(sector));
+                break;
+            case GPMC_BCH_RESULT6:
+                result = CSL_REG32_RD(attrs->gpmcBaseAddr + CSL_GPMC_BCH_RESULT_6(sector));
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    return (result);
+}

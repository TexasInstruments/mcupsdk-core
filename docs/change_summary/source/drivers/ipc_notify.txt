diff --git a/source/drivers/ipc_notify/v0/ipc_notify_v0.c b/source/drivers/ipc_notify/v0/ipc_notify_v0.c
index 40450e354d..1eb0176222 100755
--- a/source/drivers/ipc_notify/v0/ipc_notify_v0.c
+++ b/source/drivers/ipc_notify/v0/ipc_notify_v0.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -57,49 +57,47 @@ typedef struct
 
 IpcNotify_Ctrl gIpcNotifyCtrl;
 
+/**
+ * \brief Callback to call when interrupt is received
+ */
+void IpcNotify_isr(void *args);
+
+/**
+ * \brief Callback that is invoked during initialization for a given client ID
+ *
+ * \param remoteCoreId  [in] Remote core that has sent the message
+ * \param localClientId [in] Local client ID to which the message is sent
+ * \param msgValue      [in] Message value that is sent
+ * \param args          [in] Argument pointer passed by user when \ref IpcNotify_registerClient is called
+ */
+void IpcNotify_syncCallback(uint32_t remoteCoreId, uint16_t localClientId, uint32_t msgValue, void *args);
 
 static inline void IpcNotify_getWriteMailbox(uint32_t remoteCoreId, uint32_t *mailboxBaseAddr, uint32_t *hwFifoId)
 {
     IpcNotify_MailboxConfig *pMailboxConfig;
 
-    if(gIpcNotifyCtrl.selfCoreId < CSL_CORE_ID_MAX && remoteCoreId < CSL_CORE_ID_MAX)
-    {
-        pMailboxConfig = &gIpcNotifyMailboxConfig[gIpcNotifyCtrl.selfCoreId][remoteCoreId];
+    pMailboxConfig = &gIpcNotifyMailboxConfig[gIpcNotifyCtrl.selfCoreId][remoteCoreId];
+
+    *mailboxBaseAddr = gIpcNotifyMailboxBaseAddr[ pMailboxConfig->mailboxId ];
+    *hwFifoId = pMailboxConfig->hwFifoId;
 
-        *mailboxBaseAddr = gIpcNotifyMailboxBaseAddr[ pMailboxConfig->mailboxId ];
-        *hwFifoId = pMailboxConfig->hwFifoId;
-    }
-    else
-    {
-        *mailboxBaseAddr = NULL;
-        *hwFifoId = 0;
-    }
 }
 
 static inline void IpcNotify_getReadMailbox(uint32_t remoteCoreId, uint32_t *mailboxBaseAddr, uint32_t *hwFifoId, uint32_t *userId)
 {
     IpcNotify_MailboxConfig *pMailboxConfig;
 
-    if(gIpcNotifyCtrl.selfCoreId < CSL_CORE_ID_MAX && remoteCoreId < CSL_CORE_ID_MAX)
-    {
-        pMailboxConfig = &gIpcNotifyMailboxConfig[remoteCoreId][gIpcNotifyCtrl.selfCoreId];
+    pMailboxConfig = &gIpcNotifyMailboxConfig[remoteCoreId][gIpcNotifyCtrl.selfCoreId];
 
-        *mailboxBaseAddr = gIpcNotifyMailboxBaseAddr[ pMailboxConfig->mailboxId ];
-        *hwFifoId = pMailboxConfig->hwFifoId;
-        *userId = pMailboxConfig->userId;
-    }
-    else
-    {
-        *mailboxBaseAddr = NULL;
-        *hwFifoId = 0;
-        *userId = 0;
-    }
+    *mailboxBaseAddr = gIpcNotifyMailboxBaseAddr[ pMailboxConfig->mailboxId ];
+    *hwFifoId = pMailboxConfig->hwFifoId;
+    *userId = pMailboxConfig->userId;
 }
 
 static inline uint32_t IpcNotify_makeMsg(uint16_t clientId, uint32_t msgValue)
 {
-    return ((clientId & (IPC_NOTIFY_CLIENT_ID_MAX-1)) << IPC_NOTIFY_CLIENT_ID_SHIFT) |
-            (msgValue & (IPC_NOTIFY_MSG_VALUE_MAX-1))
+    return ((clientId & (IPC_NOTIFY_CLIENT_ID_MAX-1U)) << IPC_NOTIFY_CLIENT_ID_SHIFT) |
+            (msgValue & (IPC_NOTIFY_MSG_VALUE_MAX-1U))
             ;
 }
 
@@ -113,7 +111,7 @@ void IpcNotify_isr(void *args)
     for(core=0; core<pInterruptConfig->numCores; core++)
     {
         IpcNotify_getReadMailbox(pInterruptConfig->coreIdList[core], &mailboxBaseAddr, &hwFifoId, &userId);
-        DebugP_assertNoLog(mailboxBaseAddr!=NULL);
+        DebugP_assertNoLog(mailboxBaseAddr!=0U);
 
         IpcNotify_mailboxClearInt(mailboxBaseAddr, hwFifoId, userId);
         numMsgs = IpcNotify_mailboxGetNumMsg(mailboxBaseAddr, hwFifoId);
@@ -121,14 +119,14 @@ void IpcNotify_isr(void *args)
         for(msg=0; msg<numMsgs; msg++)
         {
             value = IpcNotify_mailboxRead(mailboxBaseAddr, hwFifoId);
-            clientId = (value >> IPC_NOTIFY_CLIENT_ID_SHIFT) & (IPC_NOTIFY_CLIENT_ID_MAX-1);
+            clientId = (value >> IPC_NOTIFY_CLIENT_ID_SHIFT) & (IPC_NOTIFY_CLIENT_ID_MAX-1U);
 
             if(gIpcNotifyCtrl.callback[clientId]!=NULL)
             {
                 gIpcNotifyCtrl.callback[clientId](
                         pInterruptConfig->coreIdList[core],
                         clientId,
-                        (value & (IPC_NOTIFY_MSG_VALUE_MAX-1)),
+                        (value & (IPC_NOTIFY_MSG_VALUE_MAX-1U)),
                         gIpcNotifyCtrl.callbackArgs[clientId]
                         );
             }
@@ -142,24 +140,24 @@ int32_t IpcNotify_sendMsg(uint32_t remoteCoreId, uint16_t remoteClientId, uint32
     uint32_t mailboxBaseAddr, hwFifoId;
     int32_t status = SystemP_FAILURE;
 
-    if(remoteCoreId < CSL_CORE_ID_MAX && gIpcNotifyCtrl.isCoreEnabled[remoteCoreId])
+    if((remoteCoreId < CSL_CORE_ID_MAX) && (gIpcNotifyCtrl.isCoreEnabled[remoteCoreId] != 0U))
     {
         IpcNotify_getWriteMailbox(remoteCoreId, &mailboxBaseAddr, &hwFifoId);
-        DebugP_assert(mailboxBaseAddr!=NULL);
+        DebugP_assert(mailboxBaseAddr!= 0U);
 
         oldIntState = HwiP_disable();
         do
         {
             isFull = IpcNotify_mailboxIsFull(mailboxBaseAddr, hwFifoId);
-            if(isFull && waitForFifoNotFull)
+            if((isFull != (uint32_t)SystemP_SUCCESS) && (waitForFifoNotFull != 0U))
             {
                 /* allow interrupt enable and check again */
                 HwiP_restore(oldIntState);
                 oldIntState = HwiP_disable();
             }
-        } while(isFull && waitForFifoNotFull);
+        } while((isFull != (uint32_t)SystemP_SUCCESS) && (waitForFifoNotFull != 0U));
 
-        if(!isFull)
+        if(isFull == 0U)
         {
             uint32_t value = IpcNotify_makeMsg(remoteClientId, msgValue);
             IpcNotify_mailboxWrite(mailboxBaseAddr, hwFifoId, value);
@@ -179,6 +177,8 @@ int32_t IpcNotify_registerClient(uint16_t localClientId, IpcNotify_FxnCallback m
     int32_t status = SystemP_FAILURE;
     uint32_t oldIntState;
 
+    DebugP_assert(msgCallback != NULL);
+
     if(localClientId < IPC_NOTIFY_CLIENT_ID_MAX)
     {
         oldIntState = HwiP_disable();
@@ -220,6 +220,7 @@ void IpcNotify_Params_init(IpcNotify_Params *params)
 {
     uint32_t i;
 
+    params->intrPriority = IPC_NOTIFY_DEFAULT_INTR_PRIORITY;
     params->numCores = 0;
     for(i=0; i<CSL_CORE_ID_MAX; i++)
     {
@@ -240,12 +241,12 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
     IpcNotify_getConfig(&gIpcNotifyCtrl.interruptConfig, &gIpcNotifyCtrl.interruptConfigNum);
 
     /* translate mailbox address to local CPU addresses */
-    for(i=0; gIpcNotifyMailboxBaseAddr[i]!=0; i++)
+    for(i=0; gIpcNotifyMailboxBaseAddr[i]!=0U; i++)
     {
         gIpcNotifyMailboxBaseAddr[i] = (uint32_t) AddrTranslateP_getLocalAddr(gIpcNotifyMailboxBaseAddr[i]);
     }
-
-    DebugP_assert(params->selfCoreId < CSL_CORE_ID_MAX);
+    uint32_t selfCoreId_Check = (params->selfCoreId < CSL_CORE_ID_MAX)?1U:0U;
+    DebugP_assert(selfCoreId_Check != 0U);
     gIpcNotifyCtrl.selfCoreId = params->selfCoreId;
     for(i=0; i<IPC_NOTIFY_CLIENT_ID_MAX; i++)
     {
@@ -258,10 +259,11 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
     }
 
     /* check parameters and config and assert if invalid */
-    DebugP_assert(params->numCores > 0 );
+    DebugP_assert(params->numCores > 0U);
     for(core=0; core<params->numCores; core++)
     {
-        DebugP_assert(params->coreIdList[core] < CSL_CORE_ID_MAX);
+        uint32_t coreIDlist_Check = (params->coreIdList[core] < CSL_CORE_ID_MAX)?1U:0U;
+        DebugP_assert(coreIDlist_Check!=0U);
         DebugP_assert(params->coreIdList[core] != params->selfCoreId);
         /* mark core as enabled for IPC */
         gIpcNotifyCtrl.isCoreEnabled[params->coreIdList[core]] = 1;
@@ -272,14 +274,15 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
 
         pInterruptConfig = &gIpcNotifyCtrl.interruptConfig[i];
 
-        DebugP_assert(pInterruptConfig->numCores > 0 );
+        DebugP_assert(pInterruptConfig->numCores > 0U);
         for(core=0; core<pInterruptConfig->numCores; core++)
         {
-            DebugP_assert(pInterruptConfig->coreIdList[core] < CSL_CORE_ID_MAX);
+            uint32_t coreIDlist_InterruptCheck = (pInterruptConfig->coreIdList[core] < CSL_CORE_ID_MAX)?1U:0U;
+            DebugP_assert(coreIDlist_InterruptCheck!=0U);
             DebugP_assert(pInterruptConfig->coreIdList[core] != gIpcNotifyCtrl.selfCoreId);
             /* check if mailbox info is valid for this core */
             IpcNotify_getReadMailbox(pInterruptConfig->coreIdList[core], &mailboxBaseAddr, &hwFifoId, &userId);
-            DebugP_assert(mailboxBaseAddr!=NULL);
+            DebugP_assert(mailboxBaseAddr!=0U);
         }
     }
 
@@ -296,7 +299,7 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
 
         for(core=0; core<pInterruptConfig->numCores; core++)
         {
-            if(gIpcNotifyCtrl.isCoreEnabled[pInterruptConfig->coreIdList[core]])
+            if(gIpcNotifyCtrl.isCoreEnabled[pInterruptConfig->coreIdList[core]] != 0U)
             {
                 IpcNotify_getReadMailbox(pInterruptConfig->coreIdList[core], &mailboxBaseAddr, &hwFifoId, &userId);
                 IpcNotify_mailboxClearInt(mailboxBaseAddr, hwFifoId, userId);
@@ -305,12 +308,14 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
         }
         HwiP_Params_init(&hwiParams);
         hwiParams.intNum = pInterruptConfig->intNum;
+        hwiParams.priority = params->intrPriority;
         hwiParams.callback = IpcNotify_isr;
         hwiParams.args = (void*)pInterruptConfig;
         hwiParams.eventId = pInterruptConfig->eventId;
         hwiParams.isPulse = 0; /* mailbox is level interrupt */
 
-        status |= HwiP_construct(
+        status
+        += HwiP_construct(
             &pInterruptConfig->hwiObj,
             &hwiParams);
     }
@@ -341,7 +346,7 @@ void IpcNotify_deInit(void)
 
         for(core=0; core<pInterruptConfig->numCores; core++)
         {
-            if(gIpcNotifyCtrl.isCoreEnabled[pInterruptConfig->coreIdList[core]])
+            if(gIpcNotifyCtrl.isCoreEnabled[pInterruptConfig->coreIdList[core]] != 0U)
             {
                 IpcNotify_getReadMailbox(pInterruptConfig->coreIdList[core],
                                             &mailboxBaseAddr, &hwFifoId, &userId);
@@ -385,13 +390,13 @@ int32_t IpcNotify_waitSync(uint32_t remoteCoreId, uint32_t timeout)
     int32_t status = SystemP_FAILURE;
     uint32_t startTicks, eslapedTicks, isDone;
 
-    if(remoteCoreId < CSL_CORE_ID_MAX && gIpcNotifyCtrl.isCoreEnabled[remoteCoreId])
+    if((remoteCoreId < CSL_CORE_ID_MAX) && (gIpcNotifyCtrl.isCoreEnabled[remoteCoreId] != 0U))
     {
         startTicks = ClockP_getTicks();
         isDone = 0;
-        while(!isDone)
+        while(isDone == 0U)
         {
-            if(gIpcNotifyCtrl.syncMsgPend[remoteCoreId] ==  0)
+            if(gIpcNotifyCtrl.syncMsgPend[remoteCoreId] ==  0U)
             {
                 eslapedTicks = ClockP_getTicks() - startTicks;
                 if(eslapedTicks>=timeout)
@@ -428,9 +433,9 @@ int32_t IpcNotify_syncAll(uint32_t timeout)
 
     for(remoteCoreId=0; remoteCoreId<CSL_CORE_ID_MAX; remoteCoreId++)
     {
-        if(gIpcNotifyCtrl.isCoreEnabled[remoteCoreId]
+        if((gIpcNotifyCtrl.isCoreEnabled[remoteCoreId] != 0U)
             &&
-            remoteCoreId != gIpcNotifyCtrl.linuxCoreId /* sync not supported with Linux */
+            (remoteCoreId != gIpcNotifyCtrl.linuxCoreId) /* sync not supported with Linux */
             )
         {
             /* no need to check return status, this will always pass */
@@ -439,9 +444,9 @@ int32_t IpcNotify_syncAll(uint32_t timeout)
     }
     for(remoteCoreId=0; remoteCoreId<CSL_CORE_ID_MAX; remoteCoreId++)
     {
-        if(gIpcNotifyCtrl.isCoreEnabled[remoteCoreId]
+        if((gIpcNotifyCtrl.isCoreEnabled[remoteCoreId] != 0U)
             &&
-            remoteCoreId != gIpcNotifyCtrl.linuxCoreId /* sync not supported with Linux */
+            (remoteCoreId != gIpcNotifyCtrl.linuxCoreId) /* sync not supported with Linux */
             )
         {
             status = IpcNotify_waitSync(remoteCoreId, timeout);
diff --git a/source/drivers/ipc_notify/v0/ipc_notify_v0_mailbox.h b/source/drivers/ipc_notify/v0/ipc_notify_v0_mailbox.h
index 3d57de2e22..3d5066151f 100755
--- a/source/drivers/ipc_notify/v0/ipc_notify_v0_mailbox.h
+++ b/source/drivers/ipc_notify/v0/ipc_notify_v0_mailbox.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -47,29 +47,29 @@ extern "C" {
 #define MAILBOX_MAX_USER                        ( 4u)
 
 /* HW mailbox register address, parameterized via base addr, hw fifo num, user id that is used */
-#define MAILBOX_MESSAGE(base, fifo)             (volatile uint32_t*)((base) + 0x040u + 0x04u*((fifo) & (MAILBOX_MAX_FIFO-1)))
-#define MAILBOX_FIFO_STATUS(base, fifo)         (volatile uint32_t*)((base) + 0x080u + 0x04u*((fifo) & (MAILBOX_MAX_FIFO-1)))
-#define MAILBOX_MSG_STATUS(base, fifo)          (volatile uint32_t*)((base) + 0x0C0u + 0x04u*((fifo) & (MAILBOX_MAX_FIFO-1)))    
-#define MAILBOX_CLEAR_INT(base, user)           (volatile uint32_t*)((base) + 0x104u + 0x10u*((user) & (MAILBOX_MAX_USER-1)))
-#define MAILBOX_ENABLE_INT(base, user)          (volatile uint32_t*)((base) + 0x108u + 0x10u*((user) & (MAILBOX_MAX_USER-1)))
-#define MAILBOX_DISABLE_INT(base, user)         (volatile uint32_t*)((base) + 0x10Cu + 0x10u*((user) & (MAILBOX_MAX_USER-1)))
+#define MAILBOX_MESSAGE(base, fifo)             (volatile uint32_t*)((base) + 0x040u + (0x04u*((fifo) & (MAILBOX_MAX_FIFO-1U))))
+#define MAILBOX_FIFO_STATUS(base, fifo)         (volatile uint32_t*)((base) + 0x080u + (0x04u*((fifo) & (MAILBOX_MAX_FIFO-1U))))
+#define MAILBOX_MSG_STATUS(base, fifo)          (volatile uint32_t*)((base) + 0x0C0u + (0x04u*((fifo) & (MAILBOX_MAX_FIFO-1U))))
+#define MAILBOX_CLEAR_INT(base, user)           (volatile uint32_t*)((base) + 0x104u + (0x10u*((user) & (MAILBOX_MAX_USER-1U))))
+#define MAILBOX_ENABLE_INT(base, user)          (volatile uint32_t*)((base) + 0x108u + (0x10u*((user) & (MAILBOX_MAX_USER-1U))))
+#define MAILBOX_DISABLE_INT(base, user)         (volatile uint32_t*)((base) + 0x10Cu + (0x10u*((user) & (MAILBOX_MAX_USER-1U))))
 #define MAILBOX_EOI_INT(base)                   (volatile uint32_t*)((base) + 0x140u)
 
 /* value to construct to enable/disable/clear mew message interrupt for a given HW fifo */
-#define MAILBOX_NEW_MSG_INT(fifo)               (uint32_t)(1 << (((fifo) & (MAILBOX_MAX_FIFO-1))*2))
+#define MAILBOX_NEW_MSG_INT(fifo)               ((uint32_t)1U << (((uint32_t)(fifo) & (uint32_t)(MAILBOX_MAX_FIFO-(uint32_t)1U))*(uint32_t)2U))
 
 /* return number of messages pending in the HW fifo to be read within a mailbox */
 static inline uint32_t IpcNotify_mailboxGetNumMsg(uint32_t mailboxBaseAddr, uint32_t hwFifoNum)
 {
     volatile uint32_t *addr = MAILBOX_MSG_STATUS(mailboxBaseAddr, hwFifoNum);
-    return *addr & (MAILBOX_MAX_MSGS_IN_FIFO-1);
+    return *addr & (MAILBOX_MAX_MSGS_IN_FIFO-1U);
 }
 
 /* check if HW fifo is full within a mailbox */
 static inline uint32_t IpcNotify_mailboxIsFull(uint32_t mailboxBaseAddr, uint32_t hwFifoNum)
 {
     volatile uint32_t *addr = MAILBOX_FIFO_STATUS(mailboxBaseAddr, hwFifoNum);
-    return *addr & 0x1;
+    return *addr & 0x1U;
 }
 
 /* read from HW fifo within a mailbox  */
diff --git a/source/drivers/ipc_notify/v0/soc/am243x/ipc_notify_v0_cfg.c b/source/drivers/ipc_notify/v0/soc/am243x/ipc_notify_v0_cfg.c
index 64173e3aa0..4797397e4e 100644
--- a/source/drivers/ipc_notify/v0/soc/am243x/ipc_notify_v0_cfg.c
+++ b/source/drivers/ipc_notify/v0/soc/am243x/ipc_notify_v0_cfg.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -37,7 +37,7 @@
 
 /* All mailbox base addresses */
 #define IPC_NOTIFY_MAILBOX_MAX_INSTANCES    (8U)
-uint32_t gIpcNotifyMailboxBaseAddr[IPC_NOTIFY_MAILBOX_MAX_INSTANCES+1] = {
+uint32_t gIpcNotifyMailboxBaseAddr[IPC_NOTIFY_MAILBOX_MAX_INSTANCES+1U] = {
     0x29000000U,
     0x29010000U,
     0x29020000U,
@@ -243,6 +243,8 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_m4fss0_0[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS1_0,
             CSL_CORE_ID_R5FSS1_1,
             CSL_CORE_ID_A53SS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
     }
 };
@@ -260,6 +262,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_0[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS1_0,
             CSL_CORE_ID_R5FSS1_1,
             CSL_CORE_ID_M4FSS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
     },
     {
@@ -268,6 +273,12 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_0[IPC_NOFTIY_INTERRUP
         .numCores = 1U,  /* number of cores that send messages which tied to this interrupt line */
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_A53SS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
     }
 };
@@ -285,6 +296,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_1[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS1_0,
             CSL_CORE_ID_R5FSS1_1,
             CSL_CORE_ID_M4FSS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
     },
     {
@@ -293,8 +307,14 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_1[IPC_NOFTIY_INTERRUP
         .numCores = 1U,  /* number of cores that send messages which tied to this interrupt line */
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_A53SS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
-    }    
+    }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss0_1 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS0_1_NUM;
 
@@ -310,6 +330,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss1_0[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS0_1,
             CSL_CORE_ID_R5FSS1_1,
             CSL_CORE_ID_M4FSS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
     },
     {
@@ -318,6 +341,12 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss1_0[IPC_NOFTIY_INTERRUP
         .numCores = 1U,  /* number of cores that send messages which tied to this interrupt line */
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_A53SS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
     }
 };
@@ -335,6 +364,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss1_1[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS0_1,
             CSL_CORE_ID_R5FSS1_0,
             CSL_CORE_ID_M4FSS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
     },
     {
@@ -343,6 +375,12 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss1_1[IPC_NOFTIY_INTERRUP
         .numCores = 1U,  /* number of cores that send messages which tied to this interrupt line */
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_A53SS0_0,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
+            CSL_CORE_ID_MAX,
         },
     }
 };
diff --git a/source/drivers/ipc_notify/v1/ipc_notify_v1.c b/source/drivers/ipc_notify/v1/ipc_notify_v1.c
index a6f19570c8..8428c82ab8 100644
--- a/source/drivers/ipc_notify/v1/ipc_notify_v1.c
+++ b/source/drivers/ipc_notify/v1/ipc_notify_v1.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -60,82 +60,86 @@ typedef struct
 
 IpcNotify_Ctrl gIpcNotifyCtrl;
 
+/**
+ * \brief Callback that is invoked during initialization for a given client ID
+ *
+ * \param remoteCoreId  [in] Remote core that has sent the message
+ * \param localClientId [in] Local client ID to which the message is sent
+ * \param msgValue      [in] Message value that is sent
+ * \param args          [in] Argument pointer passed by user when \ref IpcNotify_registerClient is called
+ */
+void IpcNotify_syncCallback(uint32_t remoteCoreId, uint16_t localClientId, uint32_t msgValue, void *args);
+
+/**
+ * \brief Callback to call when interrupt is received
+ */
+void IpcNotify_isr(void *args);
 
 static inline void IpcNotify_getWriteMailbox(uint32_t remoteCoreId, uint32_t *mailboxBaseAddr, uint32_t *intrBitPos, IpcNotify_SwQueue **swQ)
 {
     IpcNotify_MailboxConfig *pMailboxConfig;
 
-    if(gIpcNotifyCtrl.selfCoreId < CSL_CORE_ID_MAX && remoteCoreId < CSL_CORE_ID_MAX)
-    {
-        pMailboxConfig = &gIpcNotifyMailboxConfig[gIpcNotifyCtrl.selfCoreId][remoteCoreId];
+    pMailboxConfig = &gIpcNotifyMailboxConfig[gIpcNotifyCtrl.selfCoreId][remoteCoreId];
+
+    *mailboxBaseAddr = pMailboxConfig->writeDoneMailboxBaseAddr;
+    *intrBitPos = pMailboxConfig->intrBitPos;
+    *swQ = pMailboxConfig->swQ;
 
-        *mailboxBaseAddr = pMailboxConfig->writeDoneMailboxBaseAddr;
-        *intrBitPos = pMailboxConfig->intrBitPos;
-        *swQ = pMailboxConfig->swQ;
-    }
-    else
-    {
-        *mailboxBaseAddr = NULL;
-        *intrBitPos = 0;
-        *swQ = NULL;
-    }
 }
 
 static inline void IpcNotify_getReadMailbox(uint32_t *mailboxBaseAddr)
 {
     IpcNotify_MailboxConfig *pMailboxConfig;
 
-    if(gIpcNotifyCtrl.selfCoreId < CSL_CORE_ID_MAX)
-    {
-        pMailboxConfig = &gIpcNotifyMailboxConfig[gIpcNotifyCtrl.selfCoreId][gIpcNotifyCtrl.selfCoreId];
+    pMailboxConfig = &gIpcNotifyMailboxConfig[gIpcNotifyCtrl.selfCoreId][gIpcNotifyCtrl.selfCoreId];
+
+    *mailboxBaseAddr = pMailboxConfig->readReqMailboxBaseAddr;
 
-        *mailboxBaseAddr = pMailboxConfig->readReqMailboxBaseAddr;
-    }
-    else
-    {
-        *mailboxBaseAddr = NULL;
-    }
 }
 
 static inline void IpcNotify_getReadSwQ(uint32_t remoteCoreId, IpcNotify_SwQueue **swQ)
 {
     IpcNotify_MailboxConfig *pMailboxConfig;
 
-    if(gIpcNotifyCtrl.selfCoreId < CSL_CORE_ID_MAX && remoteCoreId < CSL_CORE_ID_MAX)
-    {
-        pMailboxConfig = &gIpcNotifyMailboxConfig[remoteCoreId][gIpcNotifyCtrl.selfCoreId];
+    pMailboxConfig = &gIpcNotifyMailboxConfig[remoteCoreId][gIpcNotifyCtrl.selfCoreId];
 
-        *swQ = pMailboxConfig->swQ;
-    }
-    else
-    {
-        *swQ = NULL;
-    }
+    *swQ = pMailboxConfig->swQ;
 }
 
 static inline uint32_t IpcNotify_makeMsg(uint16_t clientId, uint32_t msgValue)
 {
-    return ((clientId & (IPC_NOTIFY_CLIENT_ID_MAX-1)) << IPC_NOTIFY_CLIENT_ID_SHIFT) |
-            (msgValue & (IPC_NOTIFY_MSG_VALUE_MAX-1))
+    return ((clientId & (IPC_NOTIFY_CLIENT_ID_MAX-1U)) << IPC_NOTIFY_CLIENT_ID_SHIFT) |
+            (msgValue & (IPC_NOTIFY_MSG_VALUE_MAX-1U))
             ;
 }
 
 void IpcNotify_isr(void *args)
 {
-    IpcNotify_InterruptConfig *pInterruptConfig = (IpcNotify_InterruptConfig *) args;
+    IpcNotify_InterruptConfig *pInterruptConfig = (IpcNotify_InterruptConfig *) args;
     uint32_t mailboxBaseAddr;
     IpcNotify_SwQueue *swQ;
     uint32_t core, value;
     uint16_t clientId;
+    uint32_t remoteCoreId;
     int32_t status;
     uint32_t pendingIntr;
 
     IpcNotify_getReadMailbox(&mailboxBaseAddr);
-    DebugP_assertNoLog(mailboxBaseAddr!=NULL);
+    DebugP_assertNoLog(mailboxBaseAddr!=0U);
 
     pendingIntr = IpcNotify_mailboxGetPendingIntr(mailboxBaseAddr);
     do
     {
+        /*
+         * Processor sending will trigger read request multiple times and ensure
+         * that read request is reached to receiving processor. The delay implemented
+         * here is not to clear the interrupt while sending processor is reading back
+         * and verifying the interrupt is triggered at receving Processor.
+         *
+         * NOTE: This workaround is currently implemented only for AWR294x SOC.
+         */
+        IpcNotify_wait();
+
         /* We clear pending interrupt unconditional here, and read all the SW queues later */
         IpcNotify_mailboxClearPendingIntr(mailboxBaseAddr, pendingIntr);
 
@@ -144,7 +148,7 @@ void IpcNotify_isr(void *args)
             /* handle non notify interrupts, if any */
             for(core=0; core<gIpcNotifyCtrl.nonNotifyNumCores; core++)
             {
-                if( IpcNotify_mailboxIsPendingIntr(pendingIntr, gIpcNotifyCtrl.nonNotifyCoreList[core]) )
+                if( (IpcNotify_mailboxIsPendingIntr(pendingIntr, gIpcNotifyCtrl.nonNotifyCoreList[core])) != 0U)
                 {
                     gIpcNotifyCtrl.nonNotifyCallback(gIpcNotifyCtrl.nonNotifyCoreList[core]);
                 }
@@ -153,32 +157,36 @@ void IpcNotify_isr(void *args)
 
         for(core=0; core<pInterruptConfig->numCores; core++)
         {
-            IpcNotify_getReadSwQ(pInterruptConfig->coreIdList[core], &swQ);
-            DebugP_assertNoLog(swQ!=NULL);
+            remoteCoreId = pInterruptConfig->coreIdList[core];
 
-            do
+            if(gIpcNotifyCtrl.isCoreEnabled[remoteCoreId] != 0U)
             {
-                status = IpcNotify_mailboxReadSwQ(swQ, &value);
-                if(status == SystemP_SUCCESS)
+                IpcNotify_getReadSwQ(remoteCoreId, &swQ);
+                DebugP_assertNoLog(swQ!=NULL);
+                do
                 {
-                    clientId = (value >> IPC_NOTIFY_CLIENT_ID_SHIFT) & (IPC_NOTIFY_CLIENT_ID_MAX-1);
-
-                    if(gIpcNotifyCtrl.callback[clientId]!=NULL)
+                    status = IpcNotify_mailboxReadSwQ(swQ, &value);
+                    if(status == SystemP_SUCCESS)
                     {
-                        gIpcNotifyCtrl.callback[clientId](
-                                pInterruptConfig->coreIdList[core],
-                                clientId,
-                                (value & (IPC_NOTIFY_MSG_VALUE_MAX-1)),
-                                gIpcNotifyCtrl.callbackArgs[clientId]
-                                );
+                        clientId = (value >> IPC_NOTIFY_CLIENT_ID_SHIFT) & (IPC_NOTIFY_CLIENT_ID_MAX-1U);
+
+                        if(gIpcNotifyCtrl.callback[clientId]!=NULL)
+                        {
+                            gIpcNotifyCtrl.callback[clientId](
+                                    pInterruptConfig->coreIdList[core],
+                                    clientId,
+                                    (value & (IPC_NOTIFY_MSG_VALUE_MAX-1U)),
+                                    gIpcNotifyCtrl.callbackArgs[clientId]
+                                    );
+                        }
                     }
-                }
-            } while(status == SystemP_SUCCESS);
+                } while(status == SystemP_SUCCESS);
+            }
         }
 
         /* we need to keeping doing this until all status bits are 0, else we dont get new interrupt at R5F */
         pendingIntr = IpcNotify_mailboxGetPendingIntr(mailboxBaseAddr);
-    } while ( pendingIntr != 0 );
+    } while ( pendingIntr != 0U );
 
 }
 
@@ -189,25 +197,26 @@ int32_t IpcNotify_sendMsg(uint32_t remoteCoreId, uint16_t remoteClientId, uint32
     IpcNotify_SwQueue *swQ;
     int32_t status = SystemP_FAILURE;
 
-    if(remoteCoreId < CSL_CORE_ID_MAX && gIpcNotifyCtrl.isCoreEnabled[remoteCoreId])
+
+    if((remoteCoreId < CSL_CORE_ID_MAX) && (gIpcNotifyCtrl.isCoreEnabled[remoteCoreId] != 0U))
     {
         uint32_t value = IpcNotify_makeMsg(remoteClientId, msgValue);
 
         IpcNotify_getWriteMailbox(remoteCoreId, &mailboxBaseAddr, &intrBitPos, &swQ);
-        DebugP_assert(mailboxBaseAddr!=NULL);
+        DebugP_assert(mailboxBaseAddr!=0U);
         DebugP_assert(swQ!=NULL);
 
         oldIntState = HwiP_disable();
         do
         {
             status = IpcNotify_mailboxWrite(mailboxBaseAddr, intrBitPos, swQ, value);
-            if(status != SystemP_SUCCESS && waitForFifoNotFull)
+            if((status != SystemP_SUCCESS) && (waitForFifoNotFull != 0U))
             {
                 /* allow interrupt enable and check again */
                 HwiP_restore(oldIntState);
                 oldIntState = HwiP_disable();
             }
-        } while(status != SystemP_SUCCESS  && waitForFifoNotFull);
+        } while((status != SystemP_SUCCESS)  && (waitForFifoNotFull != 0U));
 
         HwiP_restore(oldIntState);
 
@@ -224,6 +233,8 @@ int32_t IpcNotify_registerClient(uint16_t localClientId, IpcNotify_FxnCallback m
     int32_t status = SystemP_FAILURE;
     uint32_t oldIntState;
 
+    DebugP_assert(msgCallback != NULL);
+
     if(localClientId < IPC_NOTIFY_CLIENT_ID_MAX)
     {
         oldIntState = HwiP_disable();
@@ -241,16 +252,18 @@ int32_t IpcNotify_registerClient(uint16_t localClientId, IpcNotify_FxnCallback m
 int32_t IpcNotify_unregisterClient(uint16_t localClientId)
 {
     uint32_t oldIntState;
+    int32_t status = SystemP_FAILURE;
 
     oldIntState = HwiP_disable();
     if(localClientId < IPC_NOTIFY_CLIENT_ID_MAX)
     {
         gIpcNotifyCtrl.callback[localClientId] = NULL;
         gIpcNotifyCtrl.callbackArgs[localClientId] = NULL;
+        status = SystemP_SUCCESS;
     }
     HwiP_restore(oldIntState);
 
-    return SystemP_SUCCESS;
+    return status;
 }
 
 void IpcNotify_syncCallback(uint32_t remoteCoreId, uint16_t localClientId, uint32_t msgValue, void *args)
@@ -265,6 +278,7 @@ void IpcNotify_Params_init(IpcNotify_Params *params)
 {
     uint32_t i;
 
+    params->intrPriority = IPC_NOTIFY_DEFAULT_INTR_PRIORITY;
     params->numCores = 0;
     for(i=0; i<CSL_CORE_ID_MAX; i++)
     {
@@ -279,10 +293,14 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
     uint32_t i, core, oldIntState;
     int32_t status = SystemP_SUCCESS;
     uint32_t mailboxBaseAddr;
+    uint32_t coreIDlist_InterruptCheck;
+    uint32_t coreID_Check = (params->selfCoreId < CSL_CORE_ID_MAX)?1U:0U;
 
+    IpcNotify_allocSwQueue(&gIpcNotifyMailboxConfig[0][0]);
     IpcNotify_getConfig(&gIpcNotifyCtrl.interruptConfig, &gIpcNotifyCtrl.interruptConfigNum);
 
-    DebugP_assert(params->selfCoreId < CSL_CORE_ID_MAX);
+    DebugP_assert(coreID_Check!=0U);
+
     gIpcNotifyCtrl.selfCoreId = params->selfCoreId;
     for(i=0; i<IPC_NOTIFY_CLIENT_ID_MAX; i++)
     {
@@ -300,7 +318,8 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
     /* check parameters and config and assert if invalid */
     for(core=0; core<params->numCores; core++)
     {
-        DebugP_assert(params->coreIdList[core] < CSL_CORE_ID_MAX);
+        uint32_t coreIDlist_Check = (params->coreIdList[core] < CSL_CORE_ID_MAX)?1U:0U;
+        DebugP_assert(coreIDlist_Check!=0U);
         DebugP_assert(params->coreIdList[core] != params->selfCoreId);
         /* mark core as enabled for IPC */
         gIpcNotifyCtrl.isCoreEnabled[params->coreIdList[core]] = 1;
@@ -308,7 +327,7 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
     /* fill list of non notify cores */
     for(core=0; core<CSL_CORE_ID_MAX; core++)
     {
-        if(gIpcNotifyCtrl.isCoreEnabled[core]==0 && core != gIpcNotifyCtrl.selfCoreId)
+        if((gIpcNotifyCtrl.isCoreEnabled[core]==0U) && (core != gIpcNotifyCtrl.selfCoreId))
         {
             gIpcNotifyCtrl.nonNotifyCoreList[gIpcNotifyCtrl.nonNotifyNumCores] = core;
             gIpcNotifyCtrl.nonNotifyNumCores++;
@@ -320,15 +339,16 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
 
         pInterruptConfig = &gIpcNotifyCtrl.interruptConfig[i];
 
-        DebugP_assert(pInterruptConfig->numCores > 0 );
+        DebugP_assert(pInterruptConfig->numCores > 0U );
         for(core=0; core<pInterruptConfig->numCores; core++)
         {
-            DebugP_assert(pInterruptConfig->coreIdList[core] < CSL_CORE_ID_MAX);
+            coreIDlist_InterruptCheck = (pInterruptConfig->coreIdList[core] < CSL_CORE_ID_MAX)?1U:0U;
+            DebugP_assert(coreIDlist_InterruptCheck!=0U);
             DebugP_assert(pInterruptConfig->coreIdList[core] != gIpcNotifyCtrl.selfCoreId);
         }
         /* check if mailbox info is valid for this core */
         IpcNotify_getReadMailbox(&mailboxBaseAddr);
-        DebugP_assert(mailboxBaseAddr!=NULL);
+        DebugP_assert(mailboxBaseAddr!=0U);
     }
 
     IpcNotify_registerClient(IPC_NOTIFY_CLIENT_ID_SYNC, IpcNotify_syncCallback, NULL);
@@ -344,19 +364,20 @@ int32_t IpcNotify_init(const IpcNotify_Params *params)
 
         IpcNotify_getReadMailbox(&mailboxBaseAddr);
 
-        if(pInterruptConfig->clearIntOnInit)
+        if((pInterruptConfig->clearIntOnInit) != 0U)
         {
             IpcNotify_mailboxClearAllInt(mailboxBaseAddr);
         }
 
         HwiP_Params_init(&hwiParams);
         hwiParams.intNum = pInterruptConfig->intNum;
+        hwiParams.priority = params->intrPriority;
         hwiParams.callback = IpcNotify_isr;
         hwiParams.args = (void*)pInterruptConfig;
         hwiParams.eventId = pInterruptConfig->eventId;
         hwiParams.isPulse = 0;
 
-        status |= HwiP_construct(
+        status += HwiP_construct(
             &pInterruptConfig->hwiObj,
             &hwiParams);
     }
@@ -424,13 +445,14 @@ int32_t IpcNotify_waitSync(uint32_t remoteCoreId, uint32_t timeout)
     int32_t status = SystemP_FAILURE;
     uint32_t startTicks, eslapedTicks, isDone;
 
-    if(remoteCoreId < CSL_CORE_ID_MAX && gIpcNotifyCtrl.isCoreEnabled[remoteCoreId])
+
+    if((remoteCoreId < CSL_CORE_ID_MAX) && (gIpcNotifyCtrl.isCoreEnabled[remoteCoreId] != 0U))
     {
         startTicks = ClockP_getTicks();
         isDone = 0;
-        while(!isDone)
+        while(isDone == 0U)
         {
-            if(gIpcNotifyCtrl.syncMsgPend[remoteCoreId] ==  0)
+            if(gIpcNotifyCtrl.syncMsgPend[remoteCoreId] ==  0U)
             {
                 eslapedTicks = ClockP_getTicks() - startTicks;
                 if(eslapedTicks>=timeout)
@@ -467,7 +489,7 @@ int32_t IpcNotify_syncAll(uint32_t timeout)
 
     for(remoteCoreId=0; remoteCoreId<CSL_CORE_ID_MAX; remoteCoreId++)
     {
-        if(gIpcNotifyCtrl.isCoreEnabled[remoteCoreId])
+        if((gIpcNotifyCtrl.isCoreEnabled[remoteCoreId]) != 0U)
         {
             /* no need to check return status, this will always pass */
             IpcNotify_sendSync(remoteCoreId);
@@ -475,7 +497,7 @@ int32_t IpcNotify_syncAll(uint32_t timeout)
     }
     for(remoteCoreId=0; remoteCoreId<CSL_CORE_ID_MAX; remoteCoreId++)
     {
-        if(gIpcNotifyCtrl.isCoreEnabled[remoteCoreId])
+        if((gIpcNotifyCtrl.isCoreEnabled[remoteCoreId]) != 0U)
         {
             status = IpcNotify_waitSync(remoteCoreId, timeout);
             if(status != SystemP_SUCCESS)
diff --git a/source/drivers/ipc_notify/v1/ipc_notify_v1.h b/source/drivers/ipc_notify/v1/ipc_notify_v1.h
index 44d6aa92b3..6d06754ef3 100644
--- a/source/drivers/ipc_notify/v1/ipc_notify_v1.h
+++ b/source/drivers/ipc_notify/v1/ipc_notify_v1.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -93,10 +93,27 @@ extern IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE
  */
 void IpcNotify_getConfig(IpcNotify_InterruptConfig **interruptConfig, uint32_t *interruptConfigNum);
 
+/**
+ * \brief Function that is generated via SysConfig to return the Queue memory configuration.
+ *
+ * This function is invoked by \ref IpcNotify_init() to get the Queue memory configuration.
+ *
+ * This function is generated vis SysConfig as this allows to keep the drivers library
+ * independant of the core that it is running on.
+ *
+ * Any core specific config and logic is generated by SysConfig
+ */
+void IpcNotify_allocSwQueue(IpcNotify_MailboxConfig *mailboxConfig);
+
+/**
+ * \brief wait for approximatly 0.6usec as part of Mailbox Errata workaround.
+ *
+ * Note: This function is applicable for only AWR294x SOC.
+ */
+void IpcNotify_wait(void);
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* IPC_NOTIFY_V0_H_ */
-
diff --git a/source/drivers/ipc_notify/v1/ipc_notify_v1_mailbox.h b/source/drivers/ipc_notify/v1/ipc_notify_v1_mailbox.h
index da9615569d..9cbe58ed99 100644
--- a/source/drivers/ipc_notify/v1/ipc_notify_v1_mailbox.h
+++ b/source/drivers/ipc_notify/v1/ipc_notify_v1_mailbox.h
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -63,30 +63,39 @@ typedef struct {
 
 } IpcNotify_SwQueue;
 
+extern void IpcNotify_trigInterrupt(uint32_t mailboxBaseAddr, uint32_t intrBitPos);
+
+#if defined(__aarch64__) || defined(__arm__)
+static inline void IpcNotify_dataAndInstructionBarrier(void)
+{
+    __asm__ __volatile__ ( "dsb sy"  "\n\t": : : "memory");
+    __asm__ __volatile__ ( "isb"     "\n\t": : : "memory");
+}
+#endif
+
 /* read from SW fifo within a mailbox  */
 static inline int32_t IpcNotify_mailboxReadSwQ(IpcNotify_SwQueue *swQ, uint32_t *value)
 {
     int32_t status = SystemP_FAILURE;
 
-    volatile uint32_t rdIdx = swQ->rdIdx;
-    volatile uint32_t wrIdx = swQ->wrIdx;
+    uint32_t rdIdx = swQ->rdIdx;
+    uint32_t wrIdx = swQ->wrIdx;
 
-    if(rdIdx < MAILBOX_MAX_MSGS_IN_SW_FIFO && wrIdx < MAILBOX_MAX_MSGS_IN_SW_FIFO)
+    if((rdIdx < MAILBOX_MAX_MSGS_IN_SW_FIFO) && (wrIdx < MAILBOX_MAX_MSGS_IN_SW_FIFO))
     {
         if( rdIdx != wrIdx)
         {
             /* there is something in the FIFO */
             *value = swQ->fifo[rdIdx];
 
-            rdIdx = (rdIdx+1)%MAILBOX_MAX_MSGS_IN_SW_FIFO;
+            rdIdx = (rdIdx+1U)%MAILBOX_MAX_MSGS_IN_SW_FIFO;
 
             swQ->rdIdx = rdIdx;
 
             rdIdx = swQ->rdIdx; /* read back to ensure the update has reached the memory */
 
             #if defined(__aarch64__) || defined(__arm__)
-            __asm__ __volatile__ ( "dsb sy"  "\n\t": : : "memory");
-            __asm__ __volatile__ ( "isb"     "\n\t": : : "memory");
+            IpcNotify_dataAndInstructionBarrier();
             #endif
             #if defined(_TMS320C6X)
             _mfence();
@@ -105,27 +114,24 @@ static inline int32_t IpcNotify_mailboxWrite(uint32_t mailboxBaseAddr, uint32_t
 {
     int32_t status = SystemP_FAILURE;
 
-    volatile uint32_t rdIdx = swQ->rdIdx;
-    volatile uint32_t wrIdx = swQ->wrIdx;
+    uint32_t rdIdx = swQ->rdIdx;
+    uint32_t wrIdx = swQ->wrIdx;
 
-    if(rdIdx < MAILBOX_MAX_MSGS_IN_SW_FIFO && wrIdx < MAILBOX_MAX_MSGS_IN_SW_FIFO)
+    if((rdIdx < MAILBOX_MAX_MSGS_IN_SW_FIFO) && (wrIdx < MAILBOX_MAX_MSGS_IN_SW_FIFO))
     {
-        if( ( (wrIdx+1)%MAILBOX_MAX_MSGS_IN_SW_FIFO ) != rdIdx )
+        if( ( (wrIdx+1U)%MAILBOX_MAX_MSGS_IN_SW_FIFO ) != rdIdx )
         {
-            volatile uint32_t *addr = (uint32_t *)mailboxBaseAddr;
-
             /* there is some space in the FIFO */
             swQ->fifo[wrIdx] = value;
 
-            wrIdx = (wrIdx+1)%MAILBOX_MAX_MSGS_IN_SW_FIFO;
+            wrIdx = (wrIdx+1U)%MAILBOX_MAX_MSGS_IN_SW_FIFO;
 
             swQ->wrIdx = wrIdx;
 
             wrIdx = swQ->wrIdx; /* read back to ensure the update has reached the memory */
 
             #if defined(__aarch64__) || defined(__arm__)
-            __asm__ __volatile__ ( "dsb sy" "\n\t": : : "memory");
-            __asm__ __volatile__ ( "isb"    "\n\t": : : "memory");
+            IpcNotify_dataAndInstructionBarrier();
             #endif
             #if defined(_TMS320C6X)
             _mfence();
@@ -133,7 +139,7 @@ static inline int32_t IpcNotify_mailboxWrite(uint32_t mailboxBaseAddr, uint32_t
             #endif
 
             /* trigger interrupt to other core */
-            *addr = (1U << intrBitPos);
+            IpcNotify_trigInterrupt(mailboxBaseAddr, intrBitPos);
 
             status = SystemP_SUCCESS;
         }
@@ -168,7 +174,7 @@ static inline uint32_t IpcNotify_mailboxIsPendingIntr(uint32_t pendingIntr, uint
     uint32_t isPending = 0;
     if(coreId<CSL_CORE_ID_MAX)
     {
-        isPending = pendingIntr & (1 << gIpcNotifyCoreIntrBitPos[coreId]);
+        isPending = pendingIntr & ((uint32_t)1 << gIpcNotifyCoreIntrBitPos[coreId]);
     }
     return isPending;
 }
diff --git a/source/drivers/ipc_notify/v1/soc/am263x/ipc_notify_v1_cfg.c b/source/drivers/ipc_notify/v1/soc/am263x/ipc_notify_v1_cfg.c
index 2764016521..e2f58af156 100644
--- a/source/drivers/ipc_notify/v1/soc/am263x/ipc_notify_v1_cfg.c
+++ b/source/drivers/ipc_notify/v1/soc/am263x/ipc_notify_v1_cfg.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -54,34 +54,6 @@
 #define R5FSS1_0_MBOX_READ_REQ_INTR ( 136U)
 #define R5FSS1_1_MBOX_READ_REQ_INTR ( 136U)
 
-/* dedicated mailbox memories address and size */
-#define MSS_MBOX_MEM                (CSL_MBOX_SRAM_U_BASE)
-#define MSS_MBOX_MEM_SIZE           (16U*1024U)
-
-/*
- * SW queue between each pair of CPUs
- *
- * place SW queues at the bottom of the dedicated mailbox memories.
- * Driver assume this memory is init to zero in bootloader as it's ECC protected and
- * needs to be intialized only once and to ensure that only one core has done the
- * mailbox ram initialization before ipc_init. If SBL is not used then Gel does the initialization.
- * We need 4*3 SW Q's for the 4x R5F to send messages to each other, i.e 384 B.
- *
- * Rest of the mailbox memory cna be used for ipc_rpmessage or custom message passing.
- */
-#define R5FSS0_0_TO_R5FSS0_1_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*12)
-#define R5FSS0_0_TO_R5FSS1_0_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*11)
-#define R5FSS0_0_TO_R5FSS1_1_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*10)
-#define R5FSS0_1_TO_R5FSS0_0_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*9)
-#define R5FSS0_1_TO_R5FSS1_0_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*8)
-#define R5FSS0_1_TO_R5FSS1_1_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*7)
-#define R5FSS1_0_TO_R5FSS0_0_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*6)
-#define R5FSS1_0_TO_R5FSS0_1_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*5)
-#define R5FSS1_0_TO_R5FSS1_1_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*4)
-#define R5FSS1_1_TO_R5FSS0_0_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*3)
-#define R5FSS1_1_TO_R5FSS0_1_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*2)
-#define R5FSS1_1_TO_R5FSS1_0_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*1)
-
 /* shift to apply in mailbox addr to get to core specific status */
 uint32_t gIpcNotifyCoreIntrBitPos[] =
 {
@@ -113,19 +85,19 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_1_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_0_TO_R5FSS0_1_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS1_0 */
             .writeDoneMailboxBaseAddr = R5FSS0_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_0_MBOX_READ_REQ,
             .intrBitPos = R5FSS1_0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_0_TO_R5FSS1_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS1_1 */
             .writeDoneMailboxBaseAddr = R5FSS0_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_0_MBOX_READ_REQ,
             .intrBitPos = R5FSS1_1_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_0_TO_R5FSS1_1_SW_QUEUE,
+            .swQ = NULL,
         },
     },
     /* R5FSS0-1 */
@@ -134,7 +106,7 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_1_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_1_TO_R5FSS0_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS0_1 */
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
@@ -146,13 +118,13 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_1_MBOX_READ_REQ,
             .intrBitPos = R5FSS1_0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_1_TO_R5FSS1_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS1_1 */
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_1_MBOX_READ_REQ,
             .intrBitPos = R5FSS1_1_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_1_TO_R5FSS1_1_SW_QUEUE,
+            .swQ = NULL,
         },
     },
         /* R5FSS1-0 */
@@ -161,13 +133,13 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS1_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS1_0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS1_0_TO_R5FSS0_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS0_1 */
             .writeDoneMailboxBaseAddr = R5FSS1_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS1_0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_1_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS1_0_TO_R5FSS0_1_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS1_0 */
             .writeDoneMailboxBaseAddr = R5FSS1_0_MBOX_WRITE_DONE,
@@ -179,7 +151,7 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS1_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS1_0_MBOX_READ_REQ,
             .intrBitPos = R5FSS1_1_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS1_0_TO_R5FSS1_1_SW_QUEUE,
+            .swQ = NULL,
         },
     },
         /* R5FSS1-1 */
@@ -188,19 +160,19 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS1_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS1_1_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS1_1_TO_R5FSS0_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS0_1 */
             .writeDoneMailboxBaseAddr = R5FSS1_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS1_1_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_1_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS1_1_TO_R5FSS0_1_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS1_0 */
             .writeDoneMailboxBaseAddr = R5FSS1_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS1_1_MBOX_READ_REQ,
             .intrBitPos = R5FSS1_0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS1_1_TO_R5FSS1_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS1_1 */
             .writeDoneMailboxBaseAddr = R5FSS1_1_MBOX_WRITE_DONE,
@@ -222,7 +194,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_0[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS0_1,
             CSL_CORE_ID_R5FSS1_0,
             CSL_CORE_ID_R5FSS1_1,
+            CSL_CORE_ID_MAX,
         },
+	.clearIntOnInit = 0,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss0_0 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS0_0_NUM;
@@ -238,8 +212,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_1[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS0_0,
             CSL_CORE_ID_R5FSS1_0,
             CSL_CORE_ID_R5FSS1_1,
+            CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 0,
+	.clearIntOnInit = 0,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss0_1 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS0_1_NUM;
@@ -255,8 +230,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss1_0[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS0_0,
             CSL_CORE_ID_R5FSS0_1,
             CSL_CORE_ID_R5FSS1_1,
+            CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 0,
+	.clearIntOnInit = 0,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss1_0 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS1_0_NUM;
@@ -272,8 +248,21 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss1_1[IPC_NOFTIY_INTERRUP
             CSL_CORE_ID_R5FSS0_0,
             CSL_CORE_ID_R5FSS0_1,
             CSL_CORE_ID_R5FSS1_0,
+            CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 0,
+	.clearIntOnInit = 0,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss1_1 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS1_1_NUM;
+
+void IpcNotify_trigInterrupt(uint32_t mailboxBaseAddr, uint32_t intrBitPos)
+{
+    volatile uint32_t *addr = (uint32_t *)mailboxBaseAddr;
+
+    /* trigger interrupt to other core */
+    *addr = ((uint32_t)1U << intrBitPos);
+}
+
+void IpcNotify_wait(void)
+{
+}
diff --git a/source/drivers/ipc_notify/v1/soc/am273x/ipc_notify_v1_cfg.c b/source/drivers/ipc_notify/v1/soc/am273x/ipc_notify_v1_cfg.c
index 1c74d7ca1e..7c9a3ad523 100644
--- a/source/drivers/ipc_notify/v1/soc/am273x/ipc_notify_v1_cfg.c
+++ b/source/drivers/ipc_notify/v1/soc/am273x/ipc_notify_v1_cfg.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -50,31 +50,6 @@
 #define R5FSS0_1_MBOX_READ_REQ_INTR ( 79U)
 #define C66SS0_MBOX_READ_REQ_INTR   ( 94U)
 
-/* dedicated mailbox memories address and size */
-#define MSS_MBOX_MEM                (CSL_MSS_MBOX_U_BASE)
-#define MSS_MBOX_MEM_SIZE           (8U*1024U)
-#define DSS_MBOX_MEM                (CSL_DSS_MAILBOX_U_BASE)
-#define DSS_MBOX_MEM_SIZE           (4U*1024U)
-
-/*
- * SW queue between each pair of CPUs
- *
- * place SW queues at the bottom of the dedicated mailbox memories.
- * Driver assume this memory is init to zero in bootloader as it's ECC protected and
- * needs to be intialized only once and to ensure that only one core has done the
- * mailbox ram initialization before ipc_init. If SBL is not used then Gel does the initialization.
- * We need 4 SW Q's for the 2x R5F to send messages to C66SS0 and each other, i.e 128 B
- * and we need 2 SW Q's for C66SS0 to send messages to each R5F, i.e 64 B
- *
- * Rest of the mailbox memory cna be used for ipc_rpmessage or custom message passing
- */
-#define C66SS0_TO_R5FSS0_0_SW_QUEUE        (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*6)
-#define C66SS0_TO_R5FSS0_1_SW_QUEUE        (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*5)
-#define R5FSS0_1_TO_R5FSS0_0_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*4)
-#define R5FSS0_1_TO_C66SS0_SW_QUEUE        (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*3)
-#define R5FSS0_0_TO_R5FSS0_1_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*2)
-#define R5FSS0_0_TO_C66SS0_SW_QUEUE        (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*1)
-
 /* shift to apply in mailbox addr to get to core specific status */
 uint32_t gIpcNotifyCoreIntrBitPos[] =
 {
@@ -105,13 +80,13 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_1_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_0_TO_R5FSS0_1_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with C66SS0 */
             .writeDoneMailboxBaseAddr = R5FSS0_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_0_MBOX_READ_REQ,
             .intrBitPos = C66SS0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_0_TO_C66SS0_SW_QUEUE,
+            .swQ = NULL,
         },
     },
     /* R5FSS0-1 */
@@ -120,7 +95,7 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_1_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_1_TO_R5FSS0_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS0_1 */
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
@@ -132,7 +107,7 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_1_MBOX_READ_REQ,
             .intrBitPos = C66SS0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_1_TO_C66SS0_SW_QUEUE,
+            .swQ = NULL,
         },
     },
     /* C66SS0 */
@@ -141,13 +116,13 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = C66SS0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = C66SS0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_0_MBOX_PROC_BIT_POS,
-            .swQ = C66SS0_TO_R5FSS0_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS0_1 */
             .writeDoneMailboxBaseAddr = C66SS0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = C66SS0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_1_MBOX_PROC_BIT_POS,
-            .swQ = C66SS0_TO_R5FSS0_1_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with C66SS0 */
             .writeDoneMailboxBaseAddr = C66SS0_MBOX_WRITE_DONE,
@@ -168,8 +143,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_0[IPC_NOFTIY_INTERRUP
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_R5FSS0_1,
             CSL_CORE_ID_C66SS0,
+            CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 0,
+	.clearIntOnInit = 0,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss0_0 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS0_0_NUM;
@@ -184,8 +160,9 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_1[IPC_NOFTIY_INTERRUP
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_R5FSS0_0,
             CSL_CORE_ID_C66SS0,
+            CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 0,
+	.clearIntOnInit = 0,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss0_1 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS0_1_NUM;
@@ -200,8 +177,21 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_c66ss0[IPC_NOFTIY_INTERRUPT_
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_R5FSS0_0,
             CSL_CORE_ID_R5FSS0_1,
+            CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 1,
+	.clearIntOnInit = 1,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_c66ss0 = IPC_NOFTIY_INTERRUPT_CONFIG_C66SS0_NUM;
+
+void IpcNotify_trigInterrupt(uint32_t mailboxBaseAddr, uint32_t intrBitPos)
+{
+    volatile uint32_t *addr = (uint32_t *)mailboxBaseAddr;
+
+    /* trigger interrupt to other core */
+    *addr = (1U << intrBitPos);
+}
+
+void IpcNotify_wait(void)
+{
+}
diff --git a/source/drivers/ipc_notify/v1/soc/awr294x/ipc_notify_v1_cfg.c b/source/drivers/ipc_notify/v1/soc/awr294x/ipc_notify_v1_cfg.c
index 3f8e8eec19..fe0bb36240 100644
--- a/source/drivers/ipc_notify/v1/soc/awr294x/ipc_notify_v1_cfg.c
+++ b/source/drivers/ipc_notify/v1/soc/awr294x/ipc_notify_v1_cfg.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2018-2021 Texas Instruments Incorporated
+ *  Copyright (C) 2018-2023 Texas Instruments Incorporated
  *
  *  Redistribution and use in source and binary forms, with or without
  *  modification, are permitted provided that the following conditions
@@ -51,30 +51,10 @@
 #define R5FSS0_1_MBOX_READ_REQ_INTR ( 79U)
 #define C66SS0_MBOX_READ_REQ_INTR   ( 94U)
 
-/* dedicated mailbox memories address and size */
-#define MSS_MBOX_MEM                (CSL_MSS_MBOX_U_BASE)
-#define MSS_MBOX_MEM_SIZE           (8U*1024U)
-#define DSS_MBOX_MEM                (CSL_DSS_MAILBOX_U_BASE)
-#define DSS_MBOX_MEM_SIZE           (4U*1024U)
-
-/*
- * SW queue between each pair of CPUs
- *
- * place SW queues at the bottom of the dedicated mailbox memories.
- * Driver assume this memory is init to zero in bootloader as it's ECC protected and
- * needs to be intialized only once and to ensure that only one core has done the
- * mailbox ram initialization before ipc_init. If SBL is not used then Gel does the initialization.
- * We need 4 SW Q's for the 2x R5F to send messages to C66SS0 and each other, i.e 128 B
- * and we need 2 SW Q's for C66SS0 to send messages to each R5F, i.e 64 B
- *
- * Rest of the mailbox memory cna be used for ipc_rpmessage or custom message passing
+/* A delay of 0.5uSec is recommended before clear pending read request from remote core
+ * This delay is implemented as a loop and is profiled to be approximately 0.6uSec
  */
-#define C66SS0_TO_R5FSS0_0_SW_QUEUE        (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*6)
-#define C66SS0_TO_R5FSS0_1_SW_QUEUE        (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*5)
-#define R5FSS0_1_TO_R5FSS0_0_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*4)
-#define R5FSS0_1_TO_C66SS0_SW_QUEUE        (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*3)
-#define R5FSS0_0_TO_R5FSS0_1_SW_QUEUE      (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*2)
-#define R5FSS0_0_TO_C66SS0_SW_QUEUE        (IpcNotify_SwQueue*)(MSS_MBOX_MEM + MSS_MBOX_MEM_SIZE - MAILBOX_MAX_SW_QUEUE_SIZE*1)
+#define IPC_NOTIFY_WAIT_CYCLES           (17U)
 
 /* shift to apply in mailbox addr to get to core specific status */
 uint32_t gIpcNotifyCoreIntrBitPos[] =
@@ -107,14 +87,20 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_1_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_0_TO_R5FSS0_1_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with C66SS0 */
             .writeDoneMailboxBaseAddr = R5FSS0_0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_0_MBOX_READ_REQ,
             .intrBitPos = C66SS0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_0_TO_C66SS0_SW_QUEUE,
+            .swQ = NULL,
         },
+		{ /* with RSS_R4 */
+			.writeDoneMailboxBaseAddr = 0U,
+			.readReqMailboxBaseAddr = 0U,
+			.intrBitPos = 0U,
+			.swQ = NULL,
+		},
     },
     /* R5FSS0-1 */
     {
@@ -122,7 +108,7 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_1_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_1_TO_R5FSS0_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS0_1 */
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
@@ -134,8 +120,14 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = R5FSS0_1_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = R5FSS0_1_MBOX_READ_REQ,
             .intrBitPos = C66SS0_MBOX_PROC_BIT_POS,
-            .swQ = R5FSS0_1_TO_C66SS0_SW_QUEUE,
+            .swQ = NULL,
         },
+		{ /* with RSS_R4 */
+			.writeDoneMailboxBaseAddr = 0U,
+			.readReqMailboxBaseAddr = 0U,
+			.intrBitPos = 0U,
+			.swQ = NULL,
+		},
     },
     /* C66SS0 */
     {
@@ -143,13 +135,13 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .writeDoneMailboxBaseAddr = C66SS0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = C66SS0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_0_MBOX_PROC_BIT_POS,
-            .swQ = C66SS0_TO_R5FSS0_0_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with R5FSS0_1 */
             .writeDoneMailboxBaseAddr = C66SS0_MBOX_WRITE_DONE,
             .readReqMailboxBaseAddr = C66SS0_MBOX_READ_REQ,
             .intrBitPos = R5FSS0_1_MBOX_PROC_BIT_POS,
-            .swQ = C66SS0_TO_R5FSS0_1_SW_QUEUE,
+            .swQ = NULL,
         },
         { /* with C66SS0 */
             .writeDoneMailboxBaseAddr = C66SS0_MBOX_WRITE_DONE,
@@ -157,7 +149,40 @@ IpcNotify_MailboxConfig gIpcNotifyMailboxConfig[CSL_CORE_ID_MAX][CSL_CORE_ID_MAX
             .intrBitPos = C66SS0_MBOX_PROC_BIT_POS,
             .swQ = NULL,
         },
+		{ /* with RSS_R4 */
+			.writeDoneMailboxBaseAddr = 0U,
+			.readReqMailboxBaseAddr = 0U,
+			.intrBitPos = 0U,
+			.swQ = NULL,
+		},
     },
+	/* RSS_R4 */
+	{
+		{ /* with R5FSS0_0 */
+			.writeDoneMailboxBaseAddr = 0U,
+			.readReqMailboxBaseAddr = 0U,
+			.intrBitPos = 0U,
+			.swQ = NULL,
+		},
+		{ /* with R5FSS0_1 */
+			.writeDoneMailboxBaseAddr = 0U,
+			.readReqMailboxBaseAddr = 0U,
+			.intrBitPos = 0U,
+			.swQ = NULL,
+		},
+		{ /* with C66SS0 */
+			.writeDoneMailboxBaseAddr = 0U,
+			.readReqMailboxBaseAddr = 0U,
+			.intrBitPos = 0U,
+			.swQ = NULL,
+		},
+	    { /* with RSS_R4 */
+			.writeDoneMailboxBaseAddr = 0U,
+			.readReqMailboxBaseAddr = 0U,
+			.intrBitPos = 0U,
+			.swQ = NULL,
+		},
+	},
 };
 
 /* Interrupt config for R5FSS0-0 */
@@ -170,8 +195,10 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_0[IPC_NOFTIY_INTERRUP
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_R5FSS0_1,
             CSL_CORE_ID_C66SS0,
+			CSL_CORE_ID_MAX,
+			CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 0,
+	.clearIntOnInit = 0,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss0_0 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS0_0_NUM;
@@ -186,8 +213,10 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_r5fss0_1[IPC_NOFTIY_INTERRUP
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_R5FSS0_0,
             CSL_CORE_ID_C66SS0,
+		    CSL_CORE_ID_MAX,
+			CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 0,
+	.clearIntOnInit = 0,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_r5fss0_1 = IPC_NOFTIY_INTERRUPT_CONFIG_R5FSS0_1_NUM;
@@ -202,8 +231,69 @@ IpcNotify_InterruptConfig gIpcNotifyInterruptConfig_c66ss0[IPC_NOFTIY_INTERRUPT_
         .coreIdList = { /* core ID's tied to this interrupt line */
             CSL_CORE_ID_R5FSS0_0,
             CSL_CORE_ID_R5FSS0_1,
+			CSL_CORE_ID_MAX,
+			CSL_CORE_ID_MAX,
         },
-        .clearIntOnInit = 1,
+	.clearIntOnInit = 1,
     }
 };
 uint32_t gIpcNotifyInterruptConfigNum_c66ss0 = IPC_NOFTIY_INTERRUPT_CONFIG_C66SS0_NUM;
+
+void IpcNotify_trigInterrupt(uint32_t mailboxBaseAddr, uint32_t intrBitPos)
+{
+    uint8_t loop = 0U;
+    volatile uint32_t *addr = (uint32_t *)mailboxBaseAddr;
+    #if defined(__aarch64__) || defined(__arm__)
+    volatile uint32_t *ptrC66MboxReadReq = (volatile uint32_t *)C66SS0_MBOX_READ_REQ;
+    #endif
+    volatile uint32_t *ptrR5F0MboxReadReq = (volatile uint32_t *)R5FSS0_0_MBOX_READ_REQ;
+    volatile uint32_t *ptrR5F1MboxReadReq = (volatile uint32_t *)R5FSS0_1_MBOX_READ_REQ;
+
+    do
+    {
+        /* trigger interrupt to other core */
+        *addr = ((uint32_t)1U << intrBitPos);
+
+        #if defined(__aarch64__) || defined(__arm__)
+
+        /* Check for the read request confirmation */
+        if(((intrBitPos == C66SS0_MBOX_PROC_BIT_POS) && ((*ptrC66MboxReadReq & (1U << R5FSS0_0_MBOX_PROC_BIT_POS))!=0U))||
+			((intrBitPos == R5FSS0_0_MBOX_PROC_BIT_POS) && ((*ptrR5F1MboxReadReq & (1U << R5FSS0_1_MBOX_PROC_BIT_POS))!=0U))||
+			((intrBitPos == R5FSS0_1_MBOX_PROC_BIT_POS) && ((*ptrR5F0MboxReadReq  & (1U << R5FSS0_0_MBOX_PROC_BIT_POS))!=0U)))
+        {
+            break;
+        }
+
+        #endif
+
+        #if defined(_TMS320C6X)
+
+        /* Check for the read request confirmation */
+        if(((intrBitPos == R5FSS0_0_MBOX_PROC_BIT_POS) && ((*ptrR5F0MboxReadReq & (1U << C66SS0_MBOX_PROC_BIT_POS))!=0U))||
+			((intrBitPos == R5FSS0_1_MBOX_PROC_BIT_POS) && ((*ptrR5F1MboxReadReq & (1U << C66SS0_MBOX_PROC_BIT_POS))!=0U)))
+        {
+			break;
+		}
+		
+        #endif
+
+    } while (++loop < 3U);
+}
+
+
+void IpcNotify_wait(void)
+{
+    volatile uint32_t loopCounter = 0U;
+
+    /* Processor sending will trigger read request multiple times and ensure
+    * that read request is reached to receiving processor. The delay implemented
+    * here is not to clear the interrupt while sending processor is reading back
+    * and verifying the interrupt is triggered at receving Processor
+    */
+    for(loopCounter = 0; loopCounter < IPC_NOTIFY_WAIT_CYCLES; loopCounter+=1U)
+	{
+		;
+	}
+    return;
+}
+
